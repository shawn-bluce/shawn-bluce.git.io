<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Linux 中不那么基础的权限 Rwx/acl/suid/sgid/sbit/lsattr/setattr]]></title>
      <url>/2021/06/02/linux-unbasic-permission/</url>
      <content type="html"><![CDATA[<p>-</p>
<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>首先声明这篇博客针对的是中级 Linux 用户，如果你还不清楚 Linux 中的基本权限机制 <code>user/group/other</code> 和 <code>rwx</code> 的话需要先去了解一下对应的基础内容才行。既然标题上写了是“不那么基础的权限”，也就能看出来虽然内容不是很基础，但是也不会很高深。</p>
<p>另外，这篇博客里提到的好多内容都是并不复杂的东西，但是非常零碎，也许你用了十年 Linux 还是不知道其中的一些小知识点，不过也没什么，毕竟这些知识点的使用率真的很低。</p>
<p>如果你看完了这篇博客有那么一点点收获，那我也算是完成目标了；如果你看完后发现所有的内容都是你以前就知道的，那我只能说你对 Linux 权限这部分的掌握超过了大多数人。因为我确实给周围好多人分享过这些内容，从刚实习的朋友到比我工作经历多很多综合实力也强很多的人，几乎没有谁是完全了解这些内容的。（所以说虽然这篇博客并不难，并不是什么高深的知识，但是我比较有信息让你从中获得那么一点点的收获）</p>
<blockquote>
<p>本博客不涉及某个命令的具体用法，只起到一个让你“知道自己哪里不知道”的作用。如果想要仔细了解某个命令或者某个机制，可以自行搜索相关资料。</p>
</blockquote>
<a id="more"></a>

<h1 id="0X01-root-究竟是谁"><a href="#0X01-root-究竟是谁" class="headerlink" title="0X01 root 究竟是谁"></a>0X01 root 究竟是谁</h1><p>“root是谁？”这个问题听起来很蠢，但是实际上好多人并没有思考过这个问题。我们都知道 Linux 中有一个叫做 <code>uid</code> 的东西，其实 root 用户指的就是 <strong>uid为0的用户</strong>，而非用户名为root的用户，我们可以通过 <code>id</code> 命令来查看用户的 uid。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/user_id.png"></p>
<p>而且值得注意的一点是 <strong>uid 是会被回收利用的</strong>。也就是说你创建了一个用户，系统分配了 1002 这个 uid 后，如果删掉这个用户紧接着再创建一个新用户是会敷用 1002 这个 uid 的。假设你删掉了系统中的一个老用户，又创建了个新的用户，那么万一 uid 是重复的就有可能导致这个新用户拥有之前老用户的权限，这是一种很危险的操作。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/user_id_2.png"></p>
<h1 id="0X02-一分钟带过的-rwx"><a href="#0X02-一分钟带过的-rwx" class="headerlink" title="0X02 一分钟带过的 rwx"></a>0X02 一分钟带过的 rwx</h1><p>然后进入正题，也就是真正意义上的权限：<code>rwx/ugo</code> 机制。不过这里就不细说了，假设你已经掌握了基础的这套权限机制。如果你之前不知道 <code>rwx</code> 是三个二进制位，从而用 <code>111/101/110</code> 来表示的 <code>rwx/r-x/rw-</code> 的话现在也知道了。</p>
<h1 id="0X03-基础-rwx-之后的一级：ACL"><a href="#0X03-基础-rwx-之后的一级：ACL" class="headerlink" title="0X03 基础 rwx 之后的一级：ACL"></a>0X03 基础 rwx 之后的一级：ACL</h1><p>我们会发现基础的 rwx/ugo 权限机制只能将权限分配给三种人：文件所属用户、文件所属组、其他。如果你想专门指定给某个用户某个权限的话，是做不到的。那么 ACL 就是来解决这个问题的。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/acl.png"></p>
<p>用于操作 ACL 的命令有两个 <code>getfacl/setfacl</code>，分别用来读取和设置 ACL 权限。其中 <code>getfacl</code> 可以比 ls -l 看到更详细的权限信息。而且你可能注意到权限位最后的 <code>+</code> 了，这里是加号的时候 <code>ls -l</code> 出来的权限位和我们平时看的就不一样了，想要看的清晰些最好就使用 <code>getfacl</code>。</p>
<blockquote>
<p>这里具体的展示方式各个发行版本可能会有所不同，有些在没有设置 acl 的时候后面什么都没有，有些则会留一个 <code>.</code> 在那里。而且 acl 在某些发行版上还需要额外安装，默认是不带的。所以需要具体发行版本具体分析。</p>
</blockquote>
<h1 id="0X04-suid-sgid-和-sbit"><a href="#0X04-suid-sgid-和-sbit" class="headerlink" title="0X04 suid sgid 和 sbit"></a>0X04 suid sgid 和 sbit</h1><p><code>suid</code> 和 <code>sgid</code> 之前先来看一下这一小段代码，这段 C 代码的唯一功能就是在 <code>/root</code> 下创建一个文件。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/create_file_c.png"></p>
<p>然后将这段代码编译成二进制程序，再给它赋予相应的用户和权限</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/create_file_result.png"></p>
<p>这里就看到了一个“奇怪的现象”：这个二进制程序会在 <code>/root</code> 创建一个文件，但是执行这个二进制程序的用户并没有向 <code>/root</code> 写入文件的权限（第三行可以看到有一个红色的 <code>[1]</code> ，是指的上一条命令的返回值），那是怎么成功的呢？就是因为上面的两行命令：<code>sudo chown root.root create_file_2_root</code> 和 <code>sudo chmod +s create_file_2_root</code>。</p>
<p>这两条命令分别是：将文件分配给 <code>root</code> 用户；为文件设置 <code>suid</code>。那么这个 <code>suid</code> 究竟是做什么用的呢？ <strong>设置了 <code>suid</code> 的程序，在执行过程中会临时变更为文件所属人的用户状态。</strong>也就是说上面的 <code>create_file_2_root</code> 命令在执行过程中是 root 用户的身份，既然是 root  用户那向 <code>/root</code> 写入个文件也就没什么大不了的了。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/suid_example.png"></p>
<p>所以 <code>suid</code> 的意思就是 <code>set uid ID upon execution</code>，那么 <code>sgid</code> 也就显而易见的是 <code>set group ID upon execution</code> 了。</p>
<p>唯一需要注意的就是，设置 <code>s</code> 权限的时候，需要已经拥有 <code>x</code> 权限。如果没有设置 <code>x</code> 就直接给了 <code>s</code> 权限，则在 <code>ls</code> 的时候会发现 <code>S</code> 会变成大写的标识，表示当前没有执行权限。</p>
<blockquote>
<p>其中 <code>suid</code> 只能使用在二进制可执行程序上；<br><code>sgid</code> 不只是二进制程序，也可以用在目录上；<br>设置了 <code>sgid</code> 后，用户在此目录下的有效用户组将变成该目录的用户组；<br>设置了 <code>sgid</code> 后，若用户在此目录下拥有 w 权限，则用户所创建的新文件的用户组与该目录的用户组相同（默认情况下自己创建的文件所属人和组都是自己，如果与目录相同就自然会有风险）</p>
</blockquote>
<p>还有一个跟 <code>suid/sgid</code> 不是很很相关，但是又比较相关（诡异的描述 hhhhh）的<code>sbit</code> 叫做 <code> the  restricted  deletion  flag  or  sticky  bit</code>，也就是用来标记限制删除的 bit。一旦文件被设置了 <code>sbit</code> 后就只有文件所属人和 root 才有办法删除了。好多发行版本的默认情况下 <code>/tmp</code> 这个目录就被设置了 <code>sbit</code>，因为你肯定不想你自己创建的临时文件被其他人删掉嘛。</p>
<p>当然，<code>suid/sgid/sbit</code> 都可以通过 <code>getfacl</code> 命令查看到。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/sbit_example.png"></p>
<blockquote>
<p>补充一句，这个只能为目录设置，为普通文件设置暂时没有任何意义和用处。</p>
</blockquote>
<h1 id="0X05-umask-默认权限"><a href="#0X05-umask-默认权限" class="headerlink" title="0X05 umask 默认权限"></a>0X05 umask 默认权限</h1><p>umask 是配置在用户上的，用于指定用户创建的文件/目录的默认权限的功能。也就是说每个用户可以有自己的 umask，用来指导自己创建的新文件、新目录所具有的权限。</p>
<p><code>新文件默认权限 = 类型最大权限 (666/777) - umask（按位减而非按数字减）</code></p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/umask.png"></p>
<blockquote>
<p>最大权限问题其实我们可以简单理解成：文件为 666，目录为 777，因为目录默认必须有 <code>x</code> 所以比文件多 <code>1</code>。</p>
</blockquote>
<p>具体算法可以按照如下来尝试计算，<strong>但是我总觉得自己哪里搞得不对，不过又怎么算都是对的，这里我对自己的正确性持保留意见，如果发现什么不对劲的地方可以随时联系我改正</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">umask 0022：</span><br><span class="line">    文件：</span><br><span class="line">        r w - r w - r w -   666</span><br><span class="line">        - - - - w - - w -   022</span><br><span class="line">———————————————————————————————</span><br><span class="line">        r w - r - - r - -   644</span><br><span class="line"></span><br><span class="line">    目录：</span><br><span class="line">        r w x r w x r w x   777</span><br><span class="line">        - - - - w - - w -   022</span><br><span class="line">———————————————————————————————</span><br><span class="line">        r w x r - x r - x   755</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="0X06-删除文件引发的权限问题"><a href="#0X06-删除文件引发的权限问题" class="headerlink" title="0X06 删除文件引发的权限问题"></a>0X06 删除文件引发的权限问题</h1><p>接下来就到了一个相对来说有趣的地方了，首先我们来带入一个场景，看看这个</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/delete_fail_1.png"></p>
<p>为什么这个文件我已经是所有人了，且权限已经是 777 了还是不能删除呢？这就涉及到了一个子问题“目录是什么”。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/what_is_dir.png"></p>
<p>都说 Linux 万物皆文件，其实目录也是一个文件，只不过相对特殊一点而已。这个文件里主要存储了 <code>inode</code> 和 <code>filename</code>，所以我们对一个目录里的文件进行改名和删除的时候需要和创建一样的 <code>w</code> 权限。只有拥有了对一个目录的 <code>rwx</code> 权限才可以进入到目录里并且删除一个文件。所以上面这张截图里不能删除文件的原因是<em>当前用户并没有当前目录的写入权限，所以不能删掉这个文件</em>。<br><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/delete_fail_2.png"></p>
<p>如果给用户添加一个对目录的写入权限，那就可以删掉这个文件了。<br><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/delete_fail_3.png"></p>
<p>接下来再看下一个例子，我们可以看到这个目录下有两个文件，我已经可以删除其中一个了，那为什么不能删除另一个权限完全一样的文件呢？</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/delete_fail_4.png"></p>
<p>答案在 <code>setattr</code> 这里。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/chattr_1.png"></p>
<p>Linux 中还有一个 <code>attr</code> 的东西，故名思义就是文件的属性了。我们可以给文件设置多个属性，例如下面的这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防磁盘I&#x2F;O错误的发生；</span><br><span class="line">S：硬盘I&#x2F;O同步选项，功能类似sync；</span><br><span class="line">a：即append，设定该参数后，只能向文件中添加数据，而不能删除；</span><br><span class="line">c：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作；</span><br><span class="line">d：即no dump，设定文件不能成为dump程序的备份目标；</span><br><span class="line">i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容；</span><br><span class="line">j：即journal，设定此参数使得当通过mount参数：data&#x3D;ordered 或者 data&#x3D;writeback 挂 载的文件系统，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data&#x3D;journal，则该参数自动失效；</span><br><span class="line">s：保密性地删除文件或目录，即硬盘空间被全部收回；</span><br><span class="line">u：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。</span><br></pre></td></tr></table></figure>

<p>其实还不止这些，但是我们通常会用到的也就这两个：<code>a</code> 和 <code>i</code>。其中被设置了 <code>a</code> 的文件只能被追加新内容，不能被删除或者复写已经存在的内容；而被设置了 <code>i</code> 的文件则不允许被删除，即使是天王老子来了也不允许被删除（除非你把它的 <code>i</code> 属性彻底）。所以说 <code>a</code> 属性通常会用在重要的日志上，从而保证日志不会被复写；<code>i</code> 属性通常会用在一些极其重要的文件上，防止被误删。而且由于这些属性的特殊性和强大的“拒绝改动性”（我乱取的名字），有一部分属性就只有 root 用户才能设置和删除，比如刚刚提到的 <code>a/i</code> 两个属性就是只有 root 才能操作，如果允许所有用户操作的话，一个用户在机器上创建了一个 10T 的文件又给了 <code>i</code> 属性，10T 的空间就被白白浪费掉了。 </p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/linux_perm/chattr_2.png"></p>
<h1 id="0X07-尾巴"><a href="#0X07-尾巴" class="headerlink" title="0X07 尾巴"></a>0X07 尾巴</h1><p>这些内容呢都算不上“复杂”或者“困难”或者“高深”，只是有很多人“不知道自己不知道”，所以我来分享一下我自己对这些内容的一些了解。主要目的也不是让读者一下就明白这些工具或者这些机制是怎么用的，是什么原理，而是<strong>让读者知道自己不知道什么</strong>。从而遇到问题的时候有个解决的思路，想要了解更深入的权限的时候记得还有一个什么<code>ACL/attr/suid/sgid/sbit</code> 的东西可以用，如果让一位读者达到这个目的我就算完成任务了～</p>
<h1 id="0X08-尾巴的尾巴"><a href="#0X08-尾巴的尾巴" class="headerlink" title="0X08 尾巴的尾巴"></a>0X08 尾巴的尾巴</h1><p>其实还有一个有关 “权限” 的机制叫做 <code>SELinux</code>，相信不少人尤其是用过 CentOS/RHEL 的会听说过这东西，不过多数人也仅限于知道有这么个东西，装好系统第一时间关掉它。其实它的功能很强大，但是我了解的也非常非常少，少到甚至不足以写一个小结专门介绍，所以就只有放在尾巴的尾巴里。至于为什么我几乎完全不懂还要写在这儿的唯一理由就是<strong>让读者知道自己不知道什么</strong>。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ACL </tag>
            
            <tag> Permission </tag>
            
            <tag> suid </tag>
            
            <tag> sgid </tag>
            
            <tag> sbit </tag>
            
            <tag> lsattr </tag>
            
            <tag> setattr </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 中函数的特性]]></title>
      <url>/2021/05/26/python-function-feature/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>在正式开始之前我们先要搞明白一个事情，那就是「函数」和「方法」到底有什么区别。首先来看一下在 <a href="https://docs.python.org/3/glossary.html">Python官方文档</a>里的定义。</p>
<p>函数：可以接受零个或几个参数并向调用者返回一些值的一系列语句。</p>
<blockquote>
<p><strong>function</strong>: A series of statements which returns some value to a caller. It can also be passed zero or more arguments which may be used in the execution of the body.</p>
</blockquote>
<p>方法：在类里定义的函数。</p>
<blockquote>
<p><strong>method</strong>: A function which is defined inside a class body. If called as an attribute of an instance of that class, the method will get the instance object as its first argument (which is usually called self).</p>
</blockquote>
<p>但是一般大家并不会很认真的区分「函数」与「方法」，而且就算不区分也并不会对平时的交流甚至编码造成任何影响（起码我没有因为不认真区分它们导致交流出现分歧或者代码出现 bug 的时候）。所以这里列出来也只是提个醒，防止有人并不是很清楚这两个名词表示的含义。其实我就是因为要写这篇博客才去搜了一下它们到底有什么区别，以前都是管 Python 里的叫「方法」，管 C 里的叫「函数」，不知道有没有人也是有这种不良习惯的🤣</p>
<p>既然搞清楚了，那么这篇文章后面就用「函数」来称呼好了，因为这些特性与是否定义在类里没有任何关系。（估计这是我第一次也是最后一次认认真真区分这两个东西了 hhhhh）</p>
<a id="more"></a>

<h1 id="0X01-万物皆对象"><a href="#0X01-万物皆对象" class="headerlink" title="0X01 万物皆对象"></a>0X01 万物皆对象</h1><p>都说 Python 中万物皆对象，那当然函数也是对象，我们可以用下面这段代码来验证一下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;id is &#x27;</span>, id(hello))</span><br><span class="line">print(<span class="string">&#x27;type is &#x27;</span>, type(hello))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isinstance(hello, object):</span><br><span class="line">    print(<span class="string">&#x27;石锤，就是对象&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果可以看到定义好的函数有自己的 id，<code>type()</code> 的输出结果也证明了它对象的身份，最后的 <code>isinstance()</code> 就更是石锤了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id is  140617210113904</span><br><span class="line">type is  &lt;class &#39;function&#39;&gt;</span><br><span class="line">石锤，就是对象</span><br></pre></td></tr></table></figure>

<h1 id="0X02-函数的本质"><a href="#0X02-函数的本质" class="headerlink" title="0X02 函数的本质"></a>0X02 函数的本质</h1><p>那么既然函数也是对象，那么一个函数和一个普通的对象有什么差别呢？或者说函数之所以是函数，它的本质是什么呢？这里首先看一个 Python 内建函数 <code>callable</code>，看名字就能猜到这个函数能用来检测传进去的参数是不是可以调用的。下面这小段代码可以看到 <code>callable</code> 的用法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo = <span class="number">3.1415926</span></span><br><span class="line">bar = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;foo callable: &#x27;</span>, callable(foo))</span><br><span class="line">print(<span class="string">&#x27;bar callable: &#x27;</span>, callable(bar))</span><br><span class="line">print(<span class="string">&#x27;hello callable: &#x27;</span>, callable(hello))</span><br></pre></td></tr></table></figure>

<p>运行结果可以看出来，只有 <code>hello</code> 也就是这里唯一的函数是可以被调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo callable:  False</span><br><span class="line">bar callable:  False</span><br><span class="line">hello callable:  True</span><br></pre></td></tr></table></figure>

<p>这么看来只要我们搞一个 callable 的对象出来，就可以向函数那样调用喽？是的，只要我们给自己定义的类实现一个 <code>__call__</code> 方法，那么这个类实例化出来的对象就是 callable 的。例如这样</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayHelloClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">say_hello_obj = SayHelloClass()</span><br><span class="line">print(<span class="string">&#x27;say_hello_obj is callable: &#x27;</span>, callable(say_hello_obj))</span><br><span class="line">say_hello_obj()</span><br></pre></td></tr></table></figure>

<p>我们从执行结果可以看到，这个类实例化出来的对象在 <code>callable</code> 这里返回了 True，且被我们通过与调用普通函数相同的方式成功的调用了。所以我们可以说函数和普通的对象本质区别就在于是不是 callable 的，而是不是 callable 的则取决于类有没有实现一个 <code>__call__</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">say_hello_obj is callable:  True</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>

<h1 id="0X03-可以被传递"><a href="#0X03-可以被传递" class="headerlink" title="0X03 可以被传递"></a>0X03 可以被传递</h1><p>既然函数都是对象了，那可以被当做参数或返回值传来传去也没什么特别的了。尤其是将函数作为参数传递，这在 Python 里有一个非常重要的概念是<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584">装饰器</a>，东西很多就不展开说了。</p>
<h1 id="0X04-args-和-kwargs"><a href="#0X04-args-和-kwargs" class="headerlink" title="0X04 *args 和 **kwargs"></a>0X04 *args 和 **kwargs</h1><p><code>def foo(xxx, yyy, zzz, *args, **kwargs)</code> 这种函数定义方法不一定经常用，但是肯定见过不少了。就拿这个函数举例好了</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">xxx, yyy, zzz, *args, **kwargs</span>):</span></span><br><span class="line">    print(xxx, yyy, zzz)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;------------------------------------&#x27;</span>)</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">print(<span class="string">&#x27;------------------------------------&#x27;</span>)</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">print(<span class="string">&#x27;------------------------------------&#x27;</span>)</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, a=<span class="number">7</span>, b=<span class="number">8</span>, c=<span class="number">9</span>)</span><br><span class="line">print(<span class="string">&#x27;------------------------------------&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里可以很容易看明白这两个参数的作用，但是有一个小问题你可能也许大概不知道，或者没尝试过</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">xxx, yyy, zzz, *args, aaa, bbb, ccc</span>):</span></span><br><span class="line">    print(xxx, yyy, zzz)</span><br><span class="line">    print(args)</span><br><span class="line">    print(aaa, bbb, ccc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, aaa=<span class="number">7</span>, bbb=<span class="number">8</span>, ccc=<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下，这种把 <code>*args</code> 夹在中间的做法偶尔也会用得上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">(4, 5, 6)</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>

<p>关于 <code>*args</code> 和 <code>**kwargs</code> 还有一个小知识点，多数人可能都知道。定义函数的时候 <code>args</code> 和 <code>kwargs</code> 两个名字只是大家习惯使用的，真正让语法生效的是前面的星号，原则上这两个单词随便用什么都可以，不过源于「代码是写给人看的」这个理念，还是建议任何时候都是用 <code>args</code> 和 <code>kwargs</code> 这两个普遍使用的单词拼写。</p>
<h1 id="0X05-🪆套娃"><a href="#0X05-🪆套娃" class="headerlink" title="0X05 🪆套娃"></a>0X05 🪆套娃</h1><p>套娃就很好理解了，也就是说可以在函数里定义函数，而且在函数里定义的函数还可以 return 到外面去。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_function</span>(<span class="params">func_name</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;hi world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_abaaba</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;a ba a ba a ba&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> func_name == <span class="string">&#x27;say_hi&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> say_hi</span><br><span class="line">    <span class="keyword">elif</span> func_name == <span class="string">&#x27;say_hello&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> say_hello</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> say_abaaba</span><br><span class="line"></span><br><span class="line">func_1 = get_function(<span class="string">&#x27;say_hi&#x27;</span>)</span><br><span class="line">func_1()</span><br><span class="line"></span><br><span class="line">func_2 = get_function(<span class="string">&#x27;say_hello&#x27;</span>)</span><br><span class="line">func_2()</span><br><span class="line"></span><br><span class="line">func_3 = get_function(<span class="string">&#x27;say_你好&#x27;</span>)</span><br><span class="line">func_3()</span><br></pre></td></tr></table></figure>

<p>这种用法要注意每次调用 <code>get_function</code> 的时候都会定义 <code>say_hi/say_hello/sai_abaaba</code> 这三个函数，如果外层函数频繁被调用或者内部函数耗时耗资源比较多的话要慎用这种方式，尽可能考虑将子函数挪出去。或者可以这么说：除非你非常确信需要将其做成子函数并且理解其会怎样工作，否则就不要使用子函数。</p>
<h1 id="0X06-λ-lambda"><a href="#0X06-λ-lambda" class="headerlink" title="0X06 λ lambda"></a>0X06 λ lambda</h1><p>说起 λ 这个符号，应该挺多人第一次见都是在 CS 里吧，当时我还以为这个字是入口的「入」，让我从那里进去呢😅</p>
<p>说正事，Python 中的 lambda 函数被称为「匿名函数」，当时刚接触的时候觉得这个名字取的真烂。后来才明白烂的不是名字，而是当时看到的那个示例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> a, b: a + b</span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这个示例完了之后就告诉我说「匿名函数讲解完了」，我当时人都傻了，心里还在想这不是有名字吗？这名字不就是<code>add</code>吗？然后又回去翻看书上的例子，才觉得这个名字取的确实没问题。（当然这个例子是我自己写的，书里可不会有这么暴力的例子🐸）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;shawn&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;jack&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;bluce&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;robert&#x27;</span>: <span class="number">19</span>, <span class="string">&#x27;frog&#x27;</span>: <span class="number">999</span>&#125;</span><br><span class="line"></span><br><span class="line">result = sorted(data, key=<span class="keyword">lambda</span> k: data.get(k))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> result:</span><br><span class="line">    print(<span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.format(k, data.get(k)))</span><br></pre></td></tr></table></figure>

<p>这个相对靠谱的例子中，就用 <code>lambda</code> 创建了个函数并且作为参数传了进去，然后实现了用字典中的值排序的功能。当然这种方法和用 <code>def</code> 定义一个标准函数再传进去没什么本质不同，但是优势就在于这种简单的函数定义方式可以直接写在参数里一行搞定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jack: 9</span><br><span class="line">shawn: 12</span><br><span class="line">robert: 19</span><br><span class="line">bluce: 22</span><br><span class="line">frog: 999</span><br></pre></td></tr></table></figure>

<p>这里再次重申一遍「代码是写给人看的」，所以不要强行上 <code>lambda</code> ，如果函数逻辑稍微复杂点，甚至参数多一点都不建议使用 <code>lambda</code> ，毕竟 <code>lambda a, b, c, d, e: (func_1(a, b, c)[3].value + d).update(e)</code> 远远不如下面这个片段简单易懂</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">a, b, c, d, e</span>):</span></span><br><span class="line">    _, _, _, result = func_1(a, b, c)</span><br><span class="line">    value = result.value +d</span><br><span class="line">    <span class="keyword">return</span> value.update(e)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Function </tag>
            
            <tag> Method </tag>
            
            <tag> Object </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的家用 NAS 方案]]></title>
      <url>/2021/04/19/nas/</url>
      <content type="html"><![CDATA[<h1 id="0X00-背景"><a href="#0X00-背景" class="headerlink" title="0X00 背景"></a>0X00 背景</h1><p>本来家里有一台群晖的 DS118 单盘位机器装了一块 4TB 红盘，用了三年后存储空间已经告急了。再加上买了相机，有很多照片需要存储；还有两台 MacBook 的 Time Machine 需要备份，而且还有不少下载的电影时不时想要回顾一下，空间就非常紧张了。虽然这台群晖的体验确实是挺好的，不过因为我这款性能太弱了，每次上传照片的时候创建索引都会卡死很久，期间几乎所有操作都是无效的，而且因为是单盘位既没有数据冗余也不能扩展空间，就想着是时候给家里的 NAS 升个级了。毕竟再过不了多久这块磁盘也就被塞满了，到时候再研究迁移就会导致中间断层一段时间，还是不太好。</p>
<p>一般来说自己家里的 NAS 有几种方案，这些方案各有其优劣，都有适合和不适合的群体，可以根据自己的实际情况进行选择。</p>
<blockquote>
<p>上下文提到的 FreeNAS 同时表示 FreeNAS 和 TrueNAS</p>
</blockquote>
<ol>
<li><a href="https://www.synology.com/">群晖</a>：简单易用、几乎不需要任何计算机专业知识、体积小功耗还低、<strong>软件套件强大、软套件强大、软件套件强大</strong>，但是比较贵。群晖就有点像是电脑届的苹果：你花了更多的钱不需要付出什么额外的东西就能获得 80 分的使用体验，但是如果你对它不满意想要改造一下以便获取 90 分乃至 100 分的体验，那是很难的。就比如你想给群晖升级硬件配置，几乎是不可能的（有些机型允许升级内存）。系统虽然提供了 ssh 连接，但是由于定制化过高也导致我们不敢进去改一些配置；</li>
<li>黑群晖：<strong>不推荐</strong>，没有别的理由，只是因为盗版；</li>
<li><a href="https://www.qnap.com/zh-cn/">威联通</a>等：比群晖便宜，易用性可能比群晖弱一点，不过也很适合不怎么具备专业知识的用户。如果想省心还想省钱，可以考虑用威联通之类的来替换群晖；</li>
<li>自建 <a href="https://www.truenas.com/">TrueNAS</a>：需要自己购买硬件攒机，需要自己安装操作系统进行配置，各种基础存储以外的功能都需要自己手动安装配置。所以不适合没有计算机专业知识储备的同学（当然你也可以先在虚拟机里尝试一下）。而且需要注意的是 FreeNAS 基于 FreeBSD，<strong>并不是Linux、并不是Linux、并不是Linux</strong>，所以即使有一些专业知识储备的同学也要注意到这一点。不过正式因为 FreeNAS 基于 FreeBSD 所以也就带来了完整且原生的 ZFS 支持。硬件方面毕竟是自己攒机装系统，性价比什么的当然就很高了；</li>
<li>自建 <a href="https://www.openmediavault.org/">openmediavault</a>：同样需要自己攒机装系统，所以性价比依旧很高。但是 OMV(openmediavault) 是基于 Debian 的，所以普适性更强一些。虽然系统性能上貌似不如 FreeNAS 不过用起来也还不错，因为我自己对 Linux 比较熟悉就也选择了这个方案；</li>
<li>自建纯 Linux：这个自由度是最高的，但是也是最折腾的。不仅要自己装机装系统，还得配置各种服务，其他方案上一键的 Samba 服务在自建 Linux 下都要配置一会儿。不过纯 Linux 的自由度是最高的，也能选用自己最熟悉的发行版本；</li>
<li>Windows server：不推荐，理由和黑群晖相同，除非你愿意出钱<a href="https://www.microsoft.com/zh-cn/windows-server/pricing">买 Windows server 授权</a>（$501）</li>
<li>路由器插硬盘：这种方式适合对数据安全性要求低且功能要求更低的用。因为几乎只支持上传下载，而且可定制的功能还特别少，不过好在成本最低。如果只是插上去用其他设备看个电影什么的，路由器插硬盘的方案还是可以试试的</li>
</ol>
<p>综合下来最后我选择了自建 openmediavault，因为群晖给我的很多功能我都用不上，比如说在线 Office 和 Video Station 等，反倒是性能太弱有点接受不了；TrueNAS 的话毕竟是 BSD 我没什么把握在出问题的时候可以修复它；纯 Linux 太折腾了，不想花那么多时间在上面。</p>
<a id="more"></a>

<h1 id="0X01-硬件方案"><a href="#0X01-硬件方案" class="headerlink" title="0X01 硬件方案"></a>0X01 硬件方案</h1><p>硬件我是先选的机箱，需要小一点还得能塞进去三块硬盘；CPU 选便宜点的就行，再弱也不至于是群晖那种；内存是从朋友那儿搞来的；电源选了个大牌子的普通电源，功率比较小的也没问题；主要是硬盘，选了三块 PMR 的 8T 企业级硬盘（非氦气）</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>型号</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>奔腾 G6400 2C4T</td>
<td>629</td>
</tr>
<tr>
<td>内存</td>
<td>铭瑄 DDR4 8G X 2</td>
<td></td>
</tr>
<tr>
<td>散热</td>
<td>ID-COOLING IS-30</td>
<td>89</td>
</tr>
<tr>
<td>主板</td>
<td>七彩虹 H410M-M.2 PRO V20</td>
<td>459</td>
</tr>
<tr>
<td>电源</td>
<td>振华 铜皇 450W 铜牌</td>
<td>259</td>
</tr>
<tr>
<td>机箱</td>
<td>先马趣造 i’m + 防尘罩</td>
<td>348</td>
</tr>
<tr>
<td>系统盘</td>
<td>铠侠 m.2 NVMe 256G</td>
<td>249</td>
</tr>
<tr>
<td>数据盘</td>
<td>西部数据 PMR 7200rpm HUS72 8T 256M   X 3</td>
<td>2700</td>
</tr>
</tbody></table>
<p>其中还有在买了之后京东保价了的，最后算下来花了差不多 4500 块钱。转过去看了一下群晖的 DS420（四盘位2020年的型号）空机器就已经这个价格了，性能还远不如我这个，所以性价比来说还是很高了。不过这里还是要提示一下，自己组装需要一定的计算机专业知识和技能，否则就算装机装好了后面的软件也够头痛的。</p>
<blockquote>
<p><strong>震惊！！！震惊！！！震惊！！！</strong>我 900 一块买的硬盘现在淘宝已经快 3000 了，一块顶我前两周的三块了，矿老板牛批！！！</p>
</blockquote>
<h1 id="0X02-软件方案"><a href="#0X02-软件方案" class="headerlink" title="0X02 软件方案"></a>0X02 软件方案</h1><p>软件上我选择了 openmediavault 方案，因为基于 Debian 还算比较熟悉。三块磁盘组了 RAID-5 阵列，虽然 RAID-5 没有那么靠谱，但是三块企业盘组 RAID-5 还是可以的。RAID-5 是磁盘越大越多越不靠谱，我这种三盘还行。然后远程访问是用的 Samba 协议，macOS 自己的 AFP 已经放弃且全面转到 Samba 了；电视手机和 iPad 都可以轻松访问，macOS 的 Time Machine 也可以直接用，很方便。</p>
<blockquote>
<p>RAID-5 最少需要三块盘（最好是容量相同的），拿其中一块的容量用来做奇偶校验，也就意味着 n 盘的 RAID-5 存储空间有 n-1 那么多。安全性的话是允许坏一块盘，如果坏两块的话，那数据就没了</p>
</blockquote>
<p>扩展的功能，比如系统监控我用的是<a href="https://learn.netdata.cloud/docs/agent/packaging/docker#host-editable-configuration">NetData</a>，下载用了 <a href="https://github.com/wahyd4/aria2-ariang-x-docker-compose">AriaNg</a> 和 <a href="https://hub.docker.com/r/linuxserver/transmission">Transmission</a>，照片库用的是<a href="https://docs.photoprism.org/getting-started/docker-compose/">PhotoPrism</a>，然后所有服务均使用 Docker 进行部署。其实各种服务可选的有很多，可以自己找适合自己的来部署。一般常见的就是需要部署一个文件管理器、一个下载工具、一个照片库和一个电影库，如果还有其他需要的话可以在 GitHub 或者其他平台找找看，比如也可以自己在家里搭一个 Gitlab/Gogs 或者虚拟化平台之类的方便开发测试。</p>
<p>其中电影库还没考虑好用什么方案，Plex不太方便、Radarr又不太好用、Kodi又需要给客户端全装一遍。</p>
<h1 id="0X03-数据迁移"><a href="#0X03-数据迁移" class="headerlink" title="0X03 数据迁移"></a>0X03 数据迁移</h1><p>数据迁移方案其实很简单，新 NAS 装好后开个 Samba 然后在老群晖里挂载一下，然后登录到群晖的管理界面上复制粘贴就行了。唯一需要注意的是，复制的时候硬盘疯狂读写有点吵，可以选择出门前复制，玩一天回来就搞定了。</p>
<p>或者不方便挂载后复制粘贴的话，使用 scp/rsync 之类的也没问题。</p>
<h1 id="0X04-综合体验"><a href="#0X04-综合体验" class="headerlink" title="0X04 综合体验"></a>0X04 综合体验</h1><p>现在用了一周多的时间了，大面上体验还算不错。现在内网访问时候的传输速度在 120～140mb/s 的水平，不管是备份恢复数据还是直接看存在里面的高清电影（4k 50～70G）都没有任何问题，一般只有在拖动进度条或者刚刚打开电影的一瞬间会卡一秒钟的样子，毕竟还是需要缓存一下。</p>
<p>先说说小问题：</p>
<ol>
<li>管理界面真的不好看，如果说群晖的 DSM 是 Windows 10 的话那 openmediavault 的管理洁面就像是 Windows 2000；</li>
<li>初次配置太麻烦了，毕竟很多服务都要自己搞，没有一些专业知识储备的话一整个周末都可能弄不好；</li>
<li>7200 转的企业盘跟 NAS 专用的红盘确实比不了，声音比较大，不过不读写的时候还是很安静的；</li>
<li>体积大，虽然先马趣造已经算是不错的小机箱了，但是跟 4 盘的群晖比还是大了很多；</li>
</ol>
<p>再来说说优点：</p>
<ol>
<li>性能充足，即使是我一次上传上万张照片，后台用 tensorflow 做分类，CPU 都没有爆满，跟不说那双通道 16G 内存了；</li>
<li>自由度高，64bit X84 4C4T 的CPU配合 16G 内存可以运行绝大多数常见服务，需要什么服务用 docker pull/start 一波就有了；</li>
<li>扩展性起飞，如果你不在乎机箱大小的话，完全可以配个 4 条内存 8 个盘位；</li>
<li>便宜、便宜、便宜</li>
</ol>
<h1 id="0X05-注意点"><a href="#0X05-注意点" class="headerlink" title="0X05 注意点"></a>0X05 注意点</h1><p>用了这段时间下来，总结了几个点需要注意的</p>
<ol>
<li>NAS 新手且没有什么计算机专业知识储备的，<strong>不建议自建、不建议自建、不建议自建</strong>。除非你只是玩玩，了解一下，否则万一不小心数据搞没了就是天大的麻烦。<strong>数据无价、数据无价、数据无价</strong></li>
<li>自建 NAS 是需要一定硬件和软件动手能力的，而且也会消耗比较长的时间，如果觉得有兴趣再考虑这种方案，否则建议用现成的群晖或者威联通这种</li>
<li>内网穿透可以考虑用 frp</li>
<li>自建 NAS 要善用 docker，也不是说多吹捧 docker，只是说在你服务崩了一个的时候不至于牵连到系统</li>
<li>NAS 即使有了 RAID 也还是建议将最重要的数据有额外备份，<strong>冗余不等于备份、冗余不等于备份、冗余不等于备份</strong></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> NAS </tag>
            
            <tag> Storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[地址解析协议 ARP]]></title>
      <url>/2021/01/16/arp/</url>
      <content type="html"><![CDATA[<h1 id="0X00-什么是-ARP"><a href="#0X00-什么是-ARP" class="headerlink" title="0X00 什么是 ARP"></a>0X00 什么是 ARP</h1><p>首先纠正一种说法，<code>ARP</code>就是“地址解析协议”，所以严格来说不应该说“ARP 协议”，因为<code>ARP Address Resolution Protocol</code>就已经包含了<code>Procotol</code>了，说“ARP 协议”就相当于是“地址解析协议协议”，很鬼畜。</p>
<p>我们知道网络中寻找其他机器需要用到对方的 ip 地址，但是在局域网内两台机器之间通信是不用 ip 地址直接通信的，而是要用到 mac 地址。而且我们一般说的交换机也是二层交换机，现在假设两台电脑插到一个交换机上去，通过 ip 能找到对方吗？显然不能。因为交换机只支持到链路层，然而对于链路层来说它并不知道 ip 是个什么，ip 需要到再上一层的“网络层”才能发挥作用，所以在这种情况下就需要用到 mac 地址来通信了。</p>
<p>当一个数据包需要被发送到某一 ip 地址的机器上去时，最后一步就需要找到 ip 地址对应机器（严格来说是网口）的 mac 地址，从而进行通信。那么在这一步里“通过 ip 地址找到 mac 地址”的解析协议就被称之为：地址解析协议，也就是<code>ARP: Address Resolution Protocol</code>了。</p>
<h1 id="0X01-ARP-的工作"><a href="#0X01-ARP-的工作" class="headerlink" title="0X01 ARP 的工作"></a>0X01 ARP 的工作</h1><p>我们知道 arp 是将 ip 和 mac 地址进行转换映射的，那肯定不是每次都要去转换的，要留个缓存的嘛。我们可以使用 <code>arp -a</code> 来检查当前机器上的 arp 高速缓存表，命令在 Linux 和 macOS 上可用，Windows 上不确定各位可以试试看。我这里是防止隐私问题把一部分数据给人工打码了，正常输出的就是缓存表里每个 ip 对应的 mac 地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? (192.xxx.xxx.1) at 4:xx:xx:xx:xx:0 on en0 ifscope [ethernet]</span><br><span class="line">? (192.xxx.xxx.103) at (incomplete) on en0 ifscope [ethernet]</span><br><span class="line">? (224.xxx.xxx.251) at 1:xx:xx:xx:xx:fb on en0 ifscope permanent [ethernet]</span><br><span class="line">? (239.xxx.xxx.250) at 1:xx:xx:xxx:xxx:fa on en0 ifscope permanent [ethernet]</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/arp_network.png" alt="网络拓扑"></p>
<p>ARP 的工作流程也是很简单的，当机器 A 想给 <code>10.0.0.4</code> 发一条数据的时候的时候：</p>
<ol>
<li>检查自己的高速缓存表，发现没找到（有点类似与 DNS 先找 <code>/etc/hosts</code> 的操作）</li>
<li>机器 A 发出广播“你们谁是 <code>10.0.0.4</code>， 告诉我你的 mac 地址”</li>
<li>因为是广播，所以 BCD 都会收到此条数据</li>
<li>CD 因为不是 <code>10.0.0.4</code> 所以忽略</li>
<li>B 发现是在找自己，回消息“我是 <code>10.0.0.4</code>，我的 mac 地址是 <code>1:0:2:7f:af:fa</code>”</li>
<li>A 收到了回馈，并将 <code>10.0.0.4 -&gt; 1:0:2:7f:af:fa</code> 记入自己的缓存表</li>
</ol>
<p>所以 ARP 概括成一句话就是“广播一条消息：如果你是这个 ip 地址的拥有者，那么请回答你的 mac 地址”。</p>
<a id="more"></a>

<h1 id="0X02-ARP-的数据包"><a href="#0X02-ARP-的数据包" class="headerlink" title="0X02 ARP 的数据包"></a>0X02 ARP 的数据包</h1><p>一个 arp 数据包有 42 个字节，分成两部分：数据部分和链路层封装的首部。</p>
<p>首部：以太网目的地址、以太网源地址、帧类型；</p>
<p>数据：硬件类型、协议类型、硬件地址长度、协议地址长度、op、发送端以太网地址、发送端 IP 地址、目的以太网地址、目的 IP 地址（其中以太网地址就是指的 mac 地址）。</p>
<p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/arp_data.png" alt="arp 数据包"></p>
<p>在整个数据包中我们最需要关注的是下面这 6 个字段以太网目的地址、以太网源地址、发送端以太网地址、发送端 IP 地址、目的以太网地址、目的 IP 地址。哎是不是发现有些数据有重复，比如发送者的 mac 地址就重复了？回忆一下 OSI 模型，因为工作在链路层的程序接受到的数据已经被链路层拆解了，也就是说 arp 程序拿到的数据是没有首部的，所以想要判断这个数据到底是从哪儿来的就需要在数据里存一份才行。</p>
<p>现在我们来简单看一下这几个字段:</p>
<ol>
<li>以太网源地址、以太网目的地址：这个是首部要用的，要知道从哪儿发到哪儿。这里需要注意的是，广播的时候，目的地址是 <code>ff:ff:ff:ff:ff:ff</code> ，这个地址在 mac 地址中表示广播；</li>
<li>发送端以太网地址、发送端 IP 地址：这个是数据里的部分，作为 arp 发出去后，别人响应的时候就是从这里取的地址返回给你</li>
<li>目的端以太网地址、目的端 IP 地址：同样是数据中的部分，作为 arp 响应的时候，这里的“目的端”指的就是发送 arp 广播请求的那个机器</li>
</ol>
<p>我们来看一个实例好了，我自己笔记本配置的网关是<code>192.168.0.1</code>，那我们来看一下这个找网关 mac 地址的流程。上面这张图是我发送出去的广播，下面这张图是网关给我的回复。（各位有兴趣的话可以下载一个 Wireshark 来抓包看看，挺有意思的）</p>
<p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/arp_request.png" alt="arp 请求"></p>
<p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/arp_response.png" alt="arp 响应"></p>
<p>这里可以看到这么几个值得注意的点：</p>
<ol>
<li>发送 arp 请求的时候，首部的接收者是 <code>ff:ff:ff:ff:ff:ff</code>，即广播地址；</li>
<li>发送 arp 请求的时候，虽然不知道目的 mac 地址，数据里仍然携带了，只不过标记为了 <code>00:00:00:00:00:00</code>；</li>
<li>响应时并非单纯的将请求数据包中的 <code>00:00:00:00:00:00</code> 替换成自己的 mac 地址，而是将自己的数据仍旧放在“发送者”的位置上。</li>
</ol>
<p>不过仔细观察一下这个协议会发现一个问题：它好像非常不安全。</p>
<h1 id="0X03-ARP-欺骗"><a href="#0X03-ARP-欺骗" class="headerlink" title="0X03 ARP 欺骗"></a>0X03 ARP 欺骗</h1><p>正常来说有人在吼“谁是 xxx 这个 ip 地址的拥有者，告诉我你的 mac 地址”，应该只有一个人回复或者干脆没人理。但是如果这时候网络里出现了一个小老弟，他很不老实，明明自己不是这个 ip 的拥有者却一直再回复“我是，我的 mac 地址是 xx:xx:xx:xx”，那会发生什么？如果广播要找的是一台普通的机器，那么在这个小老弟的干扰下可能他就会网络不稳定，或者干脆断网；如果这个小老弟打算假冒自己是网关（也就是别人在广播找网关的时候，他站出来疯狂回复），则可能导致整个局域网挂掉。</p>
<p>网断了还是小问题，如果这个小老弟冒充自己是网关，并且在自己本地做了个转发，将流量再转到真实网关上去会怎么样？局域网内其他机器并不会断网，但是却因为都以为这个小老弟是网关所以一切流量都会发送到这个小老弟这儿来，再由他转发到真网关。这时候这个小老弟就监听到了整个局域网内所有的数据包。如果这时候你的流量是不加密的，比如登录了一个 http 的站点，那小老弟就可以用上面提到的 wireshark 等工具抓到你的 htt 流量并轻而易举的看到你的登录密码，就算你没登录也能轻而易举得看到你的 cookie 从而模仿你登陆。即使你加密了，用上了 https 协议，也不能完全不泄露隐私。比如你登陆了某 PxxHub 正找视频呢，被人监听到流量抓包了，虽然他不能登录上你的号，但是他可以看到你所有的 http 请求的 url 哇，这样一来你看的所有视频这个小老弟都会知道。下次见到你直接跟你聊起你前一天晚上看的视频，岂不是很恐怖😱</p>
<p>上面提到的：假装自己是网关的操作，就叫做“ARP 欺骗”；后面把自己假装成网关后再做转发，从中监听并篡改流量的行为就叫做“中间人攻击”。 那就没有什么解决方案了吗？当然有</p>
<h1 id="0X04-防护-ARP-欺骗"><a href="#0X04-防护-ARP-欺骗" class="headerlink" title="0X04 防护 ARP 欺骗"></a>0X04 防护 ARP 欺骗</h1><p>防护的话有两种常见的方案：从网关上防护和从主机上防护。从网关上防护的一个方案叫做 <code>DAI: Dynamic ARP Inspection</code> 动态 ARP 检测，从主机上防护主要就是“不要连来路不明的 Wi-Fi，且自己的 Wi-Fi 密码要足够复杂”，给个人设备装防火墙。</p>
<p>其中 DAI 的大致工作是这样的：如果你有一台具有 DAI 功能的路由器（不太可能，因为这玩意目前只在一些高级的企业级路由器上才会有）那么这台路由器可以做到 ARP 欺骗的拦截。首先我们知道连接到网关的机器，网关当然知道他的 mac 地址对吧，再加上 DAI 这个功能可以搞到他的 IP 地址，这样一来如果他发出的 arp 响应不对就会被网关发现直接 drop 掉，甚至还可以对这个地址进行“惩罚“。</p>
<p>针对自己主机的防护我们能做的主要就是装 ARP 防火墙，防火墙可以绑定正确的 ip 和 mac地址，可以识别网络中的 arp 扫描行为。</p>
<p>所以简单来说：把路由器换成带 DAI 的企业级路由器、不要乱连 Wi-Fi、把自己 Wi-Fi 密码设置地复杂点、装个安全软件（这个安全软件，说起来真头痛，反正注意鉴别，别到时候攻击没来自己先引狼入室了🤣）。</p>
]]></content>
      
        
        <tags>
            
            <tag> Network </tag>
            
            <tag> ARP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 Linux 中创建网桥 Bridge]]></title>
      <url>/2021/01/09/linux-bridge/</url>
      <content type="html"><![CDATA[<h1 id="0X00-什么是网桥"><a href="#0X00-什么是网桥" class="headerlink" title="0X00 什么是网桥"></a>0X00 什么是网桥</h1><p>普通的桥就是连接本来不通的路的基础设施，网桥就是用来本来不通的网的设备。但是这里介绍的不是真正意义上的物理设备，而是在 Linux 上创建的虚拟设备。Linux 上不仅可以创建虚拟网卡，也可以创建虚拟网桥，所以说我们在 Linux 环境下学习网络知识确实是一个不错的选择（除非你有钱买一堆物理设备🤣）。</p>
<blockquote>
<p>桥接器（英语：network bridge），又称网桥，一种网络设备，负责网络桥接（network bridging）。桥接器将网络的多个网段在数据链路层（OSI模型第2层）连接起来（即桥接）。    – <a href="https://zh.wikipedia.org/zh-cn/%E6%A9%8B%E6%8E%A5%E5%99%A8">Wikipedia</a></p>
</blockquote>
<h1 id="0X01-网桥有什么用"><a href="#0X01-网桥有什么用" class="headerlink" title="0X01 网桥有什么用"></a>0X01 网桥有什么用</h1><p>网桥的本质就是将互不连通的网卡接到一起，原则上只有这么简单的功能，具体在这个功能之上能做什么事就看我们自己了。</p>
<p>如果用过 Docker 的话可以看一下自己本地的网络拓扑，实际上 Docker 的容器间通信和外网访问也是用到了 bridge 的。</p>
<p>最直观的一种操作就是：用一台双网卡机器串在两台主机之间，用来监听甚至修改数据包。乍一看这好像是搞坏事要用的技术手段呐，的确。如果有人拿一个双网卡的小机器（比如树莓派）串在了你的光猫和路由器之间，那么连接到路由器的所有外网请求都会经过这台小机器。如果你的流量不加密，比如用http协议或者ftp协议这种，那别人是可以看到中间的所有内容的，包括登录的密码之类的。所以这也是“不要随便连接来路不明的 Wi-Fi” 一大理由。</p>
<p>当然也不只是做坏事，现在的好多 WAF（Web Application Firewall）都是可以支持 “透明模式部署” 的，也就是说把这种安全软件所在的机器串在你的网关和 web 服务器之间，就可以在不破坏网络拓扑的情况下做到安全防护。</p>
<p>如果你想用这种方式来做软路由、绕开学校的网络共享限制，或是做流量分析都是可以实现的。</p>
<a id="more"></a>

<h1 id="0X02-实验环境"><a href="#0X02-实验环境" class="headerlink" title="0X02 实验环境"></a>0X02 实验环境</h1><p>如果要跟着做一下的话，需要简单配置一下环境：</p>
<p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/linux_bridge.png"></p>
<p>首先我们需要三台虚拟机，有些人用Virtualbox、VMware Workstation、有些人又在用VMware Fusion甚至有直接用 KVM 的，每个的操作都不太一样，我们最终都是需要有一套这样的环境。</p>
<p>三台虚拟机，server_1 有一张网卡，配置静态 ipv4 地址为 <code>192.168.1.1/24</code>，server_2 有两张网卡，分别与 server_1 和 server_3 相连，server_3 有一张网卡，配置静态 ipv4 地址为 <code>192.168.1.2/24</code>。当然如果虚拟机软件不能让两台机器直连的话可以通过在机器间加路由器或者交换机的方式将其连接起来。</p>
<p>此时 server_1 和 server_3 的 ip 虽然在同一网段，但是应该是不通的。</p>
<blockquote>
<p>如果这时候你的网络已经通了，那证明虚拟机和虚拟路由器配置有误。有一点是需要确认的：如果你用到了虚拟路由器的话，路由器要禁用 DHCP 或是给两台路由器配置不同的网段例如 <code>1.1.1.0/24</code> 和 <code>1.1.2.0/24</code></p>
</blockquote>
<h1 id="0X03-如何配置网桥"><a href="#0X03-如何配置网桥" class="headerlink" title="0X03 如何配置网桥"></a>0X03 如何配置网桥</h1><p>好的我们开始配置网桥，其实过程很简单，总共分四步：创建网桥，将 server_2 的 ens33 网卡连接到网桥上，将 server_2 的 ens34 网卡连接到网桥上，将网桥启用。</p>
<p>首先在 server_1 上执行 <code>ping 192.168.1.2</code>，此时网络是不通的，不要停，一直叫他 ping 就好，一会儿通了可以瞬间看到效果。</p>
<p>在 server_2 上执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ip link add name br0 <span class="built_in">type</span> bridge     <span class="comment"># 创建一个名为 br0 的网桥</span></span><br><span class="line"></span><br><span class="line">ip link <span class="built_in">set</span> dev ens33 master br0     <span class="comment"># 将 ens33 接到 br0 上</span></span><br><span class="line">ip link <span class="built_in">set</span> dev ens34 master br0     <span class="comment"># 将 ens34 接到 br0 上</span></span><br><span class="line"></span><br><span class="line">ip link <span class="built_in">set</span> dev br0 up               <span class="comment"># 启用 br0 这时网络应该通了</span></span><br><span class="line"></span><br><span class="line">ip link <span class="built_in">set</span> dev ens33 nomaster       <span class="comment"># 将 ens33 与 br0 断开连接</span></span><br><span class="line">ip link <span class="built_in">set</span> dev ens34 nomaster       <span class="comment"># 将 ens34 与 br0 断开连接</span></span><br><span class="line"></span><br><span class="line">ip link <span class="built_in">set</span> dev br0 down             <span class="comment"># down 掉 br0</span></span><br><span class="line"></span><br><span class="line">ip link del br0                      <span class="comment"># 删除网桥</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
            <tag> bridge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2020 年终总结]]></title>
      <url>/2020/12/31/2020-bye/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>一年前的这个时候还在想，2020 年这个年号听起来很科幻，然而 “科幻” 这个词还是还是太瞧不起 2020 了，这一年简直是“魔幻”。</p>
<p>最近这几年来，过得最不舒服的应该要数今年的前两个月了，疫情刚刚爆发，武汉封城，人也不出门，就在家里当咸鱼。本来就焦虑的人们每天看到的新闻也只能让大家更加焦虑，每天看到的都是 “口罩、防护服没有了”，“武汉封城”，“急寻密切接触者”….</p>
<p>不过好在也有火神山雷神山这种好消息，也有后面武汉解封的振奋，还在今年的最后一天还看到了“国产疫苗批准上市，免费接种”这种令人愉悦的消息。如果要真是像🇺🇸️那么搞，真不知道还有没有命在这儿写 2020 年度总结了😵</p>
<h1 id="0X01-2020-年度计划"><a href="#0X01-2020-年度计划" class="headerlink" title="0X01 2020 年度计划"></a>0X01 2020 年度计划</h1><p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/time.png" alt="时间管理.png"></p>
<ul>
<li>❗️ 写 30 篇博客完成率：63%</li>
<li>❕️ 欣赏 50 部电影完成率：82%</li>
<li>✅️ 坚持 5 个小习惯完成率：100%</li>
<li>✅️ 阅读 20 本书完成率：100%</li>
<li>✅️ 了解 4 个新领域完成率：100%</li>
<li>✅️ 提升 5 个专业技能点完成率：100%</li>
<li>✅️ 减重 15 斤到 150 斤 完成率：100%</li>
<li>✅️ 换一份新工作完成率：100%</li>
</ul>
<p>其实总结下来看的话，这个年度计划表我还算是完成度比较高的了。疫情期间所有计划都是完全停止的，一点进展没有，甚至“减重 15 斤以达到 150 斤”这事儿难度还加大了，毕竟成天在家里坐着，想吃什么还自己做来吃，不胖才怪😅。虽然后面想起来疫情其实并没有直接影响到我计划表里的任何一项，但是当时整个人都是晕糊糊的，所以那两个月也就这么晕糊糊得过去了。</p>
<a id="more"></a>

<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>这部分是达成率比较差的，主要是两部分原因：首先是今年自己的提升确实不多，太难整理了；还有一个是因为好多自己学到的东西学习资料都已经写的太好了，感觉自己再复述一遍不仅浪费时间还没有意义。所以下一个年计划里，博客这部分已经被我重构了。明年换个思路来写博客，不知道会不会比今年好一些。</p>
<p>其实坚持写博客这件事还是挺有意义的，不论是“学习最好的方法就是教别人”，还是“好记性不如烂笔头”，总之确实坚持着写了不少。在写的过程中还是有不少收获的，找工作的时候别人也会把持续维护的原创博客作为一个比较大的加分点。当时面试的问题都有些是直接从我博客里抽出来问的，看看是不是真的在认真写，是不是真的学到了东西；</p>
<h2 id="欣赏电影"><a href="#欣赏电影" class="headerlink" title="欣赏电影"></a>欣赏电影</h2><p>其实好多人跟我说 “就看一电影，还至于列到年度计划里？”，其实我觉得还是可以列进来的。就比如我自己在这条计划里有一个备注是 “不少于 30 部豆瓣 top250”，因为有好多优秀的电影认真看是能提升自己观影品味的，能提升自己的艺术趣味，就算只是当成看一部普通电影也是很不错的。</p>
<p>但是观看这种电影本身“不一定”是一个很有趣的事，因为有些电影本身太老了，或者当时很新颖的拍摄手法和观点如今已经很常见了。就算有些老电影隔了这么多年还能让人沉浸其中，但是决定把两个小时的时间放在一部 1957 年的电影上还是需要一定决心的（比如 十二怒汉）。</p>
<p>本来观影这部分是很容易达成的，毕竟有那么多优秀电影可以看，每年也有那么多院线电影可以选择，但是因为疫情原因，导致今年几乎没去电影院看院线电影，所以也就没能最终达成计划。</p>
<h2 id="坚持小习惯"><a href="#坚持小习惯" class="headerlink" title="坚持小习惯"></a>坚持小习惯</h2><p>其实真的只是小习惯，有些是能让自己变得更好的比如 “少喝可乐” 这种，还有些是改掉自己平时的一些坏习惯，比如 XXXXX（这我肯定不能说啊）。其实这种每年养成几个小习惯还是比较容易的，然而日积月累下来，每年四个坚持五年就是十几二十个优秀的习惯，就算坚持的时间再短，养成的习惯再少，也总归是一种让自己变得更好的方法嘛。</p>
<h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>其实这一项应该不算 100% 完成度。因为有几本书虽然在计划表里，但是真正看起来之后发现超无聊，讲得都是些废话或者完全不能认同的，就随便翻翻过去了。明年再选书的时候还是要多看看书评，而且看到觉得不想再看下去的书就即使止损。</p>
<p>不过关于看书倒是有两个点可以记录下来（如果有人看到这篇文章的话才算 “分享出来” ，我就姑且叫 “记录” 吧 🤣）：</p>
<ol>
<li>“读自己专业领域的书，不叫读书；读与自己专业无关的书，才叫读书”。这句话是从 Tengusan 那儿听来的，好像是马未都说的。受这句话启发，我就把明年的读书列表里所有跟专业相关的书都踢出去了，要读的是一些“奇怪”领域的书：天文、医学、医药、物理、建筑…</li>
<li>看书不一定要看和自己观点一致的，但是一定要看 “不胡说” 的。比如你认为 “外星生命一定存在”，但是作者认为 “外星人不存在”，那这本书可以继续看下去，完全没问题，求同存异嘛。因为这样不仅可以让我们认识到其他人的观点、理解别人的想法也有可能让我们发现自己观念的局限性，从而改正自己的观念或者扩展自己的思维，最起码还能开阔自己的眼界。然而如果作者表达的观点都是 “我没见过外星人，所以没有外星生物；我周围所有人的工资都超过 2000 块钱，所以世界上没有人会饿死了” 的这种明显的逻辑问题，或者纯粹的抬杠扯淡，那就没必要继续看下去了。</li>
</ol>
<h2 id="了解新领域"><a href="#了解新领域" class="headerlink" title="了解新领域"></a>了解新领域</h2><p>这个是我年度计划里最有趣的部分了。就算哪天我不再看电影、不再写博客、甚至不再玩游戏了，也还会保留这一项。今年列表里是 “做饭、摄影、游戏设计和视频剪辑”，虽然都只是了解了星星点点，不过也还是很有趣。</p>
<p>尤其是游戏设计，真正的 “游戏玩家” 可以来了解一下，不是了解编程去实现一个游戏，而是了解设计一个游戏的玩法、关卡、机制等，真的很有趣。比如 “玩家在枪林弹雨中奔跑时会偷偷降低所受的伤害，以此让玩家觉得自己精于闪避”， “敌人掉落物品时会扫描玩家背包，给出玩家需要的东西，以此让玩家觉得自己运气爆棚” 等等。</p>
<p>当然了，一年了解四个新领域，也只是、只能是了解到皮毛中的皮毛了，不过这并不重要，了解了皮毛以后再有兴趣深入也有个方向嘛～</p>
<h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><p>这个就不额外多说了，毕竟自己还只是一个初级开发者，还是得学习一个。以后我想买的从 PlayStation 到 Tesla 都要靠专业技能来赚钱买呢，不继续提升专业知识的话都不说 Tesla ，甚至爱玛电动车都买不起呦。</p>
<h2 id="减肥"><a href="#减肥" class="headerlink" title="减肥"></a>减肥</h2><p>减重 15 斤这事儿，身边有朋友说我还挺厉害的，我倒是觉得还挺正常的。就很简单呐，少吃点，多动动，自己就瘦下来了。我以前每次吃面🍜️都是点三两（大份）的，现在都是吃二两（中份）的了；以前每次吃中餐都是两三碗米饭🍚️，现在改一碗了；然后偶尔拿出自己的 Switch 玩玩健身环呐、舞力全开呀，真的是自己就瘦下来了，没那么难的。</p>
<h2 id="换工作"><a href="#换工作" class="headerlink" title="换工作"></a>换工作</h2><p>最后一个规划就是 “换一份工作”，这个也顺利达成了。毕竟作为一直之前只有过一次面试、一次工作经验的人，换工作还是个挺大的事儿呢，所以还专门<a href="https://blog.just666.com/2020/09/27/leave-knownsec/">记录了这第一次换工作的经历</a>。</p>
<h1 id="0X02-值得记录的时刻"><a href="#0X02-值得记录的时刻" class="headerlink" title="0X02 值得记录的时刻"></a>0X02 值得记录的时刻</h1><ol>
<li>准备了几道年夜饭的菜（虽然就一家三口 hhh）</li>
<li>玩到了塞尔达-旷野之息（有塞尔达玩的时光真的太幸福了）</li>
<li>第一次自己的开源项目有真正的用户</li>
<li>找到一份心仪的工作</li>
<li>一次惊险刺激的徒步之旅</li>
<li>新工作被通知提前转正</li>
</ol>
<p>今年发生的事情很多，但是回忆起来真正发生在自己身上的事情又很少，所以也没有几个真正值得记录的时刻。照着自己过去一年的滴答清单了好半天，也没凑够整整 10 个值得纪念的时刻。</p>
<h2 id="做菜"><a href="#做菜" class="headerlink" title="做菜"></a>做菜</h2><p>首先今年的年夜饭是第一次在自己家里吃，以前都是回老家跟一大家人，这次自己家里我还准备了几个菜，效果不错。而且其他有人来做客的时候我下厨炒的几个菜评价也都还挺好的，不管是家里人还是我自己满意度都还算可以；</p>
<h2 id="塞尔达"><a href="#塞尔达" class="headerlink" title="塞尔达"></a>塞尔达</h2><p>有塞尔达玩的时间，真的是最幸福的时间之一，尤其是游玩的前 100 个小时，是真的太幸福了。不只是游戏设计的优秀，还有任天堂对孩子一样的好奇心的奖励，让玩家真心觉得自己是幸福的，是被重视的。如果让我说我玩过最优秀的游戏，那自然是塞尔达无疑了。但是塞尔达也不是适合所有人，如果到现在你还没玩，又想试试的话还是建议买实体版，万一不喜欢还能出掉回血，喜欢的话就直接把实体收藏了；</p>
<h2 id="第一个用户"><a href="#第一个用户" class="headerlink" title="第一个用户"></a>第一个用户</h2><p><a href="https://github.com/shawn-bluce/server_tag">自己的一个小开源项目</a>有用户这事儿还是挺骄傲的，虽然没几个 star ✨️但是居然有人愿意用，我就已经很开心了。之前一直只是嘴上说着支持开源，实际的做法也就只是使用一些开源软件而已，这次也算是真正开源精神的一次实践吧。明年要继续完善一些 feature，还有几个 bug 要改一改，欢迎各位用 iTerm2 的朋友来试试看呐，顺便再点个 star 酒更好了🤣</p>
<h2 id="新工作"><a href="#新工作" class="headerlink" title="新工作"></a>新工作</h2><p>新工作呢，现在这份工作综合来说还是挺满意的，不仅涨了工资还能学到新的东西，认识更厉害的人，后面估计会继续在新公司待挺长一段时间了；</p>
<h2 id="惊险刺激"><a href="#惊险刺激" class="headerlink" title="惊险刺激"></a>惊险刺激</h2><p>经验刺激的徒步之旅是之前朋友推荐去的，结果在山上又大雾又高反又迷路，还上演了一波 “古墓丽影” 式的救援。而且在大雾的山坡上迷路的时候，突然发现一辆以前冲出马路的报废车，还是是真的刺激。大家在筹划这些有危险的出行之前，还是要做足功课，要不然真的出现这种特殊情况，还是挺危险的。不过这次经验还是很棒，而且很刺激，估计能记在脑子里很久很久了 hh；</p>
<p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/pic.jpeg" alt="一张惊险刺激的照片"></p>
<h2 id="提前转正"><a href="#提前转正" class="headerlink" title="提前转正"></a>提前转正</h2><p>最后一个就是前两天的新员工的工作总结了，总结完当场被通知表现的不错，提前转正了。虽然 2020 的开头实在不怎么样，但是这也算是为这个 2020 年画上了个比较漂亮的句号吧～</p>
<h1 id="0X03-总结-amp-2021"><a href="#0X03-总结-amp-2021" class="headerlink" title="0X03 总结 &amp; 2021"></a>0X03 总结 &amp; 2021</h1><p>2020 年已经到此结束了（我就不信仅剩这么一点点时间还能出什么幺蛾子），如果单纯从我自己的角度来说的话，我倒还是过得不错的。新工作不仅涨了工资，也能学到更多的东西；经历的一些事情虽然没有好的结果，但也让自己有所成长；看过的书虽然忘了不少，但也还是能无形间给自己提供力量。</p>
<p>之前听 Tengusan 分享过一句 Ansel Easton Adams 的话：“我们不只是用相机拍照。我们带到摄影中去的，是所有我们读过的书，看过的电影，听过的音乐，爱过的人”。我想不只是拍照，生活也是，我们每个人的生命不只是我们自己，还有所有我们读过的书，看过的电影，听过的音乐，爱过的人。</p>
<p>最后，介于 2020 年这么操蛋，那我觉得 2021 年再怎么样也要比 2020 年更好的，大家加油 ～  </p>
]]></content>
      
        
        <tags>
            
            <tag> log </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[防范 CSRF]]></title>
      <url>/2020/11/18/csrf/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/csrf.png"></p>
<p>假设有这么一个银行（肯定要假设，如果真有这么蠢的话这银行也早就倒闭了）的网上银行站点，他提供了一套的 API，通过<code>GET https://api.xxbank.com/transfer?amount=3000&amp;to=shawn</code>可以向 shawn 转账 3000 块。虽然用 GET 来修改数据是挺蠢的但是好像也没什么大问题是吧。</p>
<p>好的，现在你正在这个银行的网站上沉迷于数自己余额的零，这时候我给你发来了一个链接。你开开心心的看完了发给你的页面，然后关掉了它，回过头来发现自己账户少了 3000 块钱！！！怎么回事呢？</p>
<p>其实是我发给你的链接有“毒”，页面里所有的图都是<code>&lt;img src=&quot;https://xxx.xxx.xxx/xxx.jpg&quot;/&gt;</code>，但是有一张图裂了你没发现，裂了的那张图是<code>&lt;img src=&quot;https://api.xxbank.com/transfer?amount=3000&amp;to=shawn&quot; /&gt;</code>。这里有两个问题需要注意，第一个就是这个 url 并不是图片，所以图片必然会裂掉；第二个就严重了：因为是 <code>img</code> 标签，所以浏览器会去 GET 回来，这一 GET 没拿到图不要紧，却发起了我预谋的转账请求，你的钱就没得喽。</p>
<p>当然如果你多刷新几次，每次刷新就是 3000 块钱，嘿嘿嘿</p>
<a id="more"></a>

<h1 id="0X01-什么是-CSRF"><a href="#0X01-什么是-CSRF" class="headerlink" title="0X01 什么是 CSRF"></a>0X01 什么是 CSRF</h1><p>故事讲完了，那么到底什么是<code>CSRF</code>呢？</p>
<blockquote>
<p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。  「<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">维基百科</a>」</p>
</blockquote>
<p>说起 CSRF，不知道大家有没有听过一种“POST 请求比 GET 请求更安全”的说法，也许这种说法的来源就与 CSRF 相关，具体的我们后面会说到。</p>
<h1 id="0X02-如何防范-CSRF"><a href="#0X02-如何防范-CSRF" class="headerlink" title="0X02 如何防范 CSRF"></a>0X02 如何防范 CSRF</h1><h2 id="使用-Referer-字段"><a href="#使用-Referer-字段" class="headerlink" title="使用 Referer 字段"></a>使用 Referer 字段</h2><p>HTTP 协议中有一个 Referer 字段，是用来标记“发起这个请求的来源地址”，这样我们在后端做一个校验<code>if http_request.head.referer == &#39;https://www.xxbank.com/&#39;</code>就可以了。这种做法的成本极低，只需要在后端新增一个校验，但是存在一个问题：不是非常靠谱。</p>
<p>为什么不是很靠谱呢？首先，这个字段并不是必填的，我们不能保证用户的牛鬼蛇神浏览器会传这个字段；其次，即使牛鬼蛇神传了这个值，也不能保证他是正确的。所以从这个角度上来说，虽然实现成本很低但是效果也并不太好。</p>
<h2 id="使用-token-回传"><a href="#使用-token-回传" class="headerlink" title="使用 token 回传"></a>使用 token 回传</h2><p>首先我们要知道不要用 GET 去修改数据，不要用 GET 去修改数据，不要用 GET 去修改数据，然后再讨论接下来的问题。还是用转账这个 API，我们假设现在 API 是<code>POST https://api.xxbank.com/transfer/</code>，数据是<code>&#123;&quot;amount&quot;: 3000, &quot;to&quot;: &quot;shawn&quot;&#125;</code>。你可能会说“不对呀，还是可以在其他页面里用 Ajax 发送 POST 请求呀”，先别急，慢慢看。</p>
<p>我们要修改“转账”这个功能，本来只接受<code>amount/to</code>这两个参数的 API 现在接受第三个参数：<code>csrf_token</code>。那么这个<code>csrf_token</code>的值应该是什么呢？这个值又服务器生成，每次客户访问转账页面的时候带着返回个客户，然后客户表面上看起来这里有两个框框，填写金额和收款人，但实际上还隐藏了第三个框框，直面的值是自动填写的 <code>csrf_token</code>。现在用户点击“转账”后，发送的正确请求数据应该是<code>&#123;&quot;amount&quot;: 3000, &quot;to&quot;: &quot;shawn&quot;, &quot;csrf_token&quot;: &quot;2336666&quot;&#125;</code>了。</p>
<p>现在如果还有个小黑客用 Ajax 的方法发送请求，就不行了，因为这时候他只能填写<code>amount/to</code>这两个参数，第三个<code>csrf_token</code>是不知道的，所以防御成功。</p>
<h2 id="双重-cookie"><a href="#双重-cookie" class="headerlink" title="双重 cookie"></a>双重 cookie</h2><p>双重 cookie 并不是说有两个 cookie，而是说一个 cookie 要用到两次。当用户登录银行系统后，系统会发给他一个 cookie，这个完全没有问题对吧。但是采用了双重 cookie 验证的站点会在 cookie 里加入一个<code>csrf_tcookie=xxx</code>（当然你随便叫什么都可以）的值，接下来你在银行站点内发送的每一个请求都要取出这个<code>csrf_cookie</code>，拼在后面。</p>
<p>在不启用这个防护策略的时候，<code>POST https://api.xxbank.com/transfer/</code>就可以将钱转走，现在启用了这个策略，就必须得<code>POST https://api.xxbank.com/transfer/?csrf_cookie=xxxxx</code>才可以。然而由于这个值是放在 cookie 里的，所以只有该站点的请求才可以取到，其他站点的是不能取到 cookie 的。如此一来，csrf 的攻击也就失效了。（当然，这个的安全性是没有回传 csrftoken 这么强的）</p>
<h1 id="0X03-参考"><a href="#0X03-参考" class="headerlink" title="0X03 参考"></a>0X03 参考</h1><p><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">美团技术团队前端安全系列（二）：如何防止CSRF攻击？</a><br><a href="https://zh.wikipedia.org/zh/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">维基百科：CSRF</a></p>
]]></content>
      
        
        <tags>
            
            <tag> csrf </tag>
            
            <tag> security </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL 查询执行内幕-基础篇]]></title>
      <url>/2020/11/16/mysql-query-exec-basis/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>这篇博文概述了一次查询从一条 SQL 到拿到数据的过程，是掌握了基础的 CRUD 后想要进阶 MySQL 的一条必经路（当然我是说这个只知识是必经路，并不是我这篇文章）。如果有兴趣的话就继续看下去吧~</p>
<p>我们首先看一下下面这张图，其实并不复杂。我们很多人都已经知道了其中的一部分，比如缓存、存储引擎、数据这些。</p>
<p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/mysql_query_exec_basis.jpeg"></p>
<blockquote>
<p>图源自：高性能 MySQL</p>
</blockquote>
<p>我们先来看一下粗略的流程</p>
<ol>
<li>首先客户端发送一条查询给服务器；</li>
<li>服务器检查缓存，如果命中缓存则直接返回；否则继续执行；</li>
<li>服务器解析 SQL、预处理、由优化器生成执行计划；</li>
<li>MySQL 根据执行计划，调用存储引擎 API 执行查询；</li>
<li>将结果返回给客户端；</li>
</ol>
<p>虽然每一条都比上面描述的、比我们想象的要复杂得多。但是因为这里只是基础篇，所以我们只是了解一下基础流程和原理就好，如果需要深入了解某部分的细节的话，可以查阅更详细更深层的资料。</p>
<a id="more"></a>

<h1 id="0X01-客户端-lt-gt-服务器"><a href="#0X01-客户端-lt-gt-服务器" class="headerlink" title="0X01 客户端 &lt;-&gt; 服务器"></a>0X01 客户端 &lt;-&gt; 服务器</h1><p>首先我们需要知道的一点是：<strong>客户端和服务器之间的通信是半双工的</strong>。这一点其实就能解释我们工作中遇到的一个问题：当我们主动发起一个查询请求后，并不能再次主动 cancel，只能等待查询结束。</p>
<blockquote>
<p>大家学过计算机网络都应该知道，半双工就意味着要么发送数据、要么接收数据，并不能两件事一起做</p>
</blockquote>
<p>还有需要注意的一点，我们“理所当然”地以为客户端发起连接，推送 SQL 到服务器，等待处理再将结果<strong>拉</strong>回客户端。但是这样其实并不对，实际上是 MySQL 服务器在向客户端<strong>推</strong>数据，再加上半双工的限制导致客户端在接收数据的时候只能等待数据全部推送完毕。</p>
<p>我们初步了解的时候并不需要学习整个客户端和服务器交互协议的详细内容，所以了解到这里就差不多了，我们知道“半双工”和“推拉”基本就能解决一些初级问题了。</p>
<p>然后一个与此相关的是“查询状态”。我们都知道<code>show full processlist</code>可以看到当前系统中运行的查询的状态，但是有些状态是不能望文生义的，还是需要了解一下具体到底是什么含义</p>
<p><code>Sleep</code>：等待客户端发来请求；<code>Query</code>：正在查询或者<strong>正在将结果发送给客户端</strong>；<code>Locked</code>：被锁住了，正在等待表锁（存储引擎级别的锁并不会显示出来，例如 InnoDB 中的行锁）；<code>Analyzing and statistics</code>：正在收集存储引擎的统计信息，生成查询的执行计划；<code>Copying to temp table[on disk]</code>：正在查询，并将届国际复制到临时表中（通常是在 group by，或者 Union 或者文件排序），标记了 on disk就标识当前在磁盘上操作；<code>sorting result</code>：正在对结果排序；<code>sending data</code>：可能是多个状态间传递数据、或者在生成结果集或者在向客户端返回数据。</p>
<p>其他的都还好，重点就在与<code>Query</code>和<code>sending data</code>，之前很多人以为<code>Query</code>就是正在查询，<code>sending data</code>就是发送数据回到客户端，这其实是不对的。</p>
<h1 id="0X02-查询缓存"><a href="#0X02-查询缓存" class="headerlink" title="0X02 查询缓存"></a>0X02 查询缓存</h1><p>MySQL 自带就有一个查询缓存，但是比通常我们自己写的缓存要严格得多，MySQL 自己使用哈希做的缓存。也就是说，当缓存开启的情况下，每次来了一条 SQL 都会去计算这个 SQL 的哈希，然后拿哈希去对比，如果命中缓存就校验权限，权限没问题就直接返回数据了。</p>
<p>这里需要注意的一点是，MySQL 会有一个机制来控制缓存的刷新，这也是我上面提到“严格”的第一处表现：只要这个表被更新过，缓存就集体失效。因为如果数据存在延迟的话，一致性就不能得到保障，单机都保障不了一致性的话也就没法用了。</p>
<p>这里还需要注意的一点，也就是“严格”的第二处表现：因为是用 hash 做的缓存，所以只要你的 SQL 跟上次不完全一致，即使只差了一个字节，都会导致 hash 不同，最终不触发缓存。</p>
<h1 id="0X03-查询优化"><a href="#0X03-查询优化" class="headerlink" title="0X03 查询优化"></a>0X03 查询优化</h1><p>首先查询优化阶段会将 SQL 语句进行解析，得到一棵“解析树”，然后在配合预处理器的配合下最终将合法的解析树交给<em>查询优化器</em>。查询优化器会将其转化成“执行计划”，然后将执行计划交给下一步的“查询执行引擎”。</p>
<p>毕竟这一步是叫做“查询优化”的，是因为在这个过程中可以对查询进行一些优化，比如下面几种：</p>
<ol>
<li>当手动写了一个比较烂的 JOIN 时，可能内部真实的关联顺序并没有按照你的 SQL 执行，而是自己寻找了一个更好的关联顺序（MySQL 都看不下去了 hhhhh）；</li>
<li>等价变换：比如有人写了<code>3=3 AND age&gt;18</code>，就会直接在这个过程中把<code>3=3</code>给优化掉；还有这种<code>(a&lt;b AND b=c) AND a=5</code>就会被优化成<code>b&gt;5 AND b=c AND a=5</code>；</li>
<li>比如你在 InnoDB 表上给自增 id 建了索引，然后取<code>MAX(id)</code>，那优化器就会直接取到最大值（因为本来就是排好序的，没必要一个个去找）；</li>
</ol>
<p>等等这些。当然这部分是整个查询里最复杂的部分，我自己了解的也不够多，所以只能说清楚这么多，再多的话我也是似懂非懂更不敢乱说了。不过这部分确实是比较重要的内容，大家有兴趣的话可以自行搜索更有深度的资料，或者直接去看《高性能 MySQL》就好了。</p>
<h1 id="0X04-查询执行引擎"><a href="#0X04-查询执行引擎" class="headerlink" title="0X04 查询执行引擎"></a>0X04 查询执行引擎</h1><p>查询执行引擎拿到的是上一步传递过来的“执行计划”，这里的执行计划是一个数据结构。MySQL 只需要根据里面给出的指令逐步执行，执行的过程中会有很多操作需要调用存储引擎来实现（那可不嘛，要不数据从哪儿来）。具体调用会跟存储引擎相关，不同的存储引擎提供的 API 也不一样，这里就是 MySQL 主程序去调用存储引擎的 API 把最终的结果集查询出来。</p>
<h1 id="0X05-返回结果给客户端"><a href="#0X05-返回结果给客户端" class="headerlink" title="0X05 返回结果给客户端"></a>0X05 返回结果给客户端</h1><p>查询的最后一步当然就是将查到的结果返回给客户端，如果开启了缓存的话顺便再写一下缓存。</p>
<p>MySQL 返回数据是一个增量、逐步的过程。也就是说当生成第一条结果集数据的时候就开始返回了，这样可以保证服务端不用存储过多的数据，也可以让客户端更早得到结果。</p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Ab 和 Http_load 进行简单的性能测试]]></title>
      <url>/2020/11/04/ab-http-load/</url>
      <content type="html"><![CDATA[<h1 id="0X00-概述"><a href="#0X00-概述" class="headerlink" title="0X00 概述"></a>0X00 概述</h1><p>我们经常想要简单测试一下某个页面的性能，或者 REST API 的性能，用 postman 这种程序虽然可以很快的模拟请求出来但是并不方便发送大量请求；自己写脚本虽然自定义程度很高，但是写起来总归还是有点麻烦，而且并不能很方便得输出我们需要的一些常用数据。那这种时候一般就需要找些专业的工具来做这种专业的事情了。下面两个就是平时比较常用的性能测试工具，可以针对某个/某些 url 做性能测试，并且输出相对完整的报告。</p>
<p>软件具体怎么装就自己想想办法吧，毕竟 Linux/macOS/windows 之间都不太一样，而且 Linux 上还有 apt/dnf/pacman 巴拉巴拉一堆包管理器，用法都不一样，没必要一个个找出来贴上。需要了解 API 性能的人肯定能很轻松装上这些工具了~</p>
<a id="more"></a>

<h1 id="0X01-apache-bench"><a href="#0X01-apache-bench" class="headerlink" title="0X01 apache bench"></a>0X01 apache bench</h1><p>最简单的使用方式：<code>ab -n 20 -c 2 https://example.org/</code>回车，就会执行一次简单的测试并输出报告。这串命令会用<code>GET</code>请求访问<code>https://example.com/</code>，并发为 2，总共发起 20 次请求。<strong>需要注意，测试的时候域名最后已经加上<code>/</code>，因为测试是针对 url 的，而非 domain</strong></p>
<p>接着我们会得到一个这样的输出结果。其中第一部分是服务器的相关信息；第二部分是本次测试的相关信息；第三部分是连接相关的信息；第四部分是请求耗时的相关信息，我们只是简单看一下请求的响应速度，所以重点看第三和第四部分。<br><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/ab_result.png"></p>
<p>第三部分内容是连接耗时的数据，分别统计了连接、处理、等待的最小、平均、中位、最大值。</p>
<p>作为简单的测试结果，第四部分是最值得关注的，工具统计出了所有请求的耗时时间分布。我的这条结果显示 50% 的请求在 592ms 内完成；90% 的请求在 839ms 内完成，100% 的请求在 1069ms 内完成（也就是说最慢的一次请求用了 1069ms）。</p>
<p>简单的<code>GET</code>请求就到此为止了。如果需要携带 Header（这太常见了，起码登录过后得带个 token 才能真正测试），那就携带新的参数<code>-H </code>即可，类似于这个样子<code>ab -n 10 -c 2 -H &#39;token: xxxxxxx&#39; https://example.org/</code>。如果需要携带多个 Header 参数，那就多接几个<code>-H</code>也没问题。</p>
<p>如果要发送 <code>POST</code> 请求，需要先把请求内容写在一个文件里，例如在<code>/homes/shawn/post_data</code>，然后通过<code>-p /home/shawn/post_data</code>就可以把文件内容通过 <code>POST</code> 请求发送出去了，比如这样<code> ab -n 2 -c 1 -p /home/shawn/post_data http://127.0.0.1:2333/</code></p>
<h1 id="0X02-http-load"><a href="#0X02-http-load" class="headerlink" title="0X02 http_load"></a>0X02 http_load</h1><p><code>http_load</code>可以测试多个 url，不用像 <code>ab</code> 那样只能同时测单一 url；但是问题是不能使用<code>GET</code>以外的其他方法，所以用途也比较单一，用法也比较简单。</p>
<p>常用 4 个参数： </p>
<ol>
<li>-p –parallel  并发进程数</li>
<li>-f –fetches  总访问数</li>
<li>-r –rate  每秒访问数</li>
<li>-s –seconds 访问总时间</li>
</ol>
<p>首先要准备一个纯文本文件，类似这样<code>/home/shawn/urlist</code>的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;about&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;blog.just666.com&#x2F;</span><br></pre></td></tr></table></figure>
<p>保证每行一个 url，接下来就是<code>http_load -p 3 -f 10 /home/shawn/urllist</code>以 3 的并发量发起 10 次请求，或者<code>http_load -r 5 -s 10 xxx</code> 以每秒 5 次的频率请求 10 秒</p>
<p>会得到类似这样的输出结果</p>
<p><img src="https://blog-1251664340.cos.ap-chengdu.myqcloud.com/http_load.png"></p>
<p>总共发起了 19 次请求；并发为 1；大小是697449 btes；总共用了 10.0025 秒；平均每个连接是36707.8 bytes；平均每次请求 1.89 秒；平均响应是 20ms、最大 125、最小 8.2；</p>
<p>最后是各个状态码的数量，这里 19 个都是 200，一切正常；如果 50x，尤其是 502/503 这种就有可能是你频繁请求导致服务器不稳定了。</p>
<p>中间缺了一行<code>msecs/first-response</code>的解释？实话说我也不知道。manual 里没有这个解释，google 没找到官方的解释，二手资料全是复制自同一个人的，结果最初的那个老哥可能也没搞明白就没写。。。</p>
]]></content>
      
        
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Performence </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSO 和 LDAP]]></title>
      <url>/2020/11/02/sso-ldap/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>上周在新公司接到的一个任务”给 XXX 系统集成 LDAP 登录”。我以前是没有了解过 LDAP 的，一听是集成登录功能，脑子里第一时间想到的就是之前做过的 SSO，但是经过一番搜索发现 LDAP 和 SSO 完全是两回事，而且发现还是不少人不了解其中的一项或两项技术，正好在这儿整理一下顺便分享给大家~</p>
<p>内容都是比较基础的，主要介绍了什么是 SSO、SSO 的基本原理、什么是 LDAP、LDAP 的基本原理和 LDAP 如何与 SSO 关联。如果你对这些有兴趣那不妨继续看下去，如果你都了解了那就去看看其他文章或者休息一会儿好了~</p>
<p>现在开始做一些技术背景预设：假设你公司有 10 个站点，分别是<code>site_0.just666.com/site_1.just666.com.....</code>，同时每个站点都有用户系统，也就是说用户可以登录到站点上去做些操作。</p>
<p>用户肯定不愿意访问每个站点的时候都要登录，比如你登陆淘宝之后再看天猫肯定不想再登陆一次了，如果天猫要你再登陆一次且密码还跟淘宝那边不通你肯定要骂人了。现在怎么办呢？SSO 和 LDAP 两种技术就是用来解决这个问题的。</p>
<a id="more"></a>

<h1 id="0X01-SSO"><a href="#0X01-SSO" class="headerlink" title="0X01 SSO"></a>0X01 SSO</h1><p>SSO全称是 Single Sign On，中文叫”单点登录”，听名字也猜得出来，就是从单一节点上登录。SSO 需要在传统的”客户/服务”之外再加了一个 SSO 服务，专门用来校验用户登录和管理 token。</p>
<ol>
<li>客户点开站点</li>
<li>站点发现这次请求没有携带有效 token，将客户跳转到 SSO 的登录页面（并告诉 SSO 本次跳转的来源）</li>
<li>客户在登录页面输入用户名密码，点击登录（此时在和 SSO 服务进行交互）</li>
<li>SSO 服务器对登录信息进行校验，通过后发放一个 token 并跳转回源页面（因为第 2 步告诉 SSO 跳转的来源了）</li>
<li>客户带着 token 再次访问目标页面，服务器拿到 token</li>
<li>服务器带着 token 去 SSO 那儿校验，SSO服务 反馈：”这个 token 合法，用户是 shawn”</li>
<li>服务器通过校验，当前用户以 shawn 的身份登入到站点中了</li>
</ol>
<p>这样一来，原本 10 个站点需要配备 10 个用户登录模块的，现在只需要独立出来的一个登录模块了；后面再有新的站点，接入到 SSO 也是非常方便的；不仅如此，SSO 也可以做到让你登录一个站点后带着 token 直接访问同域的其他站点。</p>
<p>所以简单点来说的话，”SSO 是一种用来验证登录的服务”。</p>
<h1 id="0X02-LDAP"><a href="#0X02-LDAP" class="headerlink" title="0X02 LDAP"></a>0X02 LDAP</h1><p>上面 SSO 介绍完了看起来好像验证就完美了，完全不需要什么 LDAP 这种东西，但是实际上不是的。</p>
<p>LDAP 是一个树形结构的查询性能优秀的目录数据库，可以方便的管理公司员工和部门的结构，并且 LDAP 也并非基于 HTTP 协议，硬说的话 LDAP 其实可以是一个”DB”。只不过因为是”目录结构”的数据库，所以非常适合存储树形组织的各项数据。</p>
<p>所以这么说来 LDAP 从技术上并非无可替代，我们完全可以用 MySQL 这种关系型数据库来做个对应的表结构来存储相同的数据，再自己写一套简单的程序要进行查询。<strong>但是</strong>我们使用 LDAP 最大的原因之一应该就是 wiki 上说的那样：”开放的，中立的，工业标准的应用协议”，因为他足够开放、中立且应用非常广泛，我们随便一个程序都可以很快的接入进来。</p>
<p>我这里就不过多介绍 LDAP 了，这东西三两句是真的说不清楚，这里也主要是让大家知道”我还有什么不知道”，这样后面学习也有个点可以看。（主要是我自己也没有摸的很明白，现在真是说把基本原理搞明白了然后正确的把程序接入进去了，万一我说错了什么误人子弟就不好了）。</p>
<h1 id="0X03-联动"><a href="#0X03-联动" class="headerlink" title="0X03 联动"></a>0X03 联动</h1><p>如果说把上面两个部分看完了，那么联动这里就很容易了。SSO 和 LDAP 两个东西一前一后，LDAP 可以作为 SSO 服务的后端数据库，就算是将这两个连动起来了。不过通常来说企业里也不太会联动着用，一般来说一个 LDAP 就够了，多个站点都要登录但是用的相同的用户名密码，也没有多麻烦。</p>
<h1 id="0X04-参考资料"><a href="#0X04-参考资料" class="headerlink" title="0X04 参考资料"></a>0X04 参考资料</h1><p><a href="https://www.cnblogs.com/wilburxu/p/9174353.html">LDAP 概念和原理介绍 – WilburXu</a></p>
<p><a href="https://segmentfault.com/a/1190000014683418">我花了一个五一终于搞懂了OpenLDAP</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%96%AE%E4%B8%80%E7%99%BB%E5%85%A5">单点登录 Wikipedia</a></p>
]]></content>
      
        
        <tags>
            
            <tag> SSO </tag>
            
            <tag> Auth </tag>
            
            <tag> LDAP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的第一次跳槽之路]]></title>
      <url>/2020/09/27/leave-knownsec/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>都说“生活需要仪式感“，那对我来说的第一次跳槽还是值得记录的，用处肯定是没什么，但是总归是给自己一点点生活上的仪式感吧。而且脑子记住的东西可能过几年就忘记了，真正记录成文字的东西存活时间就会长久很多。（记录在网络上就算我自己把博客删了，都还会有垃圾站原封不动的抄走，简直不可能丢🤣）</p>
<p>本来说离职当天就来写这篇文章的，结果当天晚上同时请客去吃饭又去唱了歌，回家都凌晨两点了，隧作罢。现在离职手续全部都办好了，新公司的文件们也都准备好了，就等假期过后直接到新公司入职。所以也终于有时间坐下来不用考虑工作相关的任何事情来写一写自己的想法了～</p>
<p><strong>这不是日记，按蓝青峰跟朱潜龙的说法正经人谁写日记啊🤪</strong>（狗头）</p>
<h1 id="0X01-为什么离开"><a href="#0X01-为什么离开" class="headerlink" title="0X01 为什么离开"></a>0X01 为什么离开</h1><p>从我以实习生的身份加入创宇到最后离开一共是 1159 天，算下来是三年多一点点，时间也算是很久的了。毕竟我大学也就只有前三年是在学校的，后面就出来实习了。现在走呢也不是说因为公司有啥问题或者我被开除了，只是说我自己觉得是时候出去看看了，不想常年在一家公司里待下去</p>
<p>这次跳槽主要是这三个问题导致的：</p>
<ol>
<li><p>💰️首先是“工资问题“；大家出来工作，99.99%的人都得是为了赚钱吧。我因为是实习转正的，所以薪资起点会比较低，即使后来的调薪比例都还挺高的也会导致最后的薪资并没有怎么多；所以说自己也想要换个地方拿到更高的薪资，要恰饭的嘛；</p>
</li>
<li><p>👨‍💻其次是“专业技能“；开发者嘛，想要自我提升的人还是很多的。但是因为我做的事情是针对少数人使用的内部系统，所以对个人的技术力需求和考验并没有什么。在工作中不太能接触到更高的东西和更宽的东西，自己私下时间学习到的更高更宽的知识又比较难应用起来。虽然在舒适圈是真的舒适，但是想要提升的话总有一天要打破舒适圈的，我觉得这一天该到了；</p>
</li>
<li><p>👀️最后是“眼界和见识“；我个人觉得我已经在同一个岗位做同一个业务时间够久了，也想要见到其他不同的行业和人们。</p>
</li>
</ol>
<p>所以总结下来，就是说目前我：使用“Python“编写“Django“程序，然后运行在内网环境里，给“内部审核系统“提供稳定可靠的“web 服务“，每个月赚到“**“的工资。现在双引号里所有的东西我觉得都是时候可以改变的，对于技术栈来说的“T 型人才“的横和竖都是可以发展的了；对于工资来说就更是了，起薪低的情况下很难有大额上涨的，所以跳槽也是一个大家都理解的操作。</p>
<a id="more"></a>

<h1 id="0X02-准备一份简历"><a href="#0X02-准备一份简历" class="headerlink" title="0X02 准备一份简历"></a>0X02 准备一份简历</h1><p>换工作第一步当然是“写简历“了。我在这儿就不总结说怎么准备简历了，毕竟就一次换工作的经历，也没什么资格。不过在准备简历的过程中我觉得有些事情是值得被记录下来的。</p>
<p>首先是我花费在简历的时间，从 0 到 1 准备简历的时间加上后来改动简历的时间怎么也有 10 个小时了。这点本来我没太觉得有什么，直到后来跟朋友聊到这个才发现好多人并不会用这么长时间在简历上的。我自己是觉得简历这件事太重要了，花费 10 小时完全是值得的；</p>
<p>其次是“善用搜索能力“，多搜一下相关的简历，在 Google 上直接搜索“程序员 简历 filetype:pdf“就可以找到海量的 PDF 格式简历。这些简历都是我们的素材来源，可以多参考。（因为是搜来的，不能保证质量，所以需要自己有辨别能力）✅️❎️</p>
<p>接下来是“P2P“，也就是点对点。如果不嫌麻烦的话应该做到一份简历对应一份工作，当然这样的成本是巨大的。所以一般来说应该是一份简历对应一种工作，比如说我会 Python 和 前端 并且都可以作为主力，那我想要找这两个工作的时候应该准备一份 Python 的简历，再准备一份 前端 的简历，万万不可写在一起。因为 Python 的面试官并不是很在乎你的前端能力，反之也是一样。不过也不是说一点都不写，还是要提一些，因为这样可以证明自己的工作能力、学习能力，如果用人方真的需要这种技能那就是个大大大大大的加分项了。</p>
<p>最后的是“朋友的帮助“。我前前后后找了五六七八个朋友帮我看简历，然后从设计、人事、技术、等不同角度给我提了四五十个修改点。是的没错，我就 A4 纸 1 页能有四五十个修改点。然后我会把这些所有的修改点逐一排列起来然后认真考虑吸取哪些内容，然后再一点点改自己的简历。改好之后再拿出去给大家看看，反复迭代两三次的样子。所以上面提到的十多个小时算下来也没有很过分了是吧，毕竟改了这么多个点。</p>
<h1 id="0X03-面试经历"><a href="#0X03-面试经历" class="headerlink" title="0X03 面试经历"></a>0X03 面试经历</h1><p>因为我简历是非常用心的，所以简历投出去之后的“邀请面试率“是很高的。后来面试的时候我针对技术面做了个小心思可以给大家分享一下，个人觉得这个经验还是值 5 毛钱的。</p>
<p><strong>价值 5 毛钱的经验</strong>：我准备好简历后先投递了第一波简历，不一定是自己非常非常愿意去的公司，但是也不能说“我就试试又不去“（这样就太流氓了）。然后面试的时候也是要全力以赴，面试结束回家之后拿出一只笔在简历上把面试官问的所有问题全都勾画出来，尤其是当时没有回答出来或者自己觉得回答的不好的。然后等第一波面试结束后，如果有合适的那当然就去了，但是如果没有合适的，那就对着上面这四五六次面遇到的问题“各个击破“。因为技术面的时候面试官肯定是会对着你的简历找问题的，那你现在把几乎所有的问题都找出来了，只需要解决他们就可以了。等把所有问题都解决了，就再次投递简历～ 第二波面试的时候很多问题会直接命中，然后你就很容易成了呀</p>
<p>然后面试的时候我是很诚实的，遇到自己不懂不会的问题会说“这个我不太清楚，不过如果是我的话可能会这样设计/如果是我觉得 xxx 应该可以实现“。即使是自己不懂的原理，也可以在说明之后尝试猜测一下，这时候面试官会比较理解我的解题思路，即使不正确也是会有加分的。（当然不是乱说了，如果一点点都不懂的话就直接明说就好了）最最最重要的是，不要撒谎。往小了说，撒谎被发现可能就直接终止面试了；往大了说，就算成功入职也不会通过试用期，而且还会被同事嘲讽很久很久（是的，我们公司就来过这种，我们嘲笑了很久很久）</p>
<p>最后要注意的是“引导面试官“；面试官问了问题，你回答的时候对自己不了解的东西“一嘴带过“，然后尽可能往自己熟悉的领域聊（当然，不是说要跑题）。这样一来就会让面试官觉得你很强，不过这个算不上很重要的点了。</p>
<h1 id="0X04-心仪的工作"><a href="#0X04-心仪的工作" class="headerlink" title="0X04 心仪的工作"></a>0X04 心仪的工作</h1><p>接下来想说说我自己这次找到的比较心仪的工作。前面提到的“薪资、知识技能、眼界见识“这三个问题，能全部解决掉是最好的。所以我后面找工作的时候就是按着这三个点来突破的，如果这三个需求都能满足到的话就再好不过了。所以现在找到的新公司是很满意的，就坐等到时候入职看看具体情况了～</p>
<p>找工作的时候很重要的一点是面试过程中 HR 或者技术面的面试官问的“你有什么问题问我吗“。这种时候是可以放心大胆问的，如果自己很在乎加班那就问问、如果自己很在乎个人提升那就多问问技术栈和技术深度。如果特别反感加班，那公司 996 的话就直接告辞，这样也算节省了自己和公司的时间是吧。</p>
<p>找工作我自己会有一个铁律：喜欢的不怕多问，多打探公司的情况，让自己放心的去；觉得不合适的公司，及时止损，不浪费自己和公司的时间。</p>
<h1 id="0X05-总结"><a href="#0X05-总结" class="headerlink" title="0X05 总结"></a>0X05 总结</h1><p>这些内容写出来主要是给我自己看的，当然如果尤其他同学看到了这篇文章并且其中的某一句话对你有那么一丢丢的帮助，那我就很开心了。</p>
<p>最后祝我自己在新公司能得心应手，如果有读者的话也祝你工作顺利，生活愉快🤓～</p>
]]></content>
      
        
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL中的四种隔离等级]]></title>
      <url>/2020/08/30/mysql-isolation-level/</url>
      <content type="html"><![CDATA[<h1 id="0X00-What’s-this"><a href="#0X00-What’s-this" class="headerlink" title="0X00 What’s this"></a>0X00 What’s this</h1><p>我们知道 MySQL 中存在“事务”这么个事物（我是故意拗口的，哈哈哈哈哈哈哈）；我们也知道事务“一荣俱荣，一损俱损”（要么事物内所有查询均生效，要么均不生效）。那么现在问题来了，银行数据库中有两个事务在同时进行，我们来看一下这两个事务</p>
<blockquote>
<p>一条 SQL 就是一个查询，不一定是 <code>SELECT xxx</code> 才叫查询。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A    shawn 转账给 bluce 100 块钱</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money = money - <span class="number">100</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;shawn&#x27;</span>;    <span class="comment">-- 这行代码标记为  A-1</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money = money + <span class="number">100</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;bluce&#x27;</span>;     <span class="comment">-- 这行代码标记为  A-2</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> money <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;shawn&#x27;</span>;    <span class="comment">-- 这行代码标记为 B-1</span></span><br><span class="line"><span class="keyword">SELECT</span> money <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;bluce&#x27;</span>;     <span class="comment">-- 这行代码标记为 B-2</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>现在有这么一个情况：shawn 和 bluce 两人账上都有 100 块钱，此时事务 A 和 B 同时开始执行，那么事务 B 所查询到的两人的账户余额究竟是多少呢？这个问题并没有一个确切的结果，因为 B 在查询的时候，转账正在进行中。不过要回答这个问题也不是做不到，就需要引入标题中提到的“隔离等级”这个概念了。</p>
<p>我们在 MySQL 中使用这四种隔离等级：READ UNCOMMITTED/READ COMMITTED/REPEATABLE READ/SERIALIZABLE。隔离等级的不同就意味着在同一个时间节点下查询到的内容可能不同，数据的可靠性也会变得不同。接下来我们来简单了解一下这四种隔离等级，并且通过一个测试数据库来验证一下。</p>
<h1 id="0X01-How-to-try-it"><a href="#0X01-How-to-try-it" class="headerlink" title="0X01 How to try it"></a>0X01 How to try it</h1><p>首先要建一个数据库来做测试，表结构和两条基础数据长这样，可以通过随便什么方法把表先建好。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`account`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  <span class="string">`money`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`account`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;shawn&#x27;</span>, <span class="number">100</span>),(<span class="number">2</span>, <span class="string">&#x27;bluce&#x27;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们打开两个 MySQL 的终端连接（一定是两个），其中一个用来执行事务 A，一个用来修改隔离等级然后观察结果。</p>
<p>修改隔离等级的时候，可以选择“全局”或者“会话”两种级别，我们在测试阶段就只需要修改“会话”级就可以了。用的是<code>SET session transaction isolation level read committed;</code>这样的方法，其中最后的<code>read committed</code>就是其中一个隔离等级。</p>
<blockquote>
<p>注意在会话级别修改隔离等级应该是在你 select 去验证的会话里执行，而非执行事务的会话。换个说法就是“隔离等级”是针对事务外的，而非针对事务。</p>
</blockquote>
<a id="more"></a>

<h1 id="0X02-READ-UNCOMMITTED"><a href="#0X02-READ-UNCOMMITTED" class="headerlink" title="0X02 READ UNCOMMITTED"></a>0X02 READ UNCOMMITTED</h1><p>首先是 <code>READ UNCOMMITTED</code> 这个最简单的隔离机制：“读未查询”。其实这个翻译是准确的，就是有点别扭，换个说法叫“可以读到未提交的数据”。可以直接理解成“没有隔离”。也就是说所有改动都是实时的，别人事务里改动也是实时的，即使事务还没<code>commit</code>我也能看到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+-------+</span><br><span class="line">| id | username | money |</span><br><span class="line">+----+----------+-------+</span><br><span class="line">| 1  | shawn    | 100   |</span><br><span class="line">| 2  | bluce    | 100   |</span><br><span class="line">+----+----------+-------+</span><br></pre></td></tr></table></figure>
<p>拿上面的数据库来举个例子，现在数据库里数据是这个样子的。首先我们打开数据库终端两个，分别叫做“甲/乙”好了，为了好区分。甲负责执行事务，乙负责检验效果。我们在甲终端里开始一个事务，但是不提交</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql root@127.0.0.1:test&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Time: 0.002s</span><br><span class="line">mysql root@127.0.0.1:test&gt; UPDATE account SET money = money - 100 WHERE username = &#x27;shawn&#x27;;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Time: 0.003s;</span><br><span class="line">mysql root@127.0.0.1:test&gt; UPDATE account SET money = money + 100 WHERE username = &#x27;bluce&#x27;;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Time: 0.002s</span><br></pre></td></tr></table></figure>

<p>然后在乙终端里将会话的事务隔离等级改为 <code>READ UNCOMMITTED</code>，用这条命令<code>SET session transaction isolation level read uncommitted</code>就可以了。接下来我们再从终端乙查询一下整张表的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+-------+</span><br><span class="line">| id | username | money |</span><br><span class="line">+----+----------+-------+</span><br><span class="line">| 1  | shawn    | 0     |</span><br><span class="line">| 2  | bluce    | 200   |</span><br><span class="line">+----+----------+-------+</span><br></pre></td></tr></table></figure>

<p>发现转账已经成功了。问题也就出在这儿了，假设我们终端甲里执行的事物还有好多事情要做，而且后面执行过程中出错回滚了，那当前的数据其实就是错误的。这种读到脏数据的行为我们称之为 <strong>脏读</strong>。就光是这两条语句，都有可能出问题的。如果我们在事物给 shawn 的钱 100 之后读，就能读到 shawn 没有钱且 bluce 有 100 块，那此时的钱就凭空消失了 100。再或者说，shawn 在系统里给别人转账，点击确定后自己钱没了，然后系统在把钱加到对方账户上的时候发现对方账户有问题，事务就回滚了，shawn 发现自己的钱从 100 到 0 再到 100，就很奇怪。命名是转账成功变 0，不成功就保留 100 的事情，结果居然在两个数字减反复横跳，就很奇怪。</p>
<blockquote>
<p>记得最后在终端甲上 commit 一下，要不然一会儿数据对不上了</p>
</blockquote>
<p>如果要解决脏读的问题，其实也比较简单，可以引入下面提到的 READ COMMITTED隔离级别。</p>
<h1 id="0X03-READ-COMMITTED"><a href="#0X03-READ-COMMITTED" class="headerlink" title="0X03 READ COMMITTED"></a>0X03 READ COMMITTED</h1><p>想要让数据更靠谱就只有牺牲资源，比如加锁。在这种隔离等级下不会出现上面的脏读现象，只有当事务<code>commit</code>之后事物外才能读到改动。“那岂不是这样就完美了？” too young too simple. 正如前面说的，这种操作是要加锁的，既然加锁就有可能出问题。首先是并发，有 100 个人都要给 bluce 转账，触发了 100 个类似于上面的查询，第一个开始的会取得 bluce 的排他锁，后面的就直接卡住了。等第一个释放掉之后，后面 99 个事务再抢。。。这样还算好的，如果其中一个事物不止做了这些，还有更复杂的操作，导致事务耗时比较久，那么后面的所有事务都会被卡住，并且有可能会导致事务超时。</p>
<p>还有一个问题，涉及到索引。<code>UPDATE account SET money = money - 100 WHERE username = &#39;shawn&#39; </code>这条 SQL 对应的 username 字段如果在 account 表里没有索引，会发生什么？MySQL 会不知道哪条才是<code>username = &#39;shawn&#39;</code>，那咋办？锁表，准确的来说不是加表锁，是给表里所有行加行锁，等找到<code>username = &#39;shawn&#39;</code>的时候再释放其他的。如果表里有 100w 数据，那就要给 999999 条数据做无意义的加锁解锁操作。</p>
<h1 id="0X04-REPEATABLE-READ"><a href="#0X04-REPEATABLE-READ" class="headerlink" title="0X04 REPEATABLE READ"></a>0X04 REPEATABLE READ</h1><p>这个是 MySQL 默认采用的隔离级别，称为“可重复读”。既然有可重复读就一定会有一个对应的“不可重复读”，这里简单介绍一下怎么叫可重复读和不可重复读，还是以两个事务为例子。前面提到的两个隔离等级都是“不可重复读”的，这个很好理解，只是中文叫法有点奇怪，我们看一个“不可重复读”的例子（shawn/bluce 各有 100 块存款）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 A</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money = money - <span class="number">100</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;shawn&#x27;</span>;    <span class="comment">-- 这行代码标记为  A-1</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> money = money + <span class="number">100</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;bluce&#x27;</span>;     <span class="comment">-- 这行代码标记为  A-2</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务 B</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> money <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;shawn&#x27;</span>;     <span class="comment">-- 第一波查询</span></span><br><span class="line"><span class="keyword">SELECT</span> money <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;bluce&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> money <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;shawn&#x27;</span>;     <span class="comment">-- 第二波查询</span></span><br><span class="line"><span class="keyword">SELECT</span> money <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> username = <span class="string">&#x27;bluce&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>当两个事务同时开始后，事务 B 的两波查询可能会得到不同的结果，相同的 SQL 却得到了不同的数据，是会导致问题的。以 READ COMMITTED 为例，两个事物同时开始，B 完成了第一波查询发现俩人都有 100 块；这时候 A 才执行两条修改数据的查询，并且提交了结果；事务 B 继续执行查询，发现 shawn 没钱了，而 bluce 多了 100。这种情况在稍微复杂一点的事务中就会引发数据一致性的问题。所以<strong>MySQL选择了使用可重复读来做默认的隔离参数</strong>。</p>
<p>还有一个跟“不可重复读”类似的问题叫做“幻读”（跟幻术-月读没啥关系），因为只是防止数据更新造成“不可重复读”的话，我们可以通过加锁来解决，加什么锁呢，表锁？太费性能了，那就行锁吧。可是行锁有个问题，就是锁不到 INSERT ，毕竟数据还没有呢，你怎么锁。所以幻读简单来说是这样的：</p>
<ol>
<li>事务 A 实现一个“当用户名为 xxx 的用户不存在时就创建这条数据”</li>
<li>当事务 A <code>SELECT</code>了一趟发现不存在后，事务 B 创建了这个用户</li>
<li>事务 A 因为自己刚刚看了数据不存在，就创建这个用户，<em>然后就报错了</em></li>
</ol>
<blockquote>
<p>所以说“不可重复读”和“幻读”是两回事，但是本质上都会导致一个事务内对统一条件的 query 出现偏差。</p>
</blockquote>
<p>那么 MySQL 是怎么解决“不可重复读”和“幻读”这两个问题的呢？可以简单想象成，每当你开始一个事务的时候，就相当于给 MySQL 做了一个 git 分支，当你事务执行完了再 merge 回去（或者想象成快照）。</p>
<ol>
<li><strong>当然，MySQL当然不是这么实现的，只是用这种方法可以简单快速的理解到效果，而非原理</strong></li>
<li><strong>当然，MySQL当然不是这么实现的，只是用这种方法可以简单快速的理解到效果，而非原理</strong></li>
<li><strong>当然，MySQL当然不是这么实现的，只是用这种方法可以简单快速的理解到效果，而非原理</strong></li>
</ol>
<p>我这里因为只是介绍四种隔离级别就不再扩展了，有兴趣的话可以看一看 MVCC 相关的内容。</p>
<h1 id="0X05-SERIALIZABLE"><a href="#0X05-SERIALIZABLE" class="headerlink" title="0X05 SERIALIZABLE"></a>0X05 SERIALIZABLE</h1><p>最后一个隔离级别相当于“全隔离”，读数据加共享锁、写数据加排他锁、读写还互斥，<strong>并发性能“无敌”</strong>。当然了，这也不都是缺点，如果你恰巧需要一个没什么并发但是又对数据及时性和可靠性要求极高，那还真可以试试。</p>
<p><em>而且在这种隔离级别下，SELECT 都是要加锁的，你要是来个全表扫描，别人数据都写不进去了~</em></p>
<h1 id="0X06-Done"><a href="#0X06-Done" class="headerlink" title="0X06 Done."></a>0X06 Done.</h1><p>参考内容：《高性能 MySQL》和<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">美团技术团队博客</a></p>
]]></content>
      
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> isolation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 上下文管理器]]></title>
      <url>/2020/07/18/python-contextmanager/</url>
      <content type="html"><![CDATA[<h1 id="0X00-使用-with-as-语法"><a href="#0X00-使用-with-as-语法" class="headerlink" title="0X00 使用 with as 语法"></a>0X00 使用 with as 语法</h1><p>我们写程序经常会操作文件，我们都知道写文件要 <code>open/write/close</code> ，尤其是 <code>close</code> ，没有的话文件就会出问题（有些内容在缓存里，没写入磁盘）。不过我们现在写文件应该没什么人这样写了，都是用<code>with open(&#39;filename&#39;, &#39;w&#39;) as f</code>的方式来操作文件了。如果说这样做的好处，那多数人都会说“不用手动关闭文件了”，错肯定没错的。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200718142750.png"></p>
<p>上下比起来，上面的方式不仅多了一点点代码，而且随着中间逻辑代码变多，很可能会导致最后忘记 <code>close</code>，从而引发 bug。</p>
<h1 id="0X01-这就是上下文管理器"><a href="#0X01-这就是上下文管理器" class="headerlink" title="0X01 这就是上下文管理器"></a>0X01 这就是上下文管理器</h1><p>上面 <code>with xxx as xxx</code> 的调用方式就是在调用上下文管理器。简单来说上下文管理器就是：在执行你编写的代码（with xxx as xxx后面那坨）之前，<strong>操作一波</strong>；再在你编写的代码执行完后，<strong>操作一波</strong>。我们简单理解一下就是在 <code>with open(&#39;file_name&#39;, &#39;w&#39;) as f</code> 内层缩进的代码执行完成后自动帮你执行了<code>f.close()</code>（当然没这么简单，有兴趣可以去看一下 open 的源码，但是大体逻辑是这样的）。</p>
<a id="more"></a>

<h1 id="0X02-自己实现一个"><a href="#0X02-自己实现一个" class="headerlink" title="0X02 自己实现一个"></a>0X02 自己实现一个</h1><p>说了半天，咱们自己来实现一个上下文管理器好了。自己实现一个上下文管理器跟实现一个其他东西不太一样，不用继承任何东西，就像实现一个迭代器一样，只需要满足自己的协议（也就是上下文管理器协议）就可以。而且好在这个协议极其简单，实现一个类只需要满足满足两个方法就可以：<code>__enter__</code> 和 <code>__exit__</code>。我们先来写个 demo 试试看。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomProtocolConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host, port</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;假装开始连接, &#x27;</span>, host, port)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;进入了 __enter__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exception_type, exception_value, exception_traceback</span>):</span>   <span class="comment"># 这个定义是固定的，必然接收三个参数</span></span><br><span class="line">        print(<span class="string">&#x27;进入了 __exit__&#x27;</span>)</span><br><span class="line">        self.close()    <span class="comment"># 没有定义，只是断开连接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_data</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;假装在推数据：&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;假装收到了数据：&#x27;</span>, <span class="string">&#x27;hello,world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> CustomProtocolConnection(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;2333&#x27;</span>) <span class="keyword">as</span> conn:</span><br><span class="line">        conn.push_data(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line">        conn.pull_data()</span><br></pre></td></tr></table></figure>

<p>然后我们来看一下执行结果<br><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200718142514.png"></p>
<p>首先进行了常规的实例化；实例化之后执行了<code>__enter__</code>；然后执行我们自己编写的代码块；退出代码块之后执行了<code>__exit__</code>。我们可以看到上面定义<code>__exit__</code>的时候带了三个参数，看名字也看出来了，第一个参数是异常类型、第二个是异常的值（也就是错误消息）、第三个是异常的错误栈。如果我们在 <code>with xxx as xxx</code> 下面的代码块中出现异常了，那么异常会被捕获并传递到<code>__exit__</code>这里来，你可以根据情况来处理。这里不再展示具体如何处理异常了，大家可以手动触发异常然后在<code>__exit__</code>里打上断点来调试一下，很容易就能知道这里是怎么用的了。</p>
<p>实现一个上下文管理器不一定非要是类，一个函数照样可以（废话，<code>with open() as f</code> 不就是一个函数嘛）。我们可以来编写这样一个函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomProtocolConnection</span>:</span>     <span class="comment"># 一个本来就有的类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host, port</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;假装开始连接, &#x27;</span>, host, port)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_data</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;假装在推数据：&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;假装收到了数据：&#x27;</span>, <span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager      # 用 contextmanager 装饰器使这个方法成为上下文管理器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_2_server</span>(<span class="params">host, port</span>):</span></span><br><span class="line">    conn = CustomProtocolConnection(host, port)</span><br><span class="line">    print(<span class="string">&#x27;进入了 __enter__&#x27;</span>)  <span class="comment"># 并不是真正的 __enter__ 方法，但是有同样的效果</span></span><br><span class="line">    <span class="keyword">yield</span> conn</span><br><span class="line">    print(<span class="string">&#x27;进入了 __exit__&#x27;</span>)   <span class="comment"># 同理，并不是真正的 __exit__ 方法，但是又相同的效果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> connect_2_server(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="string">&#x27;2333&#x27;</span>) <span class="keyword">as</span> conn:</span><br><span class="line">    conn.push_data(<span class="string">&#x27;hello, world&#x27;</span>)</span><br><span class="line">    conn.pull_data()</span><br></pre></td></tr></table></figure>

<p>一个带有 <code>yield</code> 的函数是一个生成器，不过因为 <code>contentlib.contentmanager</code> 装饰器的作用，使它现在是一个上下文管理器了。以 <code>yield</code> 为界限，<code>yield</code> 之前的内容可以理解成是 <code>__enter__</code> 方法，后面的可以理解成是 <code>__exit__</code> 方法，由 <code>yield</code> 返回的那个值就是我们 <code>with connect_2_server as conn</code> 的 conn 了。我们来看一下这坨代码的运行结果，可以看到跟上面的效果是一样的。这两种方式其实是适用于不同的场景的，第一种直接编写 class 的方式适用于从零开始实现一个东西，这种就可以直接将其定义为上下文管理器，用起来比较方便；第二种通过装饰器实现一个额外的 function 的方式适用于在现有的代码块基础上实现上下文管理器，可以做到不侵入现有代码还实现所需功能的需求。<br><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200719105451.png"></p>
<h1 id="0X03-什么时候用"><a href="#0X03-什么时候用" class="headerlink" title="0X03 什么时候用"></a>0X03 什么时候用</h1><p>现在搞明白上下文管理器是什么了，也知道自己怎么才能实现一个上下文管理器了，那么什么时候才会用到这种东西呢？其实我们的操作很多时候都是可以用到的，只不过这个东西从来都不是必须的，很多情况下大家都绕开或者用了更麻烦一点的方式实现了。</p>
<p>首先，就像上面的自定义协议的通信一样，先要连接最后断开的情况就可以使用这种方式；比如要发起一大波 HTTP 请求，但是需要登录，就可以用这种方式实现自动登录和自动注销；再比如做数据统计或者导出，开始前要将数据整理一波，统计导出结束后再将结果邮件发送到指定邮箱，这种也是可以的。</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> with </tag>
            
            <tag> contentmanager </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django 中的 Objects]]></title>
      <url>/2020/07/14/django-manager/</url>
      <content type="html"><![CDATA[<h1 id="0X00-objects-是个啥"><a href="#0X00-objects-是个啥" class="headerlink" title="0X00 objects 是个啥"></a>0X00 objects 是个啥</h1><p>想必所有用过 Django 的人都会用到 Django 自带的 ORM 进行数据库查询。那既然用过 Django 的 ORM 就来看一下这段代码好了， <code>models.Stuent.objects.filter(name=&#39;Shawn&#39;)</code> 这段代码是什么意思呢？很简单，就是查询到名字为”Shawn”的学生信息。具体来说， <code>models</code> 应该是一个放了多个 model 的文件，<code>Student</code> 是一个具体的模型，<code>filter</code> 是筛选，<code>name=&#39;Shawn&#39;</code> 则是筛选条件。那么问题来了，中间那个 <code>objects</code> 是个啥呢？（你知道？知道还在这儿看啥，有这空看看其他文章，打打游戏看看电影不好吗🤣）</p>
<p>通过 <code>type</code> 可知，这个 <code>objects</code> 是一个 <code>django.db.models.manager.Manager</code> 的实例（或者是他子类的实例）。然后我们来看看这个<code>Manager</code>是个什么❓</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200714212410.png" alt="Django ORM"></p>
<blockquote>
<p>A Manager is the interface through which database query operations are provided to Django models. At least one Manager exists for every model in a Django application.</p>
</blockquote>
<p>从 Django 文档得知“Manager 是 Django 用来进行数据库查询的一个接口，在 Django 应用中每个 model 都需要至少有一个 Manager”。</p>
<a id="more"></a>

<h1 id="0X01-Manager-的用法与自定义"><a href="#0X01-Manager-的用法与自定义" class="headerlink" title="0X01 Manager 的用法与自定义"></a>0X01 Manager 的用法与自定义</h1><p>我们正常来说用的 <code>filter/exclude/first/last</code> 这种查询都是用的 Manager，用法大家是都会用的，不过自定义的话就是另一回事儿了。我们假设有下面这个 model</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField()</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    gender = models.CharField()</span><br><span class="line">    birthday = models.DateField()</span><br><span class="line">    height = models.DecimalField()</span><br><span class="line">    weight = models.DecimalField()</span><br><span class="line">    remark = models.TextField()</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;学生&#x27;</span></span><br></pre></td></tr></table></figure>

<p>虽然我们没有手动指定 <code>objects</code>，但是其实已经从 <code>models.Model</code> 继承来了。如果我们非要手动指定的话，可以<code>objects = models.Manager()</code>。<strong>值得注意一点是，如果我们手动指定了 Manager 的话，Django 就不会再给我们一个可用的 objects 了。</strong> </p>
<p>下面我们来说一下关于自定义 Manager 的方法，和什么时候需要自定义 Manager。通常来说，没有必须要用 Manager 才能完成的操作，但是很多时候利用自定义 Manager 会帮我们节省很多时间和代码。我们考虑这么一种情况，上面那个 model 定义了一个学生信息表，我们在系统里需要非常经常地使用“身高超过 180，且体重在 70 到 80 之间，且成年的男生；身高超过 170，且体重在 55 到 65 之间，且成年的女生；当天过生日的所有同学”这三种筛选条件。当然，最简单的方法就是每次使用的时候都去 <code>filter</code> 一遍，这也没错，不过这样就太奇怪了。稍微有点编程经验的可能会写出如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这函数名确实太长了，就不乱编了，三个函数对应上面三个查询</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_student_1</span>():</span>   </span><br><span class="line">    <span class="keyword">return</span> Student.objects.filter(gender=<span class="string">&#x27;M&#x27;</span>, height__gt=<span class="number">180</span>, weight__range=(<span class="number">70</span>, <span class="number">80</span>), age__gte=<span class="number">18</span>)</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_student_2</span>():</span></span><br><span class="line">    <span class="keyword">return</span> Student.object.filter(gender=<span class="string">&#x27;M&#x27;</span>, height__gt=<span class="number">170</span>, weight__range=(<span class="number">55</span>, <span class="number">65</span>), age__gte=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_student_3</span>():</span></span><br><span class="line">    today = datetime.date.today()</span><br><span class="line">    <span class="keyword">return</span> Student.objects.filter(birthday__month=today.month, birthday__day=today.day)</span><br></pre></td></tr></table></figure>

<p>调用的时候每次都是 <code>studnet_1_queryset = get_student_1()</code>。尤其是如果要在这个基础上增加新的筛选条件，画风就会变成这样：<code>student_x_queryset = get_student_1().filter(xxxx).exclude(yyyyy)</code>。就…….也不是不行，不过看起来确实很奇怪，而且跟使用 Manager 的方式比起来也非常不 Pythonic。</p>
<p>如果使用使用 Manager 的方式编写的话就可以是下面这个样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialStudentManager</span>(<span class="params">models.Manager</span>):</span></span><br><span class="line">    <span class="comment"># 自定义一个方便获取这三种数据的 Manager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">student_1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.filter(gender=<span class="string">&#x27;M&#x27;</span>, height__gt=<span class="number">180</span>, weight__range=(<span class="number">70</span>, <span class="number">80</span>), age__gte=<span class="number">18</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stuent_2</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.filter(gender=<span class="string">&#x27;M&#x27;</span>, height__gt=<span class="number">170</span>, weight__range=(<span class="number">55</span>, <span class="number">65</span>), age__gte=<span class="number">18</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">student_3</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.filter(birthday__month=today.month, birthday__day=today.day)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField()</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    gender = models.CharField()</span><br><span class="line">    birthday = models.DateField()</span><br><span class="line">    height = models.DecimalField()</span><br><span class="line">    weight = models.DecimalField()</span><br><span class="line">    remark = models.TextField()</span><br><span class="line">    </span><br><span class="line">    objects = SpecialStudentManager()   <span class="comment"># model 这里就改了这一行</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;学生&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然改动了 Model 但是没有改动数据库表，所以不需要<code>migrations</code>。</p>
</blockquote>
<p>现在我们尝试调用一下上面定义的几个查询：<code>Student.objects.student_1()</code>这样就可以了，而且如果用<code>@property</code>装饰上面的方法的话，会更好一些。当然了，我们还可以扩展一下用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialStudentManager</span>(<span class="params">models.Manager</span>):</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">student_count</span>(<span class="params">self</span>):</span>    <span class="comment"># 所有学生人数</span></span><br><span class="line">        <span class="keyword">return</span> self.all().count()</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">student_name_list</span>(<span class="params">self</span>):</span>    <span class="comment"># 所有学生人名列表</span></span><br><span class="line">        <span class="keyword">return</span> list(self.all().values_list(<span class="string">&#x27;name&#x27;</span>, flat=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<p>不过可以看出来，正如上面所说“一切用自定义 Manager 实现的功能，都可以不用自定义 Manager 实现”，但是自定义 Manager 的做法也确实让我们的代码更清晰明了，后面改起来也更舒服（不用为了一个常用的筛选去改多处代码），可读性也更高了。</p>
]]></content>
      
        
        <tags>
            
            <tag> Django </tag>
            
            <tag> manager </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次 Django Save 导致的数据异常]]></title>
      <url>/2020/07/11/django-save/</url>
      <content type="html"><![CDATA[<h1 id="0X00-按惯例得有一个标题"><a href="#0X00-按惯例得有一个标题" class="headerlink" title="0X00 按惯例得有一个标题"></a>0X00 按惯例得有一个标题</h1><p>众所周知<code>save</code>是 Django 中最常用的保存数据的方法。但是一般来说大家经常会把“常用“理解成“万能“，然后能用的时候就全用这一种方式。不过编程 中是没有所谓的“一招鲜吃遍天“的，Django 之所以提供了那么多中保存数据的方法也侧面证实了这一点。</p>
<p>首先来看一下我遇到的这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .utils <span class="keyword">import</span> calculate_score</span><br><span class="line"></span><br><span class="line">queryset = Student.objects.all()</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> queryset:</span><br><span class="line">    student.score = calculate_score(student)    <span class="comment"># 调用一个工具函数计算该学生的成绩</span></span><br><span class="line">    student.save()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码乍一看没有什么问题，因为计算的值是通过<code>calculate_score</code>这个函数进行的，所以不能使用<code>queryset.update(xxx)</code>的方法。然后咱们看一下 Django 文档是如何描述 queryset 的。</p>
<blockquote>
<p>QuerySets are lazy – the act of creating a QuerySet doesn’t involve any database activity. You can stack filters together all day long, and Django won’t actually run the query until the QuerySet is evaluated. </p>
<p><a href="https://docs.djangoproject.com/en/2.2/topics/db/queries/#querysets-are-lazy">QuerySets are lazy</a></p>
</blockquote>
<blockquote>
<p>nternally, a QuerySet can be constructed, filtered, sliced, and generally passed around without actually hitting the database. No database activity actually occurs until you do something to evaluate the queryset.</p>
<p><a href="https://docs.djangoproject.com/en/2.2/ref/models/querysets/#when-querysets-are-evaluated">When QuerySets are evaluated</a></p>
</blockquote>
<p>QuerySets are lazy 内容总结来说就是“Django 中的 QuerySet 只有在用的时候才会真的去数据库里查，而不是生成 QuerySet 的时候“。后面的 When QuerySet are evaluated 则标明了什么叫做“真正在使用“，给出了下面几个条件，当你做这些事情的时候就是“真正在使用“了。这些条件包括：迭代、 切片、列表等（我英文水平小学三年级，解读地不对的地方还希望大家指出）。 所以显然我们对这个 queryset 来了个 <code>for</code> 循环就满足了上述的“迭代“，所以这时候数 Django 就会真正的从数据库中将数据真正的 <strong>取出来</strong>。</p>
<p>现在问题来了。我们思考一个问题，如果我一秒钟能计算10 个学生的成绩，然后整个<code>Student</code>表有 3W 学生，得出“处理所有学生信息需要消耗 50 分钟的时间“这样的结论（每秒 10 条和一共 3W 是乱写的，真实数据通常比这个大得多）。</p>
<p><strong>如果在执行这个循环的时候，某位同学修改了自己的的信息，比如手机号，会发生什么？</strong> 有两种可能：第一种可能是这位同学修改自己手机号的时候计算分数的循环已经把他的分数计算完了，那么他的手机号修改也生效了（这种最好）。但是如果他改手机号的时候循环还没到他呢？假设他把手机号从原来的 123 改成了 456，那么他改完手机号的一瞬间数据库里存进去的确实是 456，没有问题。<strong>但是 queryset 里是他改手机号以前取出来的 123</strong>，这时候循环到他了，计算完之后来了一个<code>student.save()</code>，如此一来他刚刚改好的手机号码就又回到了 123。</p>
<p>所以说这种写法并不会 100% 出现问题。整个循环耗时越久，出现问题的可能性越大；系统中数据变更越频繁，出现问题的可能性越大。当然了，bug 就是 bug，不能因为 bug 没触发就无所畏惧了，还是得解决的。通常来说有两种解决方法，下面是第一种</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> queryset:</span><br><span class="line">    new_score = calculate_score(student)</span><br><span class="line">    Student.objects.filter(id=student.id).update(score=new_score)</span><br></pre></td></tr></table></figure>

<p>这种方式仍然比较 young 比较 simple 比较 naive，不过<strong>又不是不能用</strong>。<br><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200711151128.jpeg"></p>
<p>但是这种用法显然是不好的，而且 <code>update</code> 本来也不是让我们这么用的。所以我们还是得回到<code>save</code>上，Django 其实已经提供了一个参数给 <code>save</code> 了，可以用下面这种方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> queryset:</span><br><span class="line">    student.score = calculate_score(student)</span><br><span class="line">    student.save(update_fields=[<span class="string">&#x27;score&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>也就是在 <code>save</code> 的时候带上具体需要更新哪个字段，其他的就不更新了。而且通过传递的参数也可以看出，指定的是多个字段，如果有需要修改多个字段的话，就只修改这一个就好了。</p>
<p>不过其实这里还是有一个潜在问题的，那就是说：恰好我们在更新 score 的时候，其他地方也在更新这个。不过这个更多的时候就是我们程序逻辑的问题了，因为在几乎同一时间对一个字段进行修改，然后修改的双方又互相不知道的话，总是会出问题的。</p>
]]></content>
      
        
        <tags>
            
            <tag> Django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在 Django 与 DRF 中优雅地校验权限]]></title>
      <url>/2020/07/05/drf-permission/</url>
      <content type="html"><![CDATA[<h1 id="0X00-Django-中的权限结构、定义"><a href="#0X00-Django-中的权限结构、定义" class="headerlink" title="0X00 Django 中的权限结构、定义"></a>0X00 Django 中的权限结构、定义</h1><p>我们知道在创建了一个 Django 项目之后，默认就有两个公开可用的 model：User 和 Group，这两个 model 的一项功能就是用来做权限管理的。系统中会有很多项权限，单个 user 可以配置拥有哪些权限，也可以将权限配置给 group。然后校验单个权限的时候其实就是将 user 本身的权限，和 user 所在的所有组的权限做一个并集，看本次操作的权限是否在这个并集里。在，那就校验通过；不在，那就只有 HTTP 403 了。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200705173202.png"></p>
<blockquote>
<p>HTTP 401 和 HTTP 403 的区别：401 的描述是 Forbidden，而 401 是 Unauthorized，前者是没有权限，而后者干脆没通过认证。举个例子，你想查看公司财务的详细报表，财务经理一看你就是个一线小程序员，就给你一个 401，告诉你这不是你可以看的东西。如果你想看别的公司财务的详细报表，别人公司财务经理一看你根本不是他们公司的人，就直接给你了个 401 了。（俗话说十个比喻九个不准，我这个比喻当然也并不非常准确，不过对于分不清 401 和 403 的同学而言应该也问题不大🤣）</p>
</blockquote>
<p>Django 自己对每一个 model 都创建了 create，update，delete 的权限，我们可以直接拿来用，也可以自己添加新权限。Django 自己是针对各个 model 做的权限，所以最简单的权限建立是在 model 层进行的。就比如下面这种，如果我想要为 Student 这个 model 建立相关的权限，就可以通过修改 <code>Meta</code> 类里的 <code>permissions</code> 来实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">  	user = models.OneToOneField(<span class="string">&#x27;django.contrib.auth.models.User&#x27;</span>)</span><br><span class="line">  	name = models.CharField() <span class="comment"># 纯展示，就不详细定义了</span></span><br><span class="line">    birthday = models.DatetimeField()</span><br><span class="line">    phone = models.CharField()</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">				verbose_name = <span class="string">&#x27;学生&#x27;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line">        permissions = (</span><br><span class="line">        		<span class="comment"># (&#x27;权限名&#x27;, &#x27;权限描述&#x27;),</span></span><br><span class="line">          	(<span class="string">&#x27;check_classmate_score&#x27;</span>, <span class="string">&#x27;查看同班同学的成绩&#x27;</span>),</span><br><span class="line">          	(<span class="string">&#x27;send_class_notify&#x27;</span>, <span class="string">&#x27;发送班级通知&#x27;</span>),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>不过这里也看到了，每次对权限进行 CUD 的时候都是在改 model 的，所以每次改动完 model 记得都要进行一次<code>migrate</code>操作才行。不过不用担心性能问题，这个 migrate 只对 Permission 表进行 CUD 操作，而并非改表，所以非常快就搞定了。注意的一点是，不管你把这些 permissions 写在哪个 model 下，最终他们创建好的数据都还是在 Permission 表里，也就是数据库（我这里用的是 MySQL）里的<code>auth_permission</code>表了，这个表结构和数据是下面这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field           | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+-----------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id              | int(11)      | NO   | PRI | &lt;null&gt;  | auto_increment |</span><br><span class="line">| name            | varchar(255) | NO   |     | &lt;null&gt;  |                |</span><br><span class="line">| content_type_id | int(11)      | NO   | MUL | &lt;null&gt;  |                |</span><br><span class="line">| codename        | varchar(100) | NO   |     | &lt;null&gt;  |                |</span><br><span class="line">+-----------------+--------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+-----+------------------------------------+-----------------+-------------------------------+</span><br><span class="line">| id  | name                               | content_type_id | codename                      |</span><br><span class="line">+-----+------------------------------------+-----------------+-------------------------------+</span><br><span class="line">| 1   | Can add log entry                  | 1               | add_logentry                  |</span><br><span class="line">| 2   | Can change log entry               | 1               | change_logentry               |</span><br><span class="line">| 3   | Can delete log entry               | 1               | delete_logentry               |</span><br><span class="line">| 4   | Can add group                      | 2               | add_group                     |</span><br><span class="line">| 5   | Can change group                   | 2               | change_group                  |</span><br><span class="line">| 6   | Can delete group                   | 2               | delete_group                  |</span><br><span class="line">| 7   | Can add permission                 | 3               | add_permission                |</span><br><span class="line">| 8   | Can change permission              | 3               | change_permission             |</span><br><span class="line">| 9   | Can delete permission              | 3               | delete_permission             |</span><br><span class="line">| 10  | Can add user                       | 4               | add_user                      |</span><br><span class="line">| 11  | Can change user                    | 4               | change_user                   |</span><br><span class="line">| 12  | Can delete user                    | 4               | delete_user                   |</span><br><span class="line">+-----+------------------------------------+-----------------+-------------------------------+</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0X01-在-Django-中校验与分配权限"><a href="#0X01-在-Django-中校验与分配权限" class="headerlink" title="0X01 在 Django 中校验与分配权限"></a>0X01 在 Django 中校验与分配权限</h1><p>权限在表里之后“唯一”生效的地方就是 django-admin 了，就是说如果登录 django-admin 的用户没有<code>add_user</code>的权限，那你创建用户的时候就会被拒绝。但是我们平时更多的时候并不是在 django-admin 里，而是自己实现的前台页面，那该怎么自己校验权限呢？Django 中给 user 实例了两个方法：<code>user.has_perm</code>和<code>user.has_perms</code>。显然，前者校验单个权限，后者校验多个权限。咱们先来看一下是如何校验的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: shawn = User.objects.create(username=<span class="string">&#x27;shawn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: shawn.has_perm(<span class="string">&#x27;auth.add_user&#x27;</span>)	<span class="comment"># 单个权限校验直接传权限的 code_name</span></span><br><span class="line">Out[<span class="number">3</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: shawn.has_perms([<span class="string">&#x27;auth.add_user&#x27;</span>, <span class="string">&#x27;auth.del_user&#x27;</span>])  <span class="comment"># 多个全线同时检验时将多个 code_name 放在列表中</span></span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: admin = User.objects.create(username=<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: admin.is_superuser = <span class="literal">True</span>		<span class="comment"># 设置 admin 用户为超级管理员</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: admin.save()</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: admin.has_perm(<span class="string">&#x27;auth.add_user&#x27;</span>)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: admin.has_perms([<span class="string">&#x27;auth.add_user&#x27;</span>, <span class="string">&#x27;auth.del_user&#x27;</span>])</span><br><span class="line">Out[<span class="number">9</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>我们从 Django 源码中可以看到，如果正在校验的用户是“活跃的”而且是“超级管理员”，那就直接不校验了，通过。否则就去校验一波。同时校验多个权限的时候用了<code>all</code>去逐个校验，遇到一个没有的权限也就 False 了。具体的细节这里就不多说了，感兴趣的话可以看一下源码，在<code>django.contrib.auth.models.User</code>中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_perm</span>(<span class="params">self, perm, obj=None</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return True if the user has the specified permission. Query all</span></span><br><span class="line"><span class="string">    available auth backends, but return immediately if any backend returns</span></span><br><span class="line"><span class="string">    True. Thus, a user who has permission from a single auth backend is</span></span><br><span class="line"><span class="string">    assumed to have permission in general. If an object is provided, check</span></span><br><span class="line"><span class="string">    permissions for that object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Active superusers have all permissions.</span></span><br><span class="line">    <span class="keyword">if</span> self.is_active <span class="keyword">and</span> self.is_superuser:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Otherwise we need to check the backends.</span></span><br><span class="line">    <span class="keyword">return</span> _user_has_perm(self, perm, obj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_perms</span>(<span class="params">self, perm_list, obj=None</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return True if the user has each of the specified permissions. If</span></span><br><span class="line"><span class="string">    object is passed, check if the user has all required perms for it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> all(self.has_perm(perm, obj) <span class="keyword">for</span> perm <span class="keyword">in</span> perm_list)</span><br></pre></td></tr></table></figure>

<p>然后要考虑的就是如何将权限分给用户了，我们可以在 Django 源码中看到 user 和 permission 的关联关系是：ManyToMany ，所以直接修改用户的<code>user_permissions</code>字段就可以了。针对 group 也是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">36</span>]: shawn = User.objects.get(username=<span class="string">&#x27;shawn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: perm = Permission.objects.get(codename=<span class="string">&#x27;add_user&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: shawn.user_permissions.add(perm)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: shawn.save()</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: shawn.has_perm(<span class="string">&#x27;auth.add_user&#x27;</span>)</span><br><span class="line">Out[<span class="number">40</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有一个比较干扰人的问题，就是为什么我的 codename 明明是 add_user 但是校验的时候却要用<code>auth.add_user</code>。当是这个问题也是困扰了我比较久，还因为这个问题导致了我程序出现 bug（比如本来该校验<code>car.open_door</code>的地方我校验了<code>open_door</code>）。比较明显的一处是因为“重名“，因为我们 model 多了之后会出现好多处重名的权限名，所以校验的时候应该在codename 前面加上 app_name。可以看一下我们 settings 里面的 INSTALLED_APPS 配置，有一条就是<code>django.contrib.auth</code>。</p>
</blockquote>
<h1 id="0X02-DRF-中的权限设计"><a href="#0X02-DRF-中的权限设计" class="headerlink" title="0X02 DRF 中的权限设计"></a>0X02 DRF 中的权限设计</h1><p>我们在配置 DRF 的时候通常会在 settings 里写下类似这样的配置，这意味着给默认的 permission_class 设置成了<code>IsAuthenticated</code>，也就是说登录即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    ),</span><br><span class="line">	  <span class="comment">#..............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这也只是一个默认的权限配置，你用 DRF 的<code>ViewSet</code>创建的新 API 默认是登录即可，但是总会有其他的情况，这种时候通常来说我我们会重写 ViewSet 中的两个方法：<code>get_permissions</code>和<code>get_queryset</code>。先说正经的权限，也就是<code>get_permissions</code>好了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APIView</span>(<span class="params">View</span>):</span></span><br><span class="line">    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES</span><br><span class="line">    <span class="comment"># .........</span></span><br><span class="line">    </span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">get_permissions</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Instantiates and returns the list of permissions that this view requires.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> [permission() <span class="keyword">for</span> permission <span class="keyword">in</span> self.permission_classes]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_permissions</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Check if the request should be permitted.</span></span><br><span class="line"><span class="string">        Raises an appropriate exception if the request is not permitted.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> permission <span class="keyword">in</span> self.get_permissions():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> permission.has_permission(request, self):</span><br><span class="line">                self.permission_denied(</span><br><span class="line">                    request, message=getattr(permission, <span class="string">&#x27;message&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_object_permissions</span>(<span class="params">self, request, obj</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Check if the request should be permitted for a given object.</span></span><br><span class="line"><span class="string">        Raises an appropriate exception if the request is not permitted.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> permission <span class="keyword">in</span> self.get_permissions():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> permission.has_object_permission(request, self, obj):</span><br><span class="line">                self.permission_denied(</span><br><span class="line">                    request, message=getattr(permission, <span class="string">&#x27;message&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">                )</span><br></pre></td></tr></table></figure>

<p>我们从源码中可以看到这个方法其实很很简单，就只是把<code>self.permission_classes一遍，通过 codename 进行实例化，最终返回一个实例化的 permission 列表。然后在</code>check_permissions<code>或者</code>check_object_permissions<code>的时候对这个列表轮询一遍，调用 permission 实例的</code>has_object_permission(request, view)`方法来判断是否有权限执行本次请求，最终通过返回的 True/False 来确定是否有权限继续操作，如果没有权限就直接终止请求了。</p>
<p>根据上述条件，我们就可以自己写一个权限校验类了，一个简单的实现时下面这种样子的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermsRequired</span>(<span class="params">permissions.BasePermission</span>):</span></span><br><span class="line">		<span class="string">&quot;&quot;&quot;需要有多个权限之一，也就是说有其中一个权限即可&quot;&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *perms</span>):</span></span><br><span class="line">        self.perms = perms	<span class="comment"># 接受多个参数，全部都是权限</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 被 call（前期可以理解成被当成函数调用） 的时候返回自身</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span>(<span class="params">self, request, view</span>):</span></span><br><span class="line">        user = request.user		<span class="comment"># 既然传进来了 request，那就可以拿到 user 了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> user.is_superuser:	<span class="comment"># superuser 拥有一切权限</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        user_perms = user.get_all_permissions()	 <span class="comment"># 取得用户所拥有的的所有权限</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 取本次需要的权限和用户所有的权限的交集，如果有交集则校验通过（也就是 “或” 校验</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> user_perms &amp; set(self.perms) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment"># 如果想要“与”校验，可以改成下面这种</span></span><br><span class="line">        <span class="comment"># return all([perm in user_perms for perm in set(self.perms)])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="0X03-DRF-如何校验权限"><a href="#0X03-DRF-如何校验权限" class="headerlink" title="0X03 DRF 如何校验权限"></a>0X03 DRF 如何校验权限</h1><p>现在我们知道 Django 和 DRF 中的权限大概是怎么实现的了，那么具体怎么用在 DRF 框架的 web 程序中呢？下面看一段实例代码。这坨代码就是我们最常见的一个 DRF 开出来的 ViewSet 了，同时支持<code>GET/POST/PUT/PATCH/DELETE</code>五种 HTTP 方法。</p>
<blockquote>
<p>在 DRF 的 ViewSet 中，可以使用 self.action 来访问到当前请求的 function。默认情况下的 CRUD 对应的方法名是：<code>list/create/retrieve/partial_update/update/delete</code>这五个，分别对应了<code>GET /</code>,<code>POST /</code>,<code>GET /id/</code>,<code>PATCH /id/</code>,<code>PUT /id/</code>,<code>DELETE /id/</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentViewSet</span>(<span class="params">viewsets.ModelViewSet</span>):</span></span><br><span class="line">  	queryset = models.Student.objects.all()</span><br><span class="line">  	<span class="comment"># ...........</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_permissions</span>(<span class="params">self</span>):</span></span><br><span class="line">      	<span class="keyword">if</span> self.action == <span class="string">&#x27;list&#x27;</span>:		<span class="comment"># 如果是对根目录进行 GET 则需要列表权限</span></span><br><span class="line"> 						self.permission_classes = (</span><br><span class="line">                perms.PermsRequired(<span class="string">&#x27;student.list_student&#x27;</span>),</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">if</span> self.action == <span class="string">&#x27;create&#x27;</span>:		<span class="comment"># 如果对根目录进行 POST 则需要创建权限</span></span><br><span class="line">            self.permission_classes = (</span><br><span class="line">                perms.PermsRequired(<span class="string">&#x27;student.create_student&#x27;</span>),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> super(StudentViewSet, self).get_permissions()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span>(<span class="params">self</span>):</span></span><br><span class="line">      	<span class="comment"># ........</span></span><br><span class="line">        <span class="keyword">return</span> self.serializer_class</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span>(<span class="params">self</span>):</span></span><br><span class="line">        user = self.request.user</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果用户拥有查看所有学生信息的权限，则返回所有学生信息</span></span><br><span class="line">        <span class="keyword">if</span> user.has_perm(<span class="string">&#x27;student.query_all_students&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> self.queryset</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果用户有查看自己班里学生信息的权限，则返回自己班里的学生信息</span></span><br><span class="line">        <span class="keyword">if</span> user.has_perm(<span class="string">&#x27;ratel.query_self_class_students&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> self.queryset.filter(</span><br><span class="line">                student_class=user.student.student_class</span><br><span class="line">            )</span><br><span class="line">        <span class="comment"># ...还有其他校验</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果什么权限都没找到，那就只能返回自己的数据了</span></span><br><span class="line">        <span class="keyword">return</span> models.Student.objects.filter(id=user.student.id)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以从上面看到有两个地方在校验权限，一个是<code>get_permissions()</code>，另一个是<code>get_queryset()</code>。前者是严谨的“权限”，也就是说“你想要执行某某某操作，你就需要拥有某某某权限，没有就不信”；后者是广义的“权限”，会从大到小来校验，比如这里可以先判断你是否拥有查看所有人信息的权限，有，就给你所有人的信息；没有，就看你能不能看班里人的信息，有，就给你班里人的信息；没有，就只返回给你自己的数据。</p>
<p>这两种用法是在日常工作中用法最多的了。其他再有的话就是在 serializer 的 validate 中进行的校验，比如有一个功能叫做“强制删除”，这个功能可以跳过一切检测（比如检测学生是否在校，学生是否毕业超过3 年，学生饭卡是否还有钱），就直接删除。这种权限可能只会分配给高级别管理员使用，但是又不可能针对这种功能再单独开新的 API 来做，这样太奇怪了。所以我们可以通过一个参数来控制前置删除，比如<code>force_delete</code>。这样我们就可以写出类似下面的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line">  	user = self.context[<span class="string">&#x27;request&#x27;</span>].user</span><br><span class="line">    force_delete = validated_data.get(<span class="string">&#x27;force_delete&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> force_delete:</span><br><span class="line">      	<span class="keyword">if</span> <span class="keyword">not</span> user.has_perm(<span class="string">&#x27;student.force_delete&#x27;</span>):</span><br><span class="line">        		<span class="keyword">raise</span> serializers.ValidationError(<span class="string">&#x27;你没有强制删除用户的权限&#x27;</span>)</span><br><span class="line">      	</span><br><span class="line">  	<span class="keyword">return</span> validated_data</span><br></pre></td></tr></table></figure>



<h1 id="0X04-THE-END"><a href="#0X04-THE-END" class="headerlink" title="0X04 THE END"></a>0X04 THE END</h1><p>今天是个美好的周日，中午的时候想要喝了咖啡写篇博客就去玩 <em>火焰纹章</em> 的的，然而越看这个权限越越觉得自己不懂，之前一度以为自己挺明白的，结果一直是处在知其然的状态，并没有知其所以然（虽然现在知道也也不彻底）。然后就一点点看之前的代码，看实现方案，看着看着又得进去看源码，结果计划一个多小时搞定的东西搞了快四个小时。不过还好，也不亏，收获颇丰~</p>
]]></content>
      
        
        <tags>
            
            <tag> Django </tag>
            
            <tag> Django REST framework </tag>
            
            <tag> Permission </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SSO 与 CAS]]></title>
      <url>/2020/07/04/cas-sso/</url>
      <content type="html"><![CDATA[<h1 id="0X00-网站怎么登陆"><a href="#0X00-网站怎么登陆" class="headerlink" title="0X00 网站怎么登陆"></a>0X00 网站怎么登陆</h1><p>回忆一下你用过的网站们，一般都是怎么登陆的？ “就输入用户名密码登陆呗，要么就扫码登录，要么手机验证码登录，还能有啥”。确实没啥，咱们平时用到的登录方式也就都是这样的，而且这些其实从原理上来说都是 <strong>证明你是你</strong> 的手段，用户名密码是通过“密码只有你自己知道”为前提的，扫码和验证码是以“手机一定在你自己手上，并且只有你自己能解锁”为前提的。所以其实用户名密码并不是登录的唯一方法，理论上能证明你是你的一切方法都可以用来做授权认证，所以我们可以看到除了密码，出现了扫码、短信邮箱验证码、指纹、人脸、声纹、虹膜巴拉巴拉的。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/ab-blog-2fa2.webp" alt="auth"></p>
<p>上面这些都是稳定靠谱的登录方式，我们来想另一个问题，你们有一个网站选用了用户名密码的方式登录，你和用户开开心心登录。后来你上线了另一个网站，你觉得用户该怎么登陆这个新网站呢？“新网站就再注册一次呀！”好的，用户又注册了一次。随着你们公司业务逐渐壮大，上线了 100 个网站，那用户要注册一百次吗？万一自己常用的用户名被占用了呢，岂不是 100 个网站可能会用 100 套不同的用户名密码？那用户可能就要骂娘了呦。</p>
<p>聪明的你可能会想到，既然现在这么流行微服务，我们把登录做一个微服务，所有系统的登陆都用这一套不就好了？</p>
<h1 id="0X01-这就是-SSO"><a href="#0X01-这就是-SSO" class="headerlink" title="0X01 这就是 SSO"></a>0X01 这就是 SSO</h1><p>那有一个好消息和一个坏消息，坏消息是，你以为的这个天才想法就是<a href="https://zh.wikipedia.org/wiki/%E5%96%AE%E4%B8%80%E7%99%BB%E5%85%A5"> SSO（Single Sign On）</a>单点登录，早就被人想到而且实现了很多遍了；好消息是，轮子很多，完全不用自己造，挑一个拿来用就好。</p>
<blockquote>
<p>单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。这项功能通常是以轻型目录访问协议（LDAP）来实现，在服务器上会将用户信息存储到LDAP数据库中。相同的，单一退出（single sign-off）就是指，只需要单一的退出动作，就可以结束对于多个系统的访问权限。  –维基百科</p>
</blockquote>
<a id="more"></a>

<p>SSO 简单来说就是当你有一堆系统需要登录的时候，通过一个登录服务将所有系统统筹起来的方案。在不用 SSO 的时候，登录一个系统是这样的：</p>
<ol>
<li>打开网站 A </li>
<li>A 网站发现你没有 token 或者 cookie，要求你登录</li>
<li>你输入用户名密码传递给 A 网站</li>
<li>A 网站通过核对发现用户名密码正确，给你下发一个 token 或者 cookie</li>
<li>你带着 token 或者 cookie 就可以正常访问了</li>
</ol>
<p>如果你要登录一家公司的 3 个系统，那就得重复上面流程三次，如果密码输入错了或者记混了用户名密码和网站的联系可能还会登录好多次。SSO 的存在不能解决你登陆一个系统的问题，但是能解决你登录多个系统的问题。</p>
<p>通常来说 SSO 的工作流程是这样的</p>
<ol>
<li>打开网站 A</li>
<li>A 网站发现你没有 token 或者 cookie，要求你登录，给你一个 302 跳转到 SSO 站点</li>
<li>你把用户名密码发给 SSO</li>
<li>SSO 认证通过后发给你 token，并且再通过 302 给你跳回刚才的网站</li>
<li>后面你就可以带着 token 正常访问了</li>
</ol>
<p>乍一看好像一步都没有少，反而程序上的实现还更复杂了，但是 SSO 的优势就在于再登录新系统的时候。如果这时候你要登录这家公司的 B 系统，在没有 SSO 的情况下就得重复上面的步骤，而且你还得重新输入用户名密码。但是在有 SSO 的情况下是这样的：</p>
<ol>
<li>你打开网站 B</li>
<li>B 网站发现你没有 token，要求你登录，给你一个 302 跳转到 SSO 站点</li>
<li>SSO 站点是同一个，所以你会带着 token 访问 SSO，这时候 SSO 就知道你登陆过了，就会给你一个用于网站 B 的 token，并且 302 跳转过去</li>
<li>你带着 token 正常访问 B 网站</li>
</ol>
<p>从条数上看没少什么，但是你会发现真正你人工在操作的就只是“打开 B 网站”而已，后面的都是程序在跳转。这样不仅成功实现了一套用户名面走天下的方案，还成功地给用户减小了登录多个系统的麻烦。</p>
<h1 id="0X02-CAS-SSO-如何工作"><a href="#0X02-CAS-SSO-如何工作" class="headerlink" title="0X02 CAS-SSO 如何工作"></a>0X02 CAS-SSO 如何工作</h1><p>那么 <a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E4%B8%AD%E5%BC%8F%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1">CAS</a> 又是什么呢？</p>
<blockquote>
<p>集中式认证服务（英语：Central Authentication Service，缩写CAS）是一种针对万维网的单点登录协议。它的目的是允许一个用户访问多个应用程序，而只需向认证服务器提供一次凭证（如用户名和密码）。这样用户不仅不需在登陆web应用程序时重复认证，而且这些应用程序也无法获得密码等敏感信息。“CAS”也指实现了该协议的软件包。     –维基百科</p>
</blockquote>
<p>也就是说，CAS 是 SSO 的一种实现方式。它的工作流程是这样的：</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200704145125.jpeg" alt="CAS"></p>
<ol>
<li>用户访问站点 A</li>
<li>网站 A 将请求重定向 CAS 服务器</li>
<li>用户在 CAS 处输入用户名密码，提交</li>
<li>CAS 认证通过，给用户发一个 token，并重定向回站点 A</li>
<li>用户将 CAS 给的 token 带到站点 A</li>
<li>站点 A 将 token 拿去 CAS 服务器核查（因为 站点 A 现在不知道用户是谁，自己也识别不了 token）</li>
<li>CAS 服务器核查通过，并将用户 A 的信息返回给站点 A（这时候站点 A 知道用户是谁了）</li>
<li>登录成功，可以正常使用 token 访问站点了</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> SSO </tag>
            
            <tag> CAS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么 Django 需要uWSGI]]></title>
      <url>/2020/06/30/why-django-need-uwsgi/</url>
      <content type="html"><![CDATA[<h1 id="0X00-运行一个-Django-程序"><a href="#0X00-运行一个-Django-程序" class="headerlink" title="0X00 运行一个 Django 程序"></a>0X00 运行一个 Django 程序</h1><p>运行一个 Django 程序可太简单了，从创建项目到运行起来总共也不超过 5 行代码。项目运行起来了就可以打开我们的 vim 或者 IDE 之类的一顿 coding 了。作为最最最开始写 Django 的同学来说到这里也就了解的差不多了，因为大家都是自己写好代码本地测试一下就提 Pul Request 到上游仓库了，然后什么单元测试、数据库迁移、测试环境版本发布甚至可能包含 docker 镜像更新就全都交给 CI 来做了。自己就这么开开心心的写了一段时间的代码，一切都在朝着好的方向发展。突然有一天部门主管或者老大告诉你有一个新项目要你来开个头，先搭好脚手架然后发布上去，后面再来人一起做功能迭代。<br><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200630214416.png" alt="运行一个 Django 程序"></p>
<p>然后你开开心心地<code>django-admin startproject xxxx</code>、开开心心地<code>django-admin startapp xxxxx</code>，一顿 coding 之后懵逼了，没有部署过测试环境，没有部署过生产环境，只知道 CI 给做了，却完全不知道做了什么。然后你跑去看 CI 脚本，去问其他同事同学，得到了一堆 Nginx 和 uWSGI 之类的答复。你也照着做了，但是完全不知道为什么，因为你觉得<code>python manage.py runserver</code>明明就可以启动项目了，为什么还需要搞什么 Nginx 和 uWSGI 呢？</p>
<a id="more"></a>

<h1 id="0X01-部署到生产环境"><a href="#0X01-部署到生产环境" class="headerlink" title="0X01 部署到生产环境"></a>0X01 部署到生产环境</h1><p>按我现在手上的项目来说，部署阶段用到了：docker、uWSGI、supervisor、Nginx、fabric、gitlab-ci 这 5 种技术。其中 docker 是为了方便大家的生产环境、测试环境和开发环境高度一致的；uWSGI 和 Nginx 后面单独说；supervisor 是用来保活的，有时候进程挂了需要有人来重启它；fabric 是用来将常用的命令组整合的；gitlab-ci 是用来方便运行单元测试、测试环境发布和生产环境发布的。<br><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200630221308.png" alt="简单部署 Django 程序"></p>
<p>下面就重点来解答一下这个新手群体中很容易出现的疑问：</p>
<blockquote>
<p>为什么明明<code>python manage.py runserver</code>就能运行的 Django 项目非要用 Nginx 和 uWSGI 运行呢？</p>
</blockquote>
<h1 id="0X02-为什么需要-uWSGI"><a href="#0X02-为什么需要-uWSGI" class="headerlink" title="0X02 为什么需要 uWSGI"></a>0X02 为什么需要 uWSGI</h1><p>具体为什么要用 uWSGI 其实偶遇好多个原因，下面会逐个提到。</p>
<p>首先最常见的一种说法是：“<code>python manage.py runserver</code>是单线程的，一个请求不结束其他的请求就得阻塞，所以性能差”，这种说法彻头彻尾是错误的。而且验证起来也及其容易，随便找一个你的 Django 项目然后找个 api 用 ipdb 打个断点，通过 runserver 把它跑起来。然后先调用打了断点的 api，发现它卡在断点处了，然后再调另一个 api，实际上是可以得到 response 的，所以并不是所谓单线程导致的。与其说是因为单线程导致性能低下倒不如说是因为“单进程”，众所周知 Python 中有一个 GIL 全局解释锁，这东西的存在导致真正意义上的单进程多线程 Python 程序并不得行，所以 uWSGI 可以通过启动多个进程的方式来规避这个问题，也就是下面这个配置文件中<code>processes = 8</code>的部分。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">chdir</span>     = /code</span><br><span class="line"><span class="attr">pp</span>        = /code</span><br><span class="line"><span class="attr">module</span>    = ratel.wsgi</span><br><span class="line"><span class="attr">master</span>    = <span class="literal">true</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">8</span></span><br><span class="line"><span class="attr">vacuum</span>    = <span class="literal">true</span></span><br><span class="line"><span class="attr">http</span>      = <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">7701</span></span><br><span class="line"><span class="attr">stats</span> = /tmp/xxxxx_stats.socket</span><br><span class="line"></span><br><span class="line"><span class="attr">env</span> = LANG=en_US.utf8</span><br><span class="line"><span class="attr">env</span> = DJANGO_SETTINGS_MODULE=xxxxx.settings</span><br><span class="line"></span><br><span class="line"><span class="attr">harakiri</span>  = <span class="number">60</span></span><br><span class="line"><span class="attr">http-timeout</span>   = <span class="number">60</span></span><br><span class="line"><span class="attr">socket-timeout</span> = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="attr">max-requests</span> = <span class="number">8192</span></span><br><span class="line"><span class="attr">listen</span>       = <span class="number">8192</span></span><br><span class="line">no-orphans</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里说到多进程，有个题外话可以说一下：“你觉得 Django 中使用全局变量有什么需要注意的吗？”。通常情况来说编程中使用全局变量是一个很常见的问题，但是在多进程的情况下就需要多多注意了。比如按上面的配置，一个项目用了 8 个进程，其中一个进程接到了一个 request 并且把<code>CURRENT_COUNT</code>从 80 改到了 100，但是其他进程在访问自己进程里的<code>CURRENT_COUNT</code>的时候还是 80，这就是因为多个进程中全局变量不够“全局”导致的问题。那么怎么解呢？其实也简单。我们还是用<code>CURRENT_COUNT</code>，但是不用它做变量名了，而是 MySQL 的配置表中的一条数据，或者 Redis 中的 key 就能解决这个问题了。</p>
</blockquote>
<p>性能问题当然是个大问题，不用 runserver 而是改用 uWSGI 的一大原因就是性能问题，我们用 <code>ab</code> 来测试一下 runserver 和 uWSGI 两种方式启动项目的性能差距，<code>ab -n 1000 -c 100 -p data -T application/json http://127.0.0.1:7070/remit_verify/fetch_order/</code>意思为总共 1000 次请求，并发 100，访问后面的登陆接口。首先看一下使用 runserver 方式运行的 Django 成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   53.702 seconds</span><br><span class="line">Complete requests:      1000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Non-2xx responses:      1000</span><br><span class="line">Total transferred:      269000 bytes</span><br><span class="line">Total body sent:        167000</span><br><span class="line">HTML transferred:       63000 bytes</span><br><span class="line">Requests per second:    18.62 [#&#x2F;sec] (mean)</span><br><span class="line">Time per request:       5370.198 [ms] (mean)</span><br><span class="line">Time per request:       53.702 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          4.89 [Kbytes&#x2F;sec] received</span><br><span class="line">                        3.04 kb&#x2F;s sent</span><br><span class="line">                        7.93 kb&#x2F;s total</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+&#x2F;-sd] median   max</span><br><span class="line">Connect:        0    0   0.6      0       3</span><br><span class="line">Processing:    18 1574 6329.8    113   53693</span><br><span class="line">Waiting:        6 1567 6330.6    107   53691</span><br><span class="line">Total:         18 1575 6330.2    114   53695</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    114</span><br><span class="line">  66%    133</span><br><span class="line">  75%    147</span><br><span class="line">  80%    177</span><br><span class="line">  90%   1543</span><br><span class="line">  95%   7727</span><br><span class="line">  98%  27565</span><br><span class="line">  99%  53662</span><br><span class="line"> 100%  53695 (longest request)</span><br></pre></td></tr></table></figure>

<p>然后再来看一下使用 uWSGI 的成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   2.223 seconds</span><br><span class="line">Complete requests:      1000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Non-2xx responses:      1000</span><br><span class="line">Total transferred:      231000 bytes</span><br><span class="line">Total body sent:        167000</span><br><span class="line">HTML transferred:       63000 bytes</span><br><span class="line">Requests per second:    449.93 [#&#x2F;sec] (mean)</span><br><span class="line">Time per request:       222.258 [ms] (mean)</span><br><span class="line">Time per request:       2.223 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          101.50 [Kbytes&#x2F;sec] received</span><br><span class="line">                        73.38 kb&#x2F;s sent</span><br><span class="line">                        174.87 kb&#x2F;s total</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+&#x2F;-sd] median   max</span><br><span class="line">Connect:        0    0   0.8      0       4</span><br><span class="line">Processing:    10  213  30.9    222     298</span><br><span class="line">Waiting:        6  213  31.0    222     297</span><br><span class="line">Total:         10  214  30.5    222     300</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    222</span><br><span class="line">  66%    225</span><br><span class="line">  75%    226</span><br><span class="line">  80%    227</span><br><span class="line">  90%    229</span><br><span class="line">  95%    231</span><br><span class="line">  98%    250</span><br><span class="line">  99%    274</span><br><span class="line"> 100%    300 (longest request)</span><br></pre></td></tr></table></figure>

<p>其中使用 runserver 方式运行压力测试总共耗时 53.7 秒，uWSGI 耗时 2.2 秒。使用 uWSGI 后吞吐率是 24 倍，用户平均等待时间是 1/24，服务器处理时长也是 1/24 的样子。综合来说在我自己配置情况下得到了答曰 24 倍的性能提升，我这儿还是只有双核双进程的情况，如果我给 docker 配置允许使用所有 12 个逻辑处理器，情况会更显著。</p>
<h1 id="0X03-为什么需要-Nginx"><a href="#0X03-为什么需要-Nginx" class="headerlink" title="0X03 为什么需要 Nginx"></a>0X03 为什么需要 Nginx</h1><p>至于为什么要用 Nginx 就更简单了，有这么几个原因：静态资源、HTTPS、端口、多服务部署。。。。。。</p>
<p>首先是静态资源，web 服务无可避免的会用到静态资源，就算前后端分离得再彻底也不免有一些从后端服务上获取一些静态资源，尤其是用户上传下载的文件。Python 的性能咱们也抖动，如果不需要对文件进行权限限制的话，的确没必要让这些请求再走一遍 Django 了。</p>
<p>然后是 HTTPS，这个东西如果不在 Nginx 或者 Apache 上配置的话，就会很麻烦，没这个必要。</p>
<p>端口问题，有时候我们并不打算让服务暴露的是 80 或者 443，尤其是当服务在容器中的时候，这时候就需要用 Nginx 来做代理转发了。</p>
<p>多服务部署就更是需要 Nginx 了，如果你只有一台服务器但是需要部署四五个 web 服务怎么办？总不能说每个服务暴露不同的端口然后让用户根据不同的端口来决定访问哪个服务吧。所以还是需要用 Nginx 来做，根据不同的域名来控制转发到本地的哪个端口上去。</p>
]]></content>
      
        
        <tags>
            
            <tag> Django </tag>
            
            <tag> uWSGI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django 相对优雅地导出 CSV]]></title>
      <url>/2020/06/28/django-export-csv/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><blockquote>
<p>一见程序员，立刻想到 web 开发，立刻想到后台管理系统，立刻想到数据展示，立刻想到数据筛选筛选，立刻想到数据统计，立刻想到导出 Excel 表格。产品经理的想象惟在这一层能够如此跃进。      –鲁迅：我不是，我没有，别瞎说</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200628225253.jpg" alt="我不是，我没有，别瞎说啊"></p>
<p>虽然上面这种说法有点夸张了，不过确实很多很多很多人在工作中遇到过不止一次的需要在一个 web 系统里添加一个”数据导出”的功能，而且通常都是导出成 csv 这种文件。自然我也遇到了很多很多很多次，也写过那种最蠢的手拼逗号的 csv 导出，还看过别人效果更好代码量更少的版本。也就在此总结一下具体这个 csv 导出该怎么搞才好。</p>
<p>最蠢的方案可能就是我最早实习的时候写出来的那种手拼逗号的方案了，为了大家刚吃的早午晚饭着想，就不给大家看了，省得吐出来浪费粮食。真正用的比较多的是这么两种：一种是传统的拼接二维数组的方式来模拟表格，然后通过 Python 的 csv 库直接导出；另一种是使用 djcsv 来进行导出。下面来简单看一下嘞。</p>
<a id="more"></a>

<h1 id="0X01-原始-csv-导出"><a href="#0X01-原始-csv-导出" class="headerlink" title="0X01 原始 csv 导出"></a>0X01 原始 csv 导出</h1><p>其实简单的导出原始的方法就可以解决问题了，下面只列出重点代码。首先导入 csv 模块；然后打开一个文件用来保存这次导出的内容；接下来按行写入表头；然后循环整个 queryset 构建一行行的数据从而写入；最终导出就成功结束了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;export.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f: <span class="comment"># 打开待用的文件</span></span><br><span class="line">    csv_writer = csv.writer(f)  <span class="comment"># 生成一个 csvwriter</span></span><br><span class="line"></span><br><span class="line">    table_title = [<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>, <span class="string">&#x27;生日&#x27;</span>]  <span class="comment"># 准备表头</span></span><br><span class="line">    csv_writer.write_row(table_title)</span><br><span class="line"></span><br><span class="line">    queryset = Student.objects.all().only(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;birthday&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> student <span class="keyword">in</span> queryset:</span><br><span class="line">        line = [</span><br><span class="line">            student.name,</span><br><span class="line">            student.gender,</span><br><span class="line">            student.birthday.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>),</span><br><span class="line">        ]</span><br><span class="line">        csv_writer.write_row(line)</span><br></pre></td></tr></table></figure>
<p>这样导出来的文件就是我们需要的内容了。我们来看一眼成果（不是诸葛大力，是我们导出来的 csv 文件🤣）： 发现问题了没？我们的性别出现了一丢丢问题，本来是用 M/F 来当做男女来存的（这种情况其实非常多的，比如你的类型可能用了 integer 然后用一个 map 去映射到不同的中文名上去），现在却把数据库中真实的内容导出来了。</p>
<p>| 姓名 | 性别 | 生日 |<br>| —————- |<br>| Kevin Armstrong | F | 1988-01-02 |<br>| Patricia Robinson | F | 1988-01-02 |<br>| Michael Duffy | F | 1988-01-02 |<br>| Kathryn Hodge | M | 1988-01-02 |<br>| Justin Carlson | F | 1988-01-02 |<br>| Larry Jones | F | 1988-01-02 |<br>| Peter Palmer | F | 1988-01-02 |<br>| William Smith | F | 1988-01-02 |<br>| Karen Garcia | M | 1988-01-02 |<br>| Eric Williams | F | 1988-01-02 |<br>| Eduardo Bell | F | 1988-01-02 |<br>| Cynthia Lee | M | 1988-01-02 |<br>| Brandy Hoffman | F | 1988-01-02 |<br>| Emily Jones | F | 1988-01-02 |<br>| Kelly Perry | M | 1988-01-02 |<br>| Jamie Nixon | F | 1988-01-02 |<br>| Jeffrey Vega | F | 1988-01-02 |<br>| John Chen | M | 1988-01-02 |<br>| Laura Stevens | M | 1988-01-02 |<br>| Linda Robinson | M | 1988-01-02 |</p>
<p>如果你说这种问题不大，那现在我们要求加一列 ”是否成年“ ，然后这个是否成年又没有存，只有用生日来计算，那咋搞？可能只有在<code>line = [xxxxx]</code>的地方再加一行<code>&#39;成年&#39; if (datetime.datetime.now() - student.birthday).days / 365 &gt;= 18 else &#39;未成年&#39;</code>才行了。当然这只是理想情况，正常情况下一张业务表可能会有 100 多个字段，导出的时候可能要从这 100 多个字段中选择 80 多个导出来然后还要导出他们外键关联的其他表的数据。这是由上面这种写法就会越来越长，而且尤其是当”不能从数据库中直接取“的数据越来越多的时候就会麻烦了。下面介绍的这种使用 djcsv 导出的方法就很好用了。</p>
<h1 id="0X02-使用-djcsv-导出"><a href="#0X02-使用-djcsv-导出" class="headerlink" title="0X02 使用 djcsv 导出"></a>0X02 使用 djcsv 导出</h1><p>这种方法需要安装一个三方库 djcsv ，顾名思义它就是用来方便 Django 导出 csv 文件的。这坨代码的具体解释就直接写在下面注释里了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> djcsv <span class="keyword">import</span> write_csv</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">export_csv</span>():</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    queryset_values = queryset.values(</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;gender&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;birthday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;teacher__name&#x27;</span>,    <span class="comment"># 跨表也是可以的</span></span><br><span class="line">        <span class="string">&#x27;teacher__gender&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 导出字段表头</span></span><br><span class="line">    field_header_map = &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;birthday&#x27;</span>: <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;teacher__name&#x27;</span>: <span class="string">&#x27;老师姓名&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;teacher__gender&#x27;</span>: <span class="string">&#x27;老师性别&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 格式化数据</span></span><br><span class="line">    gender_dict = dict(Student.GENDER_CHOICES)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Student.GENDER_CHOICES = (</span></span><br><span class="line"><span class="string">        (&#x27;M&#x27;, &#x27;男&#x27;),</span></span><br><span class="line"><span class="string">        (&#x27;F&#x27;, &#x27;女),</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    field_serializer_map = &#123;    <span class="comment"># 折页机就是为什么要叫 serializer 的方法了，因为确实有一个翻译在这儿</span></span><br><span class="line">        <span class="string">&#x27;gender&#x27;</span>: (<span class="keyword">lambda</span> x: gender_dict.get(x, <span class="string">&#x27;其他&#x27;</span>)),</span><br><span class="line">        <span class="string">&#x27;teacher_gender&#x27;</span>: (<span class="keyword">lambda</span> x: gender_dict.get(x, <span class="string">&#x27;其他&#x27;</span>)),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;export.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> csv_file:</span><br><span class="line">        write_csv(</span><br><span class="line">            queryset_values,</span><br><span class="line">            csv_file,</span><br><span class="line">            field_header_map=field_header_map,</span><br><span class="line">            field_serializer_map=field_serializer_map</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Django </tag>
            
            <tag> djcsv </tag>
            
            <tag> export </tag>
            
            <tag> csv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何让 Django API 再快一点 (2)]]></title>
      <url>/2020/06/06/django-fast-2/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><blockquote>
<p>啊，这个破系统怎么这么慢。 -你写的程序的用户</p>
</blockquote>
<p>是的我写过一篇<a href="https://blog.just666.com/2020/05/14/django-fast/">类似的博客</a>，但是一篇肯定说不完，毕竟影响性能的东西太多了：数据量巨大、机器配置差、查询SQL效率低、额外的多余的查询、低质量的代码balabala的。今天这篇文章主要是从Django查询和ORM层面来分析一下API变慢的原因。</p>
<p>其中可能性比较多，我这里先挑几个我经常遇到的情况来说：不管自己的需求直接查询所有字段、完全不在意索引、疯狂使用<code>in</code>、循环创建/更新数据、不善于使用缓存。这几个问题其实都会对我们的API响应速度造成比较大的影响，下面我们来一个个介绍一下。</p>
<a id="more"></a>

<h1 id="0X01-SELECT"><a href="#0X01-SELECT" class="headerlink" title="0X01 SELECT *"></a>0X01 SELECT *</h1><p>首先我们一定知道，从数据库里查询的数据越多那反应也就越慢。我这里拿一个只有500条数据的表来展示一下，这里可以看到两次的耗时虽然都很短（那可不嘛，就500条数据），但是比例上还是差了三倍还多，如果随着数据量变大和字段变多这个差距就会更加明显。但是我们可以看到在循环里只需要<code>name</code>这个字段，多余的是用不到的。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200606154947_mini.png"></p>
<p>实际上这两个查询执行的是不同的两个SQL（当然了这是废话），那具体区别呢？可以看到一个是<code>SELECT *</code> 一个是单独取了两个字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`main_staffprofile`</span>;      <span class="comment">-- 其实并不是一个*，而是把所有字段都列在这儿了，这里方便展示就不都贴出来了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`main_staffprofile`</span>.<span class="string">`id`</span>, <span class="string">`main_staffprofile`</span>.<span class="string">`name`</span> <span class="keyword">FROM</span> <span class="string">`main_staffprofile`</span>;</span><br></pre></td></tr></table></figure>

<p>所以说，当我们确定知道自己下面要用到什么字段的时候，就给<code>queryset</code>加上<code>only(&#39;xxx&#39;, &#39;xxx&#39;, &#39;xxx&#39;)</code>的参数，从数据库里取的时候尽可能少的取数据，这样就能加快查询了。尤其是在查得的数据很大和字段很多的时候，比如在表里取10000条数据但是只用到30列中的3列的时候就非常应该加上<code>only</code>。</p>
<h1 id="0X02-Index-index-together"><a href="#0X02-Index-index-together" class="headerlink" title="0X02 Index/index_together"></a>0X02 Index/index_together</h1><p>好吧，说起优化速度就绕不开索引，这是必然的。我们都知道在数据库里给字段加索引可以大幅提升查询效率，具体在Django里建立普通索引也是很简单的，直接在字段定义里加一个参数<code>index=True</code>就好了。但是可能大家会忽视联合索引的建立，这里简单介绍一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    verbose_name = <span class="string">u&#x27;随便一个什么表&#x27;</span></span><br><span class="line">    verbose_name_plural = verbose_name</span><br><span class="line">    index_together = [</span><br><span class="line">        [<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;address&#x27;</span>],</span><br><span class="line">        [<span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>Django中的每个Model类我们都会创建一个Meta子类，子类里有一个属性叫做<code>index_together</code>顾名思义这就是定义联合索引的地方了。<code>index_together</code>是一个二维数组，第一维度下面的每个item都是一个联合索引，第二个维度下面的每个item就是一个字段，也就是构成联合索引的字段（注意联合索引是讲究顺序的喔）。具体索引和联合索引应该怎么建才会让数据查询更快可以看<a href="https://blog.just666.com/2019/09/15/database-index/">我上一片博客</a>或者搜索其他资料。</p>
<p>注意：索引/联合索引定义好之后需要进行数据库迁移</p>
<h1 id="0X03-IN-balabala"><a href="#0X03-IN-balabala" class="headerlink" title="0X03 IN balabala"></a>0X03 IN balabala</h1><p>我们在Django的查询中无处不见这种<code>User.objects.filter(user_type__in=(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4,&#39;, &#39;5&#39;))</code>的用法，这种用法在业务上确实有需求，所以我们是避免不掉的。不过还是可以通过一些其他的方法来尝试规避，比如从业务上看看这些选项组合到一起的时候是不是意味着一种特殊的数据，比如<code>User.objects.filter(city__in=(&#39;成都&#39;, &#39;绵阳&#39;, &#39;自贡&#39;........))</code>可以发现是在查询四川省，那么可以考虑换成<code>User.objects.filter(province=&#39;四川&#39;&#39;)</code>这种。或者<code>User.objects.filter(level__in=(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;))</code>是不是意味着<code>User.objects.exclude(level=&#39;S&#39;)</code>。</p>
<p>这种情况因为业务上的严格需求，可能并没有太好的调节方法（也可能是我没想到，如果大家有方法的话欢迎反馈给我，谢谢指教🙏），不过遇到了的话还是可以尝试上面两种方案，玩意能行的话还是可以调节一下性能的。</p>
<h1 id="0X04-疯狂关联"><a href="#0X04-疯狂关联" class="headerlink" title="0X04 疯狂关联"></a>0X04 疯狂关联</h1><blockquote>
<p>条条大路通罗马。</p>
</blockquote>
<p>疯狂关联也比较容易出现，正所谓条条大路通罗马，但是总会有一条更近一点的路。比如这种<code>User.objects.filter(father__father__name=&#39;shawn&#39;&#39;)</code>完全就可以用<code>User.objects.filter(grandfather__name=&#39;shawn&#39;&#39;)</code>这种来替代。这个其实大家都会比较清楚，对技术没什么考验，但是比较考验对程序的理解程度尤其是数据库的理解程度。有时候我们接手一个新的项目时候可能并没有对这个项目的数据库有充分的了解，所以可以尝试在写这种多层的关联查询之前取调研一下是不是有更近的通向罗马的路。</p>
<h1 id="0X05-bulk-create"><a href="#0X05-bulk-create" class="headerlink" title="0X05 bulk_create"></a>0X05 bulk_create</h1><p>这种问题应该是最常遇到的了。我们从前端接收到了这么一波数据要写到数据库里（数据哪儿来的并不重要，也可能是csv来的或者其他什么鬼地方）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&#x27;name&#x27;: &#x27;shawn_0&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;shawn_1&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;shawn_2&#x27;&#125;,</span><br><span class="line">...............................</span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;shawn_998&#x27;&#125;,</span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;shawn_999&#x27;&#125;]</span><br></pre></td></tr></table></figure>

<p>新手同学很有可能写出如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</span><br><span class="line">        User.objects.create(**user)</span><br></pre></td></tr></table></figure>

<p>但是我们来看看速度，耗时4秒，再看一下批量创建的时间，耗时0.13秒，性能提升了很多倍。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200606163344_mini.png"></p>
<p>批量创建虽好，但是有一点就需要特别注意：如果你要创建的数据比较复杂并且量非常大，请不要一次性全部创建完成，否则可能会对数据库造成较大的压力，可以尝试将比如10000条数据分成10个1000或者100个100来创建。</p>
<h1 id="0X06-cache-cached-property"><a href="#0X06-cache-cached-property" class="headerlink" title="0X06 cache/cached_property"></a>0X06 cache/cached_property</h1><p>缓存可能是提升性能最明显的方案了，同样数据量的数据从MySQL里取出来和从Redis里取出来，耗时根本不在一个数量级，所以我们应该善用缓存。</p>
<p>比如我们有一个巨大的关键词配置放在数据库里存起来了，大概有10W条数据，平时又很少更新，但是经常会查，那就非常适合使用缓存。我们可以这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_keyword_config</span>():</span></span><br><span class="line">    result = cache.get(KEYWORD_CONFIG_KEY)</span><br><span class="line">    <span class="keyword">if</span> result:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        queryset = Keyword.objects.all()</span><br><span class="line">        result = handle_keywords(queryset)</span><br><span class="line">        cache.set(KEYWORD_CONFIG_KEY, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>然后在更新关键词库的时候再同时刷新一次缓存就好了。另一种使用缓存的方式是Django中带的<code>cached_property</code>。我们知道Django中有一个<code>property</code>可以把function作为属性来用，直接通过点就能获取值，这个顾名思义就是加了缓存的<code>property</code>。也就是说每次调用<code>student_count</code>的时候都要计算一遍，但是调用<code>cached_student_count</code>的时候只有第一次会计算，后面就是缓存的值了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">        xxxxxx</span><br><span class="line"></span><br><span class="line"><span class="meta">        @property</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">student_count</span>(<span class="params">self</span>):</span></span><br><span class="line">                <span class="keyword">return</span> self.student_set.all().count()</span><br><span class="line"></span><br><span class="line"><span class="meta">        @cached_property</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cached_student_count</span>(<span class="params">self</span>):</span></span><br><span class="line">                <span class="keyword">return</span>  self.student_set.all().count()</span><br></pre></td></tr></table></figure>

<p>下面是官方文档关于<code>cached_property</code>的解释，简单明了： <strong>注意里面提到的生命周期，小心用到已经失效的数据</strong></p>
<blockquote>
<p>将一个类方法转换为特征属性，一次性计算该特征属性的值，然后将其缓存为实例生命周期内的普通属性。 类似于 property() 但增加了缓存功能。 对于在其他情况下实际不可变的高计算资源消耗的实例特征属性来说该函数非常有用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sequence_of_numbers</span>):</span></span><br><span class="line">        self._data = sequence_of_numbers</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cached_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stdev</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> statistics.stdev(self._data)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cached_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">variance</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> statistics.variance(self._data)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Index </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中的filter与map/reduce方法]]></title>
      <url>/2020/05/25/python-filter-map-reduce/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言-amp-Pythonic"><a href="#0X00-前言-amp-Pythonic" class="headerlink" title="0X00 前言 &amp; Pythonic"></a>0X00 前言 &amp; Pythonic</h1><p>Python管<code>filter/map/reduce</code>这些叫高阶函数，听起来有点高级有点难搞的意思，实际上是贼简单的东西。下面通过几个简单的例子来帮助大家了解一下<code>filter/map/reduce</code>这三个高阶函数的简单用法。</p>
<p>事先声明，这三个函数都是扩展性质的东西，从来不用这三个函数也可以正常的编写程序，没有什么功能是没了这三个函数就写不出来的。只不过是这三个函数的出现能让之前很丑陋的代码变得精简易读了而已。</p>
<p>这三个函数非常适合搭配<code>lambda</code>来使用，编写非常Pythonic的代码，具体什么是Pythonic其实很难定义，其实就是把Python编程一个形容词了，比如你看到一个人“穿了运动鞋牛仔裤帽衫双肩包黑框眼镜电子表”就会说他“太程序员了”，大概就是这么个意思。总结来说呢就是 <strong>非常具有Python特色的Python代码</strong>。比如下面这段代码明显就不Pythonic</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(name_list)):</span><br><span class="line">    print(name_list[index])</span><br></pre></td></tr></table></figure>



<p>而这种代码就是Pythonic的写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure>



<p>尤其是结合了<code>lambda</code>之后，就能写出更Pythonic的代码了，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_boy</span>(<span class="params">student</span>):</span></span><br><span class="line">    <span class="keyword">if</span> student.gender == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>就可以直接用<code>lambda</code>改写成这个样子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is_boy = <span class="keyword">lambda</span> studnet: student.gender == <span class="string">&#x27;M&#x27;</span></span><br></pre></td></tr></table></figure>



<a id="more"></a>

<h1 id="0X01-filter"><a href="#0X01-filter" class="headerlink" title="0X01 filter"></a>0X01 filter</h1><p><code>filter</code>顾名思义，一定是一个筛选器。当我们有一个列表想要找出这个列表中满足某些条件的数据，在不是用<code>filter</code>的情况下很有可能会写出这样的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">number_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span>(<span class="params">input_number</span>):</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;不考虑0的问题，我们现在是研究filter&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> input_number % <span class="number">2</span></span><br><span class="line"></span><br><span class="line">odd_list = []</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> number_list:</span><br><span class="line">    <span class="keyword">if</span> is_odd(number):	<span class="comment"># 把奇数怼到新列表里</span></span><br><span class="line">        odd_list.append(number)</span><br><span class="line"></span><br><span class="line">print(odd_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>但是借助<code>filter</code>就可以将新列表的生成变得很简单，本质上只要了一行代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">odd_list = filter(is_odd, number_list)</span><br><span class="line"></span><br><span class="line">print(list(odd_list))</span><br></pre></td></tr></table></figure>



<p><code>filter</code>接受两个参数，第一个参数是个只接受一个参数的<code>function</code>，第二个参数是个列表。工作原理就是将列表中的对象一个个塞到第一个参数的<code>function</code>中取得返回值，将返回值为<code>True</code>的保存到新列表中，最终返回。</p>
<blockquote>
<p>  Python2中<code>filter</code>返回的直接是列表，而Python3中返回的则是可迭代对象。</p>
</blockquote>
<h1 id="0X02-map"><a href="#0X02-map" class="headerlink" title="0X02 map"></a>0X02 map</h1><p><code>map</code>可以用来批量处理数据，批量传参。<code>map</code>接受不定长度的参数，其中第一个参数固定为一个“接受n个参数”的function，然后后面紧跟真就是n个可迭代的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受n个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join_name</span>(<span class="params">first_name, middle_name, last_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;拼接三个字符串&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;_&#123;&#125;_&#123;&#125;&#x27;</span>.format(first_name, middle_name, last_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    first_name_list = [<span class="string">&#x27;zhang&#x27;</span>, <span class="string">&#x27;li&#x27;</span>, <span class="string">&#x27;wang&#x27;</span>, <span class="string">&#x27;zhao&#x27;</span>]</span><br><span class="line">    middle_name_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">    last_name_list = [<span class="string">&#x27;san&#x27;</span>, <span class="string">&#x27;si&#x27;</span>, <span class="string">&#x27;wu&#x27;</span>, <span class="string">&#x27;liu&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法1，使用map传递n+1个参数，第一个是function对象，后面的是参数列表</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> map(join_name, first_name_list, middle_name_list, last_name_list):</span><br><span class="line">        print(result)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 方法2，不使用map，相当于下面这种</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(first_name_list)):</span><br><span class="line">        result = join_name(first_name_list[index], middle_name_list[index], last_name_list[index])</span><br><span class="line">        print(result)</span><br></pre></td></tr></table></figure>

<p>输出的内容都是这个样子的：</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200525234648.png"></p>
<p>使用了<code>map</code>之后不仅在for那里不用非常蠢得用<code>range(len(first_name_list))</code>了，也不用拿到下标之后到处跑着用下标取值了。而且有一个很大的优点是：<code>map</code>自动使用多个参数列表中最短的那个，也就是说不会出现<code>IndexError: list index out of range</code>的数组越界问题了。</p>
<h1 id="0X03-reduce"><a href="#0X03-reduce" class="headerlink" title="0X03 reduce"></a>0X03 reduce</h1><p><code>reduce</code>方法从Python 3开始就不是全局命名空间里的function了（说人话就是挪到官方包里去了，需要导入，不能直接用了），所以我们需要<code>from functools import reduce</code>才能用到。<code>reduce</code>相对更简单一些，固定接受两个参数，第一个参数是一个“固定接受两个参数的”function，第二个参数是一个可迭代对象。具体用法可以看示例，非常通俗易懂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join_chars</span>(<span class="params">char_a, char_b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;拼接两个字符串, reduce的第一个参数只能是一个接受两个参数的function&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> char_a + char_b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    char_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]</span><br><span class="line">    print(reduce(join_chars, char_list))	<span class="comment"># 使用reduce</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 其实这个reduce就类似于下面这种写法</span></span><br><span class="line">    res = join_chars(char_list[<span class="number">0</span>], char_list[<span class="number">1</span>])</span><br><span class="line">    res = join_chars(res, char_list[<span class="number">2</span>])</span><br><span class="line">    res = join_chars(res, char_list[<span class="number">3</span>])</span><br><span class="line">    res = join_chars(res, char_list[<span class="number">4</span>])</span><br><span class="line">    res = join_chars(res, char_list[<span class="number">5</span>])</span><br><span class="line">    res = join_chars(res, char_list[<span class="number">6</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 或者类似这种</span></span><br><span class="line">    res = join_chars(</span><br><span class="line">        join_chars(</span><br><span class="line">            join_chars(</span><br><span class="line">                join_chars(</span><br><span class="line">                    char_list[<span class="number">0</span>],</span><br><span class="line">                    char_list[<span class="number">1</span>]</span><br><span class="line">                ),</span><br><span class="line">                char_list[<span class="number">2</span>]</span><br><span class="line">            ),</span><br><span class="line">            char_list[<span class="number">3</span>]</span><br><span class="line">        ),</span><br><span class="line">        char_list[<span class="number">4</span>]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="0X04-结合lambda"><a href="#0X04-结合lambda" class="headerlink" title="0X04 结合lambda"></a>0X04 结合lambda</h1><p>结合<code>lambda</code>之后可以将上面的<code>is_odd</code>改写成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line">number_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">odd_list = filter(<span class="keyword">lambda</span> number: number % <span class="number">2</span>, number_list)</span><br><span class="line"></span><br><span class="line">print(list(odd_list))</span><br></pre></td></tr></table></figure>

<p>可以将上面<code>map</code>中的代码改写成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    first_name_list = [<span class="string">&#x27;zhang&#x27;</span>, <span class="string">&#x27;li&#x27;</span>, <span class="string">&#x27;wang&#x27;</span>, <span class="string">&#x27;zhao&#x27;</span>]</span><br><span class="line">    middle_name_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">    last_name_list = [<span class="string">&#x27;san&#x27;</span>, <span class="string">&#x27;si&#x27;</span>, <span class="string">&#x27;wu&#x27;</span>, <span class="string">&#x27;liu&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方法1，使用map传递n+1个参数，第一个是function对象，后面的是参数列表</span></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> map(</span><br><span class="line">        <span class="keyword">lambda</span> a, b, c: <span class="string">&#x27;&#123;&#125;_&#123;&#125;_&#123;&#125;&#x27;</span>.format(a, b, c), first_name_list, middle_name_list, last_name_list</span><br><span class="line">    ):</span><br><span class="line">        print(result)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<p>可以将上面<code>reduce</code>中的代码改成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    char_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>]</span><br><span class="line">    print(reduce(<span class="keyword">lambda</span> a, b: a + b, char_list))</span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> filter </tag>
            
            <tag> map </tag>
            
            <tag> reduce </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自控&目标]]></title>
      <url>/2020/05/14/self-control-and-target/</url>
      <content type="html"><![CDATA[<h1 id="0X00-GTD"><a href="#0X00-GTD" class="headerlink" title="0X00 GTD"></a>0X00 GTD</h1><blockquote>
<p>   <strong>尽管去做</strong>（英语：<strong>Getting Things Done</strong> / <strong>GTD</strong>），是一种行为管理的方法，也是<a href="https://zh.wikipedia.org/w/index.php?title=%E6%88%B4%E7%BB%B4%C2%B7%E8%89%BE%E4%BC%A6&action=edit&redlink=1">戴维·艾伦</a>写的一本书的书名。</p>
<p>  GTD的主要原则在于一个人需要通过记录的方式把头脑中的各种任务移出来。通过这样的方式，头脑可以不用塞满各种需要完成的事情，而集中精力在正在完成的事情。</p>
<p>  ​                                                                                                     –维基百科</p>
</blockquote>
<p>GTD说白了就是把自己要做的事项从脑子里拿出来，写到纸上或者记到什么鬼地方，我最喜欢的就是”滴答清单”了。</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200514225226_mini.png"></p>
<p>最早的时候我用的是Google日历，在学校里的时候这样用了一两年还不错。后来大四出来实习，那段时间工作哪儿哪儿都不顺利，也就没心情安排自己的生活和学习了，所以实习的那一年基本就是下班了就趴在床上玩手机，什么都没干成。不只是没学习，而是没玩游戏没看电影，实打实的什么都没干成。后面又重拾了GTD，把自己安排的明明白白的，对我来说效果还是立竿见影的。我安排自己不只是学习，也包括社交和娱乐，约好什么时间和谁在哪儿吃饭或者干嘛的；自己给自己规定什么时间玩游戏，给自己规定什么时间看电影。</p>
<p>这样一套流程下来，有两个明显的好处：自己的时间利用率极大的提升了，不会出现坐在桌子前面考虑接下来要干什么的事情；另一个就是方便自己回顾生活，毕竟不写日记的话自己也搞不清楚哪天哪天干了什么事儿了。这里给大家看一下我滴答清单里的任务分类：</p>
<p><img src="https://raw.githubusercontent.com/shawn-bluce/pics_home/master/20200514230004_mini.png"></p>
<p>这里主要是学习类、个人日常生活类、工作和年度规划。除了每年年底会对新一年进行规划以外，还会在每个月对下个月进行规划。不过正所谓”取法其上，仅得其中；取法其中，仅得其下”，所以也不要因为自己没有完成月内所有计划或者年度计划而自我否定，只要在没有突发事件的情况下都按部就班完成了自己的任务安排，那损失的那一点点跟全局比起来都是小问题了。</p>
<p>安排时间的时候有个问题需要注意：给自己一定的缓冲时间，比如整整一周不要尝试将周一至周五的晚上都安排上学习，然后周六周日又安排三四部电影和游戏时间。因为很大可能你周五晚上下班是要跟朋友约出去吃吃喝喝的，很大可能周末会被叫出去玩或者自己睡过了之类的。而且即使没有这些外在因素，也不应该给自己安排的满满当当的。我自己的建议是这样：周一到周四的晚上安排三次学习，空出来一天用来缓冲；周五晚上不安排，即使没有约也可以自己给自己放个假；周六周日给自己安排一天半的时间，而且然后周六晚上不安排学习，可以的话给周日晚上安排一波学习。</p>
<p>仅从我自己的角度来说，这类GTD方案让我非常受用，不仅时间变多了，也更有节奏了。自己知道周一到周四晚上不该玩游戏，周末又可以玩一整天。时间拍起来之后的生活里我玩到了很多以前觉得没时间玩的优秀游戏，比如<em>战神</em> <em>塞尔达</em>  <em>GTA5</em>  <em>和一众优秀游戏</em>，也看了很多以前觉得没时间看的豆瓣Top250电影。</p>
<a id="more"></a>

<h1 id="0X01-卸载"><a href="#0X01-卸载" class="headerlink" title="0X01 卸载"></a>0X01 卸载</h1><p>我不知道其他人，反正我自己入手一个新的电子产品尤其是：手机、平板、电脑的时候，就会疯狂的配置，然后疯狂安装软件，一度觉得不多装几个软件新电脑、手机就白买了似的。这里给出的方案恰恰与之相反：<strong>卸载</strong>。</p>
<p>针对电脑来说，这个其实没所谓，主要还是在手机和平板上。假设你想控制自己少玩手机少玩平板，其实很简单呐，平时玩什么就卸载什么就得了。我本来就对手机游戏没有兴趣，但是以前手机上有的时候偶尔还是会玩一玩，现在直接卸载掉就不玩了，也完全不想玩。</p>
<p>最应该卸载的其实是手机里的那些”社区”，如果你有一两个自己特别喜欢的社区，不管是知乎还是豆瓣，那都应该留着。不过如果你手机里装了一大堆社区类的app，那完全可以考虑卸载一波，这样就省的让你拿起手机一顿看之后单纯的因为无聊而点开一个app。当然了，卸载是一个非常极端的做法，还有不那么极端的做饭：修改通知&amp;推送。</p>
<h1 id="0X02-通知-amp-推送"><a href="#0X02-通知-amp-推送" class="headerlink" title="0X02 通知&amp;推送"></a>0X02 通知&amp;推送</h1><p>现在拿起来你的手机，看一看有多少未读的推送和通知呢？再想想你有多少次是正在开心的学习、玩游戏、看电影的时候听到了手机”叮咚”一声推送，然后拿起来看了看，关掉了无关的推送，然后又点开了微博知乎吧啦吧啦？</p>
<p>所以说如果做不到卸载，那就关掉他的推送。其实你仔细想想，你很需要微博给你推送那些乱七八糟的流量明星出轨恋爱多人运动的消息吗？你很需要知乎给你推送的人在内蒙刚下航母吗？你很需要bilibili给你推送的黑人抬棺交响乐版吗？其实并不，反而是他们给你推送之后你可能会因为好奇点开，就算没点开也有可能会点开其他的app然后中断自己正在做的事儿。</p>
<p>所以现在我手机上除了微信、QQ这类工具以外，大多数程序的推送我都关掉了，因为我并不是很关心他们的推送，反而这些推送会严重干扰到我。当然如果你实在不想关掉推送，那也可以把推送的声音和”通知亮屏”这种关掉，防止你专心工作学习玩游戏的时候被手机中断。</p>
<h1 id="0X03-设备独立"><a href="#0X03-设备独立" class="headerlink" title="0X03 设备独立"></a>0X03 设备独立</h1><p>设备独立就很简单了，试想你正在用手机看一篇技术文章或者一篇其他的长文，看了三分钟就收到了朋友在微信群里at你给你看沙雕视频的通知，你坚持住没点；五分钟后又收到同事发给你的”王者峡谷邀请函”，你又坚持住了；十几分钟后又收到了UC推来的”震惊🤯七旬老人竟和孙子在家中做这种事情！”，好吧，这次你可能没坚持住，点进去了。这样算下来你一共看了半个小时文章，中间被打断了好几次。</p>
<p>如果你用Kindle看书，或者干脆拿纸质书，那肯定就不会出现这种问题了。如果你用walkman听歌，那就不会出现手动切歌的时候顺便刷上半个小时微博的问题。如果你用switch/PS4/XBox玩游戏就不会遇到游戏中被一个突如其来的系统更新打断或者被视频聊天打断的问题。</p>
<p>所以说在可以的情况下，尽可能让自己的设备独立，每个设备做每个设备最擅长的事情，这样也最不容易被打断。（每个工具只做一件事，并将其做到极致。  其实这也是经典的UNIX思想）</p>
<h1 id="0X04-锁定"><a href="#0X04-锁定" class="headerlink" title="0X04 锁定"></a>0X04 锁定</h1><p>我之前的一加手机有”禅定模式”，现在的小米手机有”专注模式”，这个功能很棒。手机打开禅定模式前会让你选择时间，比如30分钟、60分钟、90分钟这种。选好之后就开始进入禅定模式了，禅定模式期间手机只能看时间、接电话和拨打紧急电话，其他一切的通知、推送、短信、at、全都没了。这种情况下你的工作学习效率会高很多，起码不会被手机打扰到。</p>
<p>在iPad上也有类似的，叫”勿扰模式”，macOS和Windows上也有，连Linux上都有。虽然功能没有手机那么夸张，但是也会帮你拦截绝大多数通知，然后让你自己沉浸到当前的工作和学习当中去。强烈推荐在电脑上使用勿扰模式的时候将当前窗口全屏，这样就可以将干扰放到最低。</p>
<h1 id="0X05-立flag"><a href="#0X05-立flag" class="headerlink" title="0X05 立flag"></a>0X05 立flag</h1><p>立flag是个好办法，把自己的计划疯狂得说出来。比如你打算一年减肥20斤，那就告诉全世界，虽然你谁都不告诉自己悄悄减失败了也不丢脸，但是也会给自己埋下一个说辞”不成功也没人知道的，问题奀”。所以应该大胆的告诉周围人你的计划（当然了，私密的问题就别说了，别老说争取下次争取涨个 xx%  的工资这种）。当所有人都知道你要减肥20斤的时候，下次你再跟他们吃饭还吃那么多，你的朋友就会时不时提醒你甚至”嘲讽”你，给你一些动力。而且你自己也会给自己心理暗示：”NB都吹出去了，不能一点动静都没有吧，还是得努努力才行”。</p>
<p>我自己也是在朋友圈里立过flag的，说什么”完成不了就请朋友圈全圈吃火锅”这种听起来就不靠谱的话。大家也都知道是在开玩笑，但是遇到你做了和计划相反的事儿还是会提醒你的。虽然我最后没有彻底完成，也没有请全圈吃火锅。估计真请的话怕是两个月工资都不够🤣</p>
<h1 id="0X06-最后"><a href="#0X06-最后" class="headerlink" title="0X06 最后"></a>0X06 最后</h1><p>最后简单总结一下，这些技巧也好方法也罢都是我自己总结到的，对我自己是很有用的，但是不确定对大家是不是有用。如果有兴趣的话也可以试一下，毕竟大家都是沙雕网友，受用的方法应该也不会差太多吧哈哈哈哈哈🤪</p>
]]></content>
      
        
        <tags>
            
            <tag> GTD </tag>
            
            <tag> Target </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何让Django API再快一点]]></title>
      <url>/2020/05/14/django-fast/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><blockquote>
<p>  啊，这个破系统怎么这么慢。  –你写的程序的用户</p>
</blockquote>
<p>是的，我用Django写的程序经常会出现性能问题，有时候是逻辑问题、有时候是数据库问题、有时候又是机器问题。我就现在这儿总结一波我自己的经验好了（这里都是基于我自己的经验来的，可能会相对比较简单，没有太骚太复杂太高级的东西）。这儿默认大家都是用的Django + Django REST framework了，因为我自己是用的这套技术栈，而且这套技术栈也算是Django生态下前后端分离的最常见的了。</p>
<h1 id="0X01-问题出在哪儿呢"><a href="#0X01-问题出在哪儿呢" class="headerlink" title="0X01 问题出在哪儿呢"></a>0X01 问题出在哪儿呢</h1><p>众所周知”想要解决问题，首先就要找到问题在哪儿”。那怎么判断问题在哪儿呢？</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ger78bhmijj32qg07s7b9.jpg" alt="htop截图"></p>
<ol>
<li>首先登到服务器上看<code>htop</code>，有面有一个<code>Load average</code>就是综合负载。一般来说，如果你的服务器是n核心的，那负载在n-2以下就算是正常的，快到n了也不是不能用，但是就要考虑升级了。这里给出来了三个负载值，从左到右依次是1分钟、5分钟、10分钟的负载情况。（为什么说是一般情况呢，如果你就只有一两个核心，那这个算法肯定不生效；如果你有128核，那负载到126了就意味着马上就炸🤣。所以说一半双核心不超过1.5、4核不超过3，8核不超过6这种）</li>
<li>如果确定了就是机器性能的问题，那就好办了，升级服务器就好（当然不是不够久升级，还是要觉得当前的数据量啊并发啊已经挺高了再考虑。要不然一慢就升级服务器，那岂不是太奢侈了，而且对自己的代码质量也没有一点好处）</li>
<li>我们假设不需要升级服务器配置，那就从程序和数据库两个方面来说。一般是先打开MySQL的慢查询日志，然后根据慢查询日志来逐渐优化表结构，优化查询，优化程序逻辑。</li>
</ol>
<a id="more"></a>

<h1 id="0X02-代码质量低or逻辑问题"><a href="#0X02-代码质量低or逻辑问题" class="headerlink" title="0X02 代码质量低or逻辑问题"></a>0X02 代码质量低or逻辑问题</h1><p>代码质量低是个问题，一般来说呈现在这几个地方：多余的循环次数、查了完全没卵用的数据、进行额外的操作。我们都知道计算机里几种处理速度的差距是巨大的<code>CPU缓存&gt;&gt;内存&gt;&gt;硬盘&gt;&gt;网络</code>，这四个之间的性能差异两两之间往往可以差出至少一个数量级（其实随着网络发展，现在网络速度已经可以赶上机械硬盘了）。而其中最慢的就是I/O了，所以我们应该尽一切可能避免I/O，而且有一点要注意的是”读写数据库”当然也算I/O。下面列举两种常见的问题</p>
<h2 id="多余的I-O"><a href="#多余的I-O" class="headerlink" title="多余的I/O"></a>多余的I/O</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> student_data <span class="keyword">in</span> studnet_list:</span><br><span class="line">    token = get_token_from_another_system_with_http_api()</span><br><span class="line">    response = requests.post(url, student_data, headers=&#123;<span class="string">&#x27;token&#x27;</span>: token&#125;)</span><br></pre></td></tr></table></figure>

<p>比如说这部分代码，我们都知道一个token不应该是一次性的，那把这个多余的取token的方法放在循环外面就好了。其实如果<code>get_token_from_another_system_with_http_api()</code>不是从其他的web服务上取token而是<code>get_token_from_local_cache()</code>的话，虽然也还是执行了多余的操作，但是就好得多了。</p>
<h2 id="查了完全没卵用的东西"><a href="#查了完全没卵用的东西" class="headerlink" title="查了完全没卵用的东西"></a>查了完全没卵用的东西</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queryset = Student.objects.filter(age__gte=<span class="number">20</span>, gender=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> queryset:</span><br><span class="line">    send_mail(studnet.email, <span class="string">&#x27;一个标题&#x27;</span>, <span class="string">&#x27;hello,world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这部分代码看起来问题不大，但是假设我们有10W的学生，并且<code>Student</code>表有大几十个字段，那到<code>for student in queryset</code>的时候，就会卡住一会儿（如果机器不太行的话可能会卡很久）。其实我们知道，默认这样的查询是<code>SELECT * FROM student WHERE xxxx</code>来的，把所有数据都取出来了。如果我们稍加改动</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queryset = Student.objects.filter(age__gte=<span class="number">20</span>, gender=<span class="string">&#x27;F&#x27;</span>).only(<span class="string">&#x27;email&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> queryset:</span><br><span class="line">    send_mail(studnet.email, <span class="string">&#x27;一个标题&#x27;</span>, <span class="string">&#x27;hello,world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>仔细看，其实就只是在<code>filter()</code>后面加了<code>only(&#39;email&#39;)</code>，这就相当于是<code>SELECT email FROM student WHERE xxxxx</code>了，效率明显高了好多。或者直接改成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">email_list = Student.objects.filter(age__gte=<span class="number">20</span>, gender=<span class="string">&#x27;F&#x27;</span>).values_list(<span class="string">&#x27;email&#x27;</span>, flat=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> email <span class="keyword">in</span> email_list:</span><br><span class="line">    send_mail(email, <span class="string">&#x27;一个标题&#x27;</span>, <span class="string">&#x27;hello,world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这样返回来的<code>queryset</code>里的元素就是email了。</p>
<h1 id="0X03-数据库瓶颈（MySQL）"><a href="#0X03-数据库瓶颈（MySQL）" class="headerlink" title="0X03 数据库瓶颈（MySQL）"></a>0X03 数据库瓶颈（MySQL）</h1><p><strong>数据库一定要多占内存，数据库一定要多占内存，数据库一定要多占内存。</strong>一般来说，在Linux系统下是用多少内存分配多少，但是我们MySQL通常都是独立部署的，有且只有一个MySQL，所以就直接一次性给MySQL分配够内存，这是最好的方法。记得内存就是买来用的，买内存回来结果一年到头都是30%的占用，那岂不是亏了吗哈哈哈哈哈🤓</p>
<p><strong>数据库机器不要开swap，数据库机器不要开swap，数据库机器不要开swap</strong>。数据库的机器内存不够了，就加内存或者优化查询，万万不可使用交换分区。只要你的数据库机器一开swap分区，再结合上面的原则，就意味着<strong>瞬间爆炸</strong>。因为内存一直都是几乎占满的情况，你一打开交换分区，Linux就会疯狂开始用内存和硬盘进行交换，本来你MySQL里有很多东西放内存里就是图个快的，结果又给在swap的机制下放回磁盘了，再折腾一圈下来甚至比直接在磁盘里还要慢。</p>
<h2 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h2><p>因为把优化查询改成了优化<code>ORM</code>，所以也就理所当然放到上一个段落里了，那这里就只剩下索引为题了。索引简单来说就是：”针对某些字段，牺牲内存和写入速度换取查询速度”。所以说如果有些字段你很少改，甚至写进去就不会再变了，然后又要疯狂的以它为条件查询，那就给他加个索引。不过加索引之前有几个注意的点：</p>
<ol>
<li>这个字段一定是读取频率远高于写入频率的；</li>
<li>这个字段的”唯一性”要高，比如学生表的身份证号这种，每条数据都有不同的身份证号；</li>
<li>这个字段要在SQL中的<code>WHERE</code>子句后面，而不是<code>SELECT</code>后面。也就是说：应该是条件，而非需要得到的数据；</li>
</ol>
<p>具体的可以看我的[另一篇博客]](<a href="https://blog.just666.com/2019/09/15/database-index/)%E3%80%82">https://blog.just666.com/2019/09/15/database-index/)。</a></p>
<h1 id="0X04-机器瓶颈（Linux）"><a href="#0X04-机器瓶颈（Linux）" class="headerlink" title="0X04 机器瓶颈（Linux）"></a>0X04 机器瓶颈（Linux）</h1><p>机器瓶颈，这里给几种简单的排查、结解决方法，主要还是得靠运维同事了。</p>
<h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><p>htop就是我们上面说到的看CPU/内存/进程和负载的工具，便于你找到疯狂消耗CPU或者内存的程序。</p>
<blockquote>
<p>  这个htop排序那里是可以用鼠标点的喔</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ger9ndnd8gj31gy0u0u0x.jpg"></p>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p>如果你机器内存爆炸💥了，还不能第一时间加内存上去，那就只有先用交换分区缓一下。<code>swapon</code>和<code>swapoff</code>两个命令可以帮到你，具体的可以搜索一下，是可以在不停机的情况下加入新的交换分区和关闭交换分区。</p>
<p>一个奇技淫巧：可以使用<code>dd</code>命令搞一个块文件，然后格式化成<code>swap</code>格式，最后挂成交换分区喔。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ger9v07ilqj31gy0u0twy.jpg"></p>
<h2 id="df-du"><a href="#df-du" class="headerlink" title="df/du"></a>df/du</h2><p><code>df</code>可以看到当前挂载的磁盘，哪些快要满了。<code>du</code>可以方便得看目录的大小，还有一个<code>ncdu</code>是<code>du</code>的进阶版，是一个类似图形化的界面，用起来更舒服。能确认到哪个目录占用的空间多，然后指向性得清理一些数据。有时候磁盘满了都不知道是什么东西占了空间，这时候du和ncdu就很好用了。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[读书笔记？？]]></title>
      <url>/2020/05/05/read-note/</url>
      <content type="html"><![CDATA[<h1 id="0X00-为什么要记读书笔记"><a href="#0X00-为什么要记读书笔记" class="headerlink" title="0X00 为什么要记读书笔记"></a>0X00 为什么要记读书笔记</h1><p>本来我也是一个从来不记读书笔记的人，总觉得张无忌师傅的那个”都忘了吗？忘了就去吧”的神奇教诲很有道理，我也是一直都是看书看多少算多少，记住的就记住了，忘了也就忘了。即使这次开始记笔记也不是因为我要把看过的内容都记住，这完全不可能。</p>
<p>那到底是什么原因让我开始记读书笔记了呢？”走神”。没错，就是走神。我看书的时候，尤其是自己没有那么大兴趣的书，我经常机械的读着书然后思路就飞到不知道哪里去了，可能是其他相关的知识、可能是海拉鲁大陆、可能是九界湖、也可能幻想着自己去悬崖边上的麦田里抓那些快要掉到悬崖下的小孩儿了。</p>
<p>所以为了让自己不再继续走神下去，我决定做点什么。最开始的时候是尝试把自己看到的一切内容都真正的”读”出来，读出声来，但是后来发现这种方式不太适合我，每次一本正经得把书里的内容一个字一个字念出来都觉得很奇怪，像是小学生在上语文课一样。放弃读出声来的操作之后就想到了记笔记，目前看起来这种方案还是不错的。</p>
<h1 id="0X01-我平时怎么记"><a href="#0X01-我平时怎么记" class="headerlink" title="0X01 我平时怎么记"></a>0X01 我平时怎么记</h1><p>我这里给出的方案只适用于跟我类似的朋友，如果你是认认真真读书然后想要整理大纲呀整理知识点呀之类的，那我的方案应该是帮不到你（不过也可以看看，万一呢）。我介绍的方案是我自己用过的，也就两种，很简单的。</p>
<p>首先是实体笔记，也就是像在学校里那样，左右各一本，一边看一边记；目前我是用iPad来统筹了看书和记笔记，也就放下了纸质笔记本和用了好几年的kindle（现在他可以去做他的专职工作：泡面 了）。我自己用电脑的时候不管显示器多大我都很少分屏，但是到了iPad上开个分屏一边是Kindle app一边是godnotes，效率还是挺高的（这里庆幸一下之前纠结过后还是买了iPad Air，要是当时选择了iPad mini的话分屏记笔记怕不是记笔记得累死个人）。这张图就是我平时记笔记的时候（不要在意好不好看。什么？你说看不懂？我的笔记是给自己看的，你看不看得懂问题不大🤣）</p>
<a id="more"></a>

<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gehuhyuz0lj31400u0npd.jpg"></p>
<p>当你准备好所有设备了，记得要做几件事儿：</p>
<ol>
<li>拿出手机，打开”禅定模式”或者”冥想模式”或者什么鬼的，反正就是那种类似直接锁定你手机，让你什么都干不了的模式；</li>
<li>如果是用iPad看书，打开你的”勿扰模式”；</li>
<li>去一个安静的地方，桌子上的东西尽可能的少，最好只有书、笔记本和一支笔；</li>
<li>让你的小爱同学或者Siri或者谁在一个小时后叫你；</li>
</ol>
<p>我平时记笔记怎么说呢。。。叫”意识流”吧。凡事都可以类比成软件开发，我最了解自己的需求，所以我知道怎么做才对。正因为我最清楚自己的需求”通过摘抄书上的重要内容和记录自己的想法来强制自己不走神”，所以我从来不在乎自己的笔记是不是知识点完整，是不是排版方便二次阅读，是不是便于后期查找。</p>
<p>所以说我记笔记的原则很简单：</p>
<ol>
<li>遇到书上写的”非常有道理，非常值得摘抄”的内容，抄下来，适当再加符号加重一下；</li>
<li>遇到书上提出的问题，比如”仔细想想你身边的专家是如何解决工作中他人的打断的”，我就会把我想到的答案写上去。因为一旦我不需要输出内容的时候，就有可能偷懒不去思考了；</li>
<li>遇到逻辑关系复杂的内容，画个图整理；</li>
<li>看到不认同的观点，将书上的观点和我自己的观点都写上去，并且标个问号；</li>
</ol>
<p>大概就是这样，整体来说非常简单，并不是什么”正经”的读书笔记记录法，不过这种方式对我来说非常奏效。</p>
<h1 id="0X03-资源和工具"><a href="#0X03-资源和工具" class="headerlink" title="0X03 资源和工具"></a>0X03 资源和工具</h1><p>先从资源说起吧，目前我的书主要分两种：京东和淘宝买的纸质书、亚马逊买的电子书。以前用Kindle的时候只买与专业技术无关或者关系甚小的书，因为Kindle确实太小了而且前后翻页也很不方便。现在用iPad Air替换Kindle之后明显买电子书的意愿比原来更大了，现在出了特别硬核的极其特殊的书，我都买电子版了。（经历了搬家和大刀阔斧整理房间之后，才发现纸质书真的太重太占地方了）</p>
<p>工具方面我在iPad上几乎只用这两个：Kindle app和Goodnotes。其中Kindle是因为电子书市场的书比较多，虽然现在好多电子书平台，不过他们市场里的书都比较少，主要还是以畅销书为主。Goodnotes是用来看PDF和记笔记用的，Notability也买了，不过不太用的惯。另外的工具其实也有，比如用来画思维导图的MindNode，在电脑上画好直接传到iPad上粘贴到Goodnotes，体验很棒。目前用着不舒服的一点就是Kindle app好像并不能把图片拖出来，在iPad上左右分屏的时候可以轻松将Safari里的图长按拖动到Goodnotes里，其他好多程序也都支持，但是Kindle是不可以的。不知道是不是版权的问题有限制，搞得我每次都是切过去截图然后把截图剪出来粘贴上去，幸亏这种需求不算频繁。</p>
<p>硬件工具除了iPad以外就是Apple Pencil和一张膜了。Apple Pencil跟iPad一起记笔记真的还挺舒服的，但是最好给iPad贴一张”类纸膜”，要不然iPad的屏幕太光滑了，写字总是不太舒服。</p>
<h1 id="0X02-真的有用吗"><a href="#0X02-真的有用吗" class="headerlink" title="0X02 真的有用吗"></a>0X02 真的有用吗</h1><p>有没有用还真不好说，反正我自己的综合体验来说有这么几点</p>
<ol>
<li>看书的效率明显下降，因为要专心，还要做笔记。估计是之前的一半左右；</li>
<li>即使是自己看过了不太记得的地方，回头乱翻翻自己乱记的笔记也能回忆起来不少东西；</li>
<li>以前看了实体书，厚厚一本就会有成就感，后面看了电子书就没有那么大成就感了。现在开始记笔记之后，看看自己的笔记（即使是电子笔记）成就感又回来了</li>
</ol>
<p>如果各位也有跟我类似的困扰，那也可以试试我的方法。不管用不收钱，管用也不收钱🤩</p>
]]></content>
      
        
        <tags>
            
            <tag> Read </tag>
            
            <tag> Note </tag>
            
            <tag> Notebook </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中诡异的权限（奇怪的权限增加了）]]></title>
      <url>/2020/04/23/linux-permission/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><blockquote>
<p>Linux诡异的权限是怎么回事呢？Linux相信大家都很熟悉， 但是诡异的权限是怎么回事呢？下面就让小编带大家一起了解吧。</p>
<p>Linux诡异的权限，其实就是诡异的权限了。那么Linux为什么会诡异的权限，相信大家都很好奇是怎么回事。大家可能会感到很惊讶，Linux怎么会诡异的权限呢？但事实就是这样，小编也感到非常惊讶。 那么这就是关于Linux诡异的权限的事情了，大家有没有觉得很神奇呢？</p>
<p>看了今天的内容，大家有什么想法呢？欢迎在评论区告诉小编一起讨论哦。</p>
</blockquote>
<p>说正事说正事儿。说起Linux权限大家肯定：”这我知道啊，不就是rwx吗，r是读、w是写、x是执行。就这？”当然不只是这个，不过我们还是要从最基础的开始说起来。</p>
<a id="more"></a>

<h1 id="0X01-基础权限部分"><a href="#0X01-基础权限部分" class="headerlink" title="0X01 基础权限部分"></a>0X01 基础权限部分</h1><p>首先最基础的权限就是 <code>rwx</code> 这种，三组权限针对:所 属用户、所属用户的组、其他用户，每组3位(对应 二进制位)。正因为对应二进制位所以<code>rwx</code>就是三个 二进制位均为1的7;<code>r-x</code>就是对应的101也就是5;<code>r-</code> 就是100也就是4</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge43ddofakj315g0iu16s.jpg" alt="Linux基础权限"></p>
<p>最基础的rwx权限就不多说了，说一个不是所有人都 知道的，看下面这张截图:这个叫做linux.pdf的文 件，这个文件的权限是777，但是当我们试图删除它的时候，发现完全不能行，那是为什么呢？我们很自然的认为对一个文件有rwx的权限就是有所有权限了，其实这么理解问题不大。但是考虑一个问题，删除一个 目录里的文件，实际上是不是在对这个目录进行w操 作呢?<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge43jtgw7xj30py06yq73.jpg"></p>
<p>返回来再看这个目录的权限就明白了。是的，基于Linux中”万物皆文件”的思路，可以知道目录其实也是文件，所以删除目录里的文件就是在修改这个目录，进而得到结论：删除文件是需要拥有对文件所在目录的w权限才行的。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge43gladatj30v605agt8.jpg"></p>
<h1 id="0X02-ACL"><a href="#0X02-ACL" class="headerlink" title="0X02 ACL"></a>0X02 ACL</h1><p>现在再来看另一个问题:我们看这个叫<code>macOS.txt</code>的文件，又是一个777权限的文件。按照上面提到的内容，我们就算不能删了它起码也能给它写成空文件是吧，因为毕竟有w权限。但是你真的有这个文件的w权 限吗?当你尝试给这个文件写入内容的时候直接就报错了，完全没有权限。是的，也许机智的你注意到了，问题就出现在 <code>-rwxrwxrwx+</code> 中最后的<code>+</code>那里。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge43o1s5o6j30za08c7fp.jpg"></p>
<p>实际上是因为Linux上还有一个叫做ACL的机制。系统用户肯定不能单纯通过用户和组来完成的，正是通过 ACL的这个机制可以在传统的rwx权限的基础上进行扩 展。可以使用ACL在rwx之外给单独一个/多个用户/组 指定权限。比如下面这种用法:<code>setfacl -m u:shawn:--- macOS.txt</code>拆分开看这个命令，第一个参数 -m指 的是(modify)，后面的<code>u:shawn:---</code>就是说 <code>用户: shawn:三无权限</code> 。再使用getfacl看一下文件具体权限，可以看到，所属人和组都是root，用户、组和其 他人的权限都是777，但是只有一个<code>user:shawn:---</code>，这个就意味着只有这个用户是没有权限的。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge43oxve6sj30yq0cy4ai.jpg"></p>
<h1 id="0X03-隐藏属性"><a href="#0X03-隐藏属性" class="headerlink" title="0X03 隐藏属性"></a>0X03 隐藏属性</h1><p>我们来看一下这个DELETE_ME的文件，我们仍然还是有777的权限，也没有通过ACL限制单个用户的权限，而且当前目录我也有w权限。那我们来尝试删除或者重写一下内容好了，发现还是还是还是还是没有权限。。。。那这回又是为什么呢？</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge43pp3dfuj310i0pm1kx.jpg"></p>
<p>是的，又是一个奇怪的东⻄:<code>attr</code>我们可以使用<code>lsattr filename</code>来查看当前文件的隐藏属性，有很多，这里可以看到的是i和e。其中e是系统底层的自带的， 有兴趣的话可以自己查阅一下资料。刚刚文件删不掉 改不了是因为这个i。这个i的功能就是: <strong>immutable 不可改变的</strong> 。所以我们不能删除，也不能修改内容。 使用<code>chattr -I filename</code>就可以将这个标记删除了，然 后这个文件也就可以改动了。如果需要增加这个标记 的话是<code>chattr +I filename</code>也就是说用加减号来控制隐 藏的标记。也可以使用等号<code>chattr =I filename</code>的方式来直接重写所有的标记。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge43qbpmjij30zw08cn6h.jpg"></p>
<p>关于这个attr的所有参数内容<a href="https://linux.die.net/man/1/chattr">都在这里</a></p>
<h1 id="0X04-奇怪的权限知识增加了"><a href="#0X04-奇怪的权限知识增加了" class="headerlink" title="0X04 奇怪的权限知识增加了"></a>0X04 奇怪的权限知识增加了</h1><p>到此为止这些隐藏在最基础的rwx权限之外的奇怪的权限（并不全，其实还有其他的）就说完了，希望大家能有所收获～</p>
<p>备注1:有些Linux发行版本没有默认附带这个，我展 示是用的Fedora所以要通过dnf装一下这个功能。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge43t8b5fvj32hc0quu0x.jpg"></p>
<p>备注2:除了rwx的基础权限部分以外，ACL和attr两 部分内容是仅适用于Linux发行版本的，macOS并不 适用，如果需要学习或者测试的话要搞一台Linux才 行。</p>
<p>备注3:ACL和attr的相关资料:</p>
<ol>
<li><a href="https://man.linuxde.net/setfacl">https://man.linuxde.net/setfacl</a></li>
<li><a href="https://man.linuxde.net/lsattr">https://man.linuxde.net/lsattr</a></li>
<li><a href="https://man.linuxde.net/chattr">https://man.linuxde.net/chattr</a></li>
<li><a href="https://linux.die.net/man/1/chattr">https://linux.die.net/man/1/chattr</a></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ACL </tag>
            
            <tag> Permission </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何让自己的Linux/macOS终端更好用]]></title>
      <url>/2020/04/19/terminal/</url>
      <content type="html"><![CDATA[<h1 id="0X00-视频在这里-下面是配置文件"><a href="#0X00-视频在这里-下面是配置文件" class="headerlink" title="0X00 视频在这里 下面是配置文件"></a>0X00 <a href="https://www.bilibili.com/video/BV1JA411b7dp/">视频在这里</a> 下面是配置文件</h1><p>这篇博客要配合<a href="https://www.bilibili.com/video/BV1JA411b7dp/">发在bilibili的视频</a>来看，这个文件是在<code>~/.zshrc</code>的。大家有问题直接在视频下面留言或者直接给我私信好了～</p>
<a id="more"></a>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># system env</span></span><br><span class="line"><span class="built_in">export</span> ZSH=<span class="string">&quot;/Users/shawn/.oh-my-zsh&quot;</span></span><br><span class="line"><span class="built_in">export</span> LANGUAGE=en_US</span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br><span class="line"><span class="comment"># ZSH_THEME=&quot;agnoster&quot;</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br><span class="line">EDITOR=/usr/bin/vim</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/Library/Python/3.7/bin</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/Library/Python/2.7/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HIST_STAMPS=<span class="string">&quot;yyyy-mm-dd&quot;</span></span><br><span class="line">HISTFILESIZE=100000</span><br><span class="line">HISTFILE=~/.zsh_history</span><br><span class="line"></span><br><span class="line"><span class="comment"># zsh plugin</span></span><br><span class="line">plugins=(</span><br><span class="line">    z</span><br><span class="line">    git</span><br><span class="line">    docker</span><br><span class="line">    fabric</span><br><span class="line">    extract</span><br><span class="line">    thefuck</span><br><span class="line">    fzf-zsh</span><br><span class="line">    git-open</span><br><span class="line">    colored-man-pages</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alias for simple command</span></span><br><span class="line"><span class="built_in">alias</span> py2=<span class="string">&#x27;/Users/shawn/Library/Python/2.7/bin/ipython2&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> py=<span class="string">&#x27;/Users/shawn/Library/Python/3.7/bin/ipython3&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> cat=<span class="string">&#x27;/usr/local/bin/bat&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> down=<span class="string">&#x27;aria2c -x16 -j4&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> me=<span class="string">&quot;cd <span class="variable">$HOME</span>/Workstadion/ &amp;&amp; ls&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alias to source command</span></span><br><span class="line"><span class="built_in">alias</span> _cat=<span class="string">&#x27;/bin/cat&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ctrl + n autosuggest</span></span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;^n&#x27;</span> autosuggest-accept</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker</span></span><br><span class="line"><span class="function"><span class="title">attach</span></span>() &#123;</span><br><span class="line">  docker <span class="built_in">exec</span> -it `docker ps | grep $* | awk -F <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>` bash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">attach_django</span></span>() &#123;</span><br><span class="line">  docker <span class="built_in">exec</span> -it `docker ps | grep $* | awk -F <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>` python manage.py shell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">git_set_proxy</span></span>() &#123;</span><br><span class="line">  git config --global http.proxy <span class="string">&#x27;socks5://127.0.0.1:1080&#x27;</span></span><br><span class="line">  git config --global https.proxy <span class="string">&#x27;socks5://127.0.0.1:1080&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">git_unset_proxy</span></span>() &#123;</span><br><span class="line">  git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">  git config --global --<span class="built_in">unset</span> https.proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">json</span></span>() &#123;</span><br><span class="line">    <span class="comment"># echo `xclip -o` | jq   # Linux</span></span><br><span class="line">    <span class="built_in">echo</span> `pbpaste` | jq    <span class="comment"># macOS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.</span></span><br><span class="line">[[ ! -f ~/.p10k.zsh ]] || <span class="built_in">source</span> ~/.p10k.zsh</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
            <tag> macOS </tag>
            
            <tag> Terminal </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2019年度总结]]></title>
      <url>/2019/12/31/2019-bye/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>2020年要来了，听起来这是个多科幻的年号啊。《银翼杀手》里说2019年底人类就有强人工智能了，可以穿梭宇宙了，甚至可以星际殖民了。然而现在就是2019年最后一天了，我的小爱同学还是像智障一样经常听不懂我说话。</p>
<p>换个角度想一想，90后是不是会觉得60后已经算是老年人了；那么相同时间差算下来20后也会觉得我们90后是老人，然而第一个20后还有一个多小时就出生了呢。</p>
<h1 id="0X01-2019年度分析"><a href="#0X01-2019年度分析" class="headerlink" title="0X01 2019年度分析"></a>0X01 2019年度分析</h1><p>2019年是我第一次做整年的规划，大概进度是这样的。正所谓“取法其上，仅得其中；取法其中，仅得其下”，所以给自己的目标定高一些甚至超出自己的能力也没什么不好的，这样可以让自己完成目标的动力最大化的嘛（其实也算是给自己没完成目标找一个借口，哈哈哈）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">阅读20本书【完成】</span><br><span class="line">专业进阶（学习了解新技术）【5&#x2F;7】</span><br><span class="line">了解五个新领域【4&#x2F;5】</span><br><span class="line">撰写30篇博客（包含20篇技术类）【27&#x2F;30】</span><br><span class="line">观看50部电影（包含25部豆瓣top250）【47&#x2F;50】</span><br><span class="line">减重至75KG（共减10KG）【5&#x2F;10】</span><br></pre></td></tr></table></figure>

<p>因为我是一个比较喜欢对自己生活做计划的人，之前我没有计划的时候就自己趴在床上玩手机甚至都能玩一下午。所以今年年初的时候就给自己定了一系列的目标，试着打卡式过这个2019，结果发现效果还是挺好的。</p>
<p>其中30篇博客我觉得是可以推荐给同样写博客的同学的，其实一年下来写30篇博客而且又不都是技术类的并没有很难。这样的话不仅可以让自己的博客更饱满还更可以逼迫自己学习，大家一定都会有过那种自己觉得看了几篇博客文档又写了几行代码验证就觉得自己回了的时候吧。其实这种时候如果计划把这部分整理成博客的话，就可以大幅度提升自己的学习效果，毕竟自己也不可能乱写一通就发表了。想必也都知道那句“教别人的同时也非常能提升自己”，其实这里的道理是一样的。我每次写博客都是想尽可能把事情说清楚说明白，如果过程中发现自己说不明白那就只有继续研究这个东西，直到能解释给别人为止。所以说程序员自己写博客传授自己的知识和经验几乎就是百利而无一害的。</p>
<p>观看25部豆瓣top250的电影也非常棒的，再结合前面20本书里包含的那本<a href="https://book.douban.com/subject/2326403/">《认识电影》ISBN: 9787506287081</a>书，感觉近一年来对电影越来越了解了，更多的会去看电影里导演想要表达的东西而不是简简单单的故事了。这本书也非常推荐给喜欢看电影的同学，里面从多个角度介绍了电影的基础知识，对理解电影有非常棒的帮助。</p>
<p>了解新领域就更有意思了。现在网络这么发达（听起来好象是2005年的台词啊），几乎是想要了解的任何一个领域都会有对应领域的大佬做科普，甚至还会有国际一流院校推出的MOOC可以学。想要了解一个新领域的成本越来越低了，没有什么是搜索引擎解决不了的（什么  你说百度？打扰了），尤其是对我这种好奇宝宝（宝宝？）来说简直太棒了。</p>
<h1 id="0X02-2019值得纪念"><a href="#0X02-2019值得纪念" class="headerlink" title="0X02 2019值得纪念"></a>0X02 2019值得纪念</h1><p>今年有什么特殊的事情发生吗？让我仔细想想……好多都比较私人，说几个不那么私人的吧。</p>
<ol>
<li>年初的时候考了红十字会的急救员证书，真希望永远也用不到这个东西；</li>
<li>换了一台4核8线程32G内存的电脑（这也算很值得纪念了哈哈哈哈）；</li>
<li>跟去年比起来，今年真正属于自己的时间多了不少，也就做了不少饭，厨艺精进哈哈；</li>
<li>我成UP主了，当时买电脑发现网上Thinkpad T480的评测很少，获取不到重要信息，就自己录了一个，现在使用体验和拆机视频一共播放量都有六万了；</li>
<li>因为《脱口秀大会》的缘故，去看了本地的一场线下脱口秀，虽然当时没抱太大期望但是结果却意外的好，大家有兴趣的可以试试线下脱口秀；</li>
<li>卖掉PS4换了一台Switch（不是PS4不好，是最近想玩的PS4游戏都玩过了，正好玩Switch等明年的PS5）</li>
</ol>
<h1 id="0X03-2019看到的好电影"><a href="#0X03-2019看到的好电影" class="headerlink" title="0X03 2019看到的好电影"></a>0X03 2019看到的好电影</h1><p>这里给大家推荐一些今年看过的电影，都是我觉得非常棒的，豆瓣top250里的就不算了哈。</p>
<p>《利刃出鞘》：这是一部悬疑电影，虽然号称007大战美国队长，但实际上并没有动作戏。我觉得悬疑篇最重要的两点：一个是主角和观众的信息对等，不要出现主角知道的一些事情没有告诉观众的情况，比如我们还在想这个杀人凶手是怎么逃离人群的时候，结果其实人家会隐身？？第二个是让观众一直循环在”我是个天才-我是个智障-我是个天才-我是个智障“之间。</p>
<p>《双子杀手》：这个电影说实话剧情上不算多好，不过由于是李安指导的120fps电影，机会可是不多啊。就赶紧买了杜比影院的票去体验2K 120FPS的杜比影院技术了。真的太棒太棒了，120FPS使得动作极为流畅，维尔史密斯的每个动作都清晰且流畅；杜比影院的超高对比度使得一场暗处动作戏相当好看。一场电影看下来真的是意犹未尽的感觉，甚至有着不输给复仇者联盟的视觉震撼。</p>
<p>《流浪地球》：这个电影其实是没什么问题的，非常棒。虽然不是顶级制作但是也没有一些人嘴里的那么不堪。电影总体来说即使去掉所谓情怀和国产的tag也是一部非常不错的电影呢。</p>
<p>《复仇者联盟4》：这个电影基本就是一个字“爽”。就像大佬说的这叫 <em>movie</em> 而不是 <em>cinema</em>，不过这也不是什么贬义啦。这也是我为数不多二刷的电影，确实很好看。</p>
<p>《徒手攀岩》：这部电影出乎意外的好看。我以为会很无聊，结果全程双手握紧直出冷汗。喜欢看纪录片的同学强烈推荐这部记录片。</p>
<p>《中国机长》：跟上面的徒手攀岩一样，我以为会很无聊，结果全镇双手紧握直出冷汗。（还真就一样，完全一样哈哈哈哈哈）都说看了这部电影就不敢坐飞机了，我反而觉得有这样的机长坐镇我更敢坐飞机了呢。</p>
<h1 id="0X04-2019玩到的好游戏"><a href="#0X04-2019玩到的好游戏" class="headerlink" title="0X04 2019玩到的好游戏"></a>0X04 2019玩到的好游戏</h1><p>要说今年玩到过的好玩的游戏，如果直让我选一个，那就是《战神》。虽然这个游戏是去年出的，但是也太棒了吧！！！</p>
<p>故事非常棒，整个算下来大概就是小战神和奎爷打算把小战神母亲的骨灰扬了。（？？？哈哈哈）</p>
<p>认真认真，这里说一个我最喜欢的点。游戏的越肩视角一镜到底是真的厉害，完全不会打断游戏流程。假设玩家永远不挂的话，那就可以保持整个镜头从头到尾不动的。为了满足这个点就设计出了我在游戏里最喜欢最喜欢的一个小细节：传送。一般游戏传送就两种，选择目的地后切换界面读条，再切换载入；要么就是上车上马然后一路自动跑过去要等很久；但是战神里的处理简直太棒了！游戏里有固定的传送点，是一堆散落在地上的石头，奎爷靠近的时候石头就自己围起来变成门，中间是白色的像是传送门一样；然后奎爷就进入到白色的空间里，里面是一个类似迷宫的小地图，在里面跑哇跑哇跑哇，突然前面又刷新出了一个白色的门，出去就到了目的地。其实类似迷宫的那个小地图八成是一直在内存里的（或者奎爷离传送门近的时候开始加载的），所以我们进入小地图的过程是无缝的；从小地图里跑来跑去自己以为是跑向传送门，其实是游戏正在加载目的地的资源，等加载好了就在你面前放一个传送门，直接出去无缝衔接。这个设计真的是让我惊叹不已。</p>
<h1 id="0X05-总结"><a href="#0X05-总结" class="headerlink" title="0X05 总结"></a>0X05 总结</h1><p>总的来说2019年过得还是挺好的，希望2020年过得更好吧<del>~</del>   大家<strong>新年快乐</strong>!!!</p>
]]></content>
      
        
        <tags>
            
            <tag> log </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Django中使用RabbitMQ]]></title>
      <url>/2019/11/21/django-rabbitmq/</url>
      <content type="html"><![CDATA[<h1 id="0X00-使用docker部署RabbitMQ"><a href="#0X00-使用docker部署RabbitMQ" class="headerlink" title="0X00 使用docker部署RabbitMQ"></a>0X00 使用docker部署RabbitMQ</h1><p>自从用起docker之后，每次在自己本地开发环境部署新服务就首选用docker了。虽然理论上docker跟裸机部署比起来多多少少有一些缺点，但是跟3分钟部署几乎一些开发环境服务的优势比起来简直都是毛毛雨了。</p>
<p>首先要拉个镜像下来，通常拉镜像都是选择最新的或者特定某个版本，但是RabbitMQ有一点比较奇怪，如果逆向拉带有web管理页面的就不能用<code>latest</code>，而应该选择<code>management</code>。然后确定好镜像之后再了解一下端口情况，RabbitMQ带有web管理页面的话会用到两个端口：提供MQ服务的<code>5672</code>和提供web服务的<code>15672</code>。</p>
<p>下面是我的配置文件，把内容保存为<code>docker-compose.yml</code>然后<code>docker-compose up -d</code>就好了（如果不在yml文件所在目录下执行或者文件名不叫<code>docker-compose.yml</code>的话要用<code>docker-compose -f xxx/xxx/xxx/xxx.yml</code>指定配置文件的位置。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># image: rabbitmq:latest    # 如果要用不带web界面的可以选这个</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rabbitmq:management</span>  <span class="comment"># 带有web界面的镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rabbitmq</span>    <span class="comment"># 取一个容器名</span></span><br><span class="line">    <span class="attr">ports:</span>  <span class="comment"># 开放两个端口，当然没有web界面的话就不用开放15672了</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5672:5672&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15672:15672&quot;</span></span><br><span class="line">    <span class="attr">environment:</span>    <span class="comment"># 这里设置登录名和密码</span></span><br><span class="line">      <span class="attr">RABBITMQ_DEFAULT_USER:</span> <span class="string">shawn</span></span><br><span class="line">      <span class="attr">RABBITMQ_DEFAULT_PASS:</span> <span class="string">****************</span>   <span class="comment"># 高科技加密（骗你的，我自己打的星号</span></span><br></pre></td></tr></table></figure>

<p>这样以来服务就启动起来了，可以访问<code>http://127.0.0.1:15672</code>看到RabbitMQ的web登录页面了。</p>
<blockquote>
<p><code>docker-compose</code>并不是docker的一部分，而是一个用Python编写的docker编排工具。如果电脑上的话可以使用<code>pip install docker-compose</code>来安装它</p>
</blockquote>
<a id="more"></a>

<h1 id="0X01-使用Python调用RabbitMQ"><a href="#0X01-使用Python调用RabbitMQ" class="headerlink" title="0X01 使用Python调用RabbitMQ"></a>0X01 使用Python调用RabbitMQ</h1><p><a href="https://www.rabbitmq.com/tutorials/tutorial-one-python.html">RabbitMQ的官方文档上有一个非常简单明了的介绍如何使用Python接入RabbitMQ</a>。有两坨代码，一坨是sender另一坨是receiver，首先是sender：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立和RabbitMQ的连接</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;shawn&#x27;</span>, <span class="string">&#x27;********&#x27;</span>)   <span class="comment"># 两个参数：用户名和密码</span></span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;/&#x27;</span>, credentials)  <span class="comment"># 四个参数：机器、端口、虚拟主机（新手先不管它）、认证信息</span></span><br><span class="line">)</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择使用一个队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送一个消息</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;hello&#x27;</span>, body=<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断开连接</span></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<p>然后是差不太多的receiver的这一坨</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完全相同的建立连接</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;shawn&#x27;</span>, <span class="string">&#x27;********&#x27;</span>)</span><br><span class="line">connection = pika.BlockingConnection(</span><br><span class="line">    pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;/&#x27;</span>, credentials)</span><br><span class="line">)</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完全相同的选择使用一个队列</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ch, method, properties, body</span>):</span></span><br><span class="line">    print(<span class="string">&quot; [x] Received %r&quot;</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从&#x27;hello&#x27;队列来的消息交给`callback`方法处理</span></span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;hello&#x27;</span>, on_message_callback=callback, auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始等待消息</span></span><br><span class="line">print(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>现在就可以用<code>python sender.py</code>把消息塞到RabbitMQ中，再用<code>python receiver.py</code>拿到RabbitMQ队列中的消息了。</p>
<h1 id="0X02-使用Django调用RabbitMQ（Celery）"><a href="#0X02-使用Django调用RabbitMQ（Celery）" class="headerlink" title="0X02 使用Django调用RabbitMQ（Celery）"></a>0X02 使用Django调用RabbitMQ（Celery）</h1><p>Django在生产环境中经常需要Celery的支持，在Django中使用Celery主要是为了两大特性：定时任务和异步任务。如果够骚的话定时任务可以通过Linux的<code>crontab</code>来替代，但是异步任务目前还不太好离开Celery。通常部署Celery的时候后端都是Redis，这次可以尝试一下使用RabbitMQ（Celery默认就是支持使用RabbitMQ这类MQ的）。在正常配置了Redis作为后端的情况下切换到RabbitMQ其实是不麻烦的：唯一要做的就是将本来的<code>BROKER_URL</code>改成<code>BROKER_URL=&#39;amqp://shawn:********@localhost:5672//&#39;</code>就可以了。</p>
<p>相比Redis，RabbitMQ自带web界面，可以方便的查看后台任务；而且作为broker来说性能更强劲。可能这也是Celery官方建议使用RabbitMQ的原因吧。</p>
<blockquote>
<p>Django3其实已经开始支持异步了，但等到大规模高质量应用可能还需要一段时间</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> MQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django中的url]]></title>
      <url>/2019/11/20/django-url/</url>
      <content type="html"><![CDATA[<h1 id="0X00-url的源头"><a href="#0X00-url的源头" class="headerlink" title="0X00 url的源头"></a>0X00 url的源头</h1><p>使用<code>django-admin startproject test_project</code>创建一个新的Django项目之后在<code>settings.py</code>中可以找到一个配置项<code>ROOT_URLCONF</code>，默认情况下值为项目目录下的<code>urls</code>，也就是<code>test_project.urls</code>。</p>
<p>默认情况下这个<code>urls.py</code>的内容大致是这样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;learn_django URL Configuration</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The `urlpatterns` list routes URLs to views. For more information please see:</span></span><br><span class="line"><span class="string">    https://docs.djangoproject.com/en/2.2/topics/http/urls/</span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">Function views</span></span><br><span class="line"><span class="string">    1. Add an import:  from my_app import views</span></span><br><span class="line"><span class="string">    2. Add a URL to urlpatterns:  path(&#x27;&#x27;, views.home, name=&#x27;home&#x27;)</span></span><br><span class="line"><span class="string">Class-based views</span></span><br><span class="line"><span class="string">    1. Add an import:  from other_app.views import Home</span></span><br><span class="line"><span class="string">    2. Add a URL to urlpatterns:  path(&#x27;&#x27;, Home.as_view(), name=&#x27;home&#x27;)</span></span><br><span class="line"><span class="string">Including another URLconf</span></span><br><span class="line"><span class="string">    1. Import the include() function: from django.urls import include, path</span></span><br><span class="line"><span class="string">    2. Add a URL to urlpatterns:  path(&#x27;blog/&#x27;, include(&#x27;blog.urls&#x27;))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里就是根目录了，新项目使用<code>python manage.py runserver</code>启动之后访问<code>http://127.0.0.1:8000/</code>就是访问到这个url的根路由了，默认情况下有一个<code>admin/</code>可选，也就是Django自己的后台管理页面。<strong>Django所有的url都是从这个文件发散出去的</strong>，<code>urlpatterns</code>里除了将url路由至<code>view</code>就是其他的子url配置。换句话说，通常情况下Django中所有url最终都应该被路由到View上才对。</p>
<a id="more"></a>

<h1 id="0X01-路由到子url和view"><a href="#0X01-路由到子url和view" class="headerlink" title="0X01 路由到子url和view"></a>0X01 路由到子url和view</h1><p>上面提到通常情况下Django中所有url最终都应该被路由到View上，那就来看一下究竟该怎么做。现在有一个项目，项目中有一个app叫<code>student</code>是用来管理一些学生信息的，app中有一个<code>views.py</code>，具体内容就暂时不列出了，在此处关系不大；还有一个<code>urls.py</code>，内容是这样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> StudentView, ExamView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;^$&#x27;</span>, StudentView.as_view()),    <span class="comment"># 直接将这个子url的根目录路由到一个view</span></span><br><span class="line">    path(<span class="string">&#x27;^exam/$&#x27;</span>, ExamView.as_view()),    <span class="comment"># 直接将url路由至一个view</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>现在要来修改根的<code>urls.py</code>了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;student/&#x27;</span>, include(<span class="string">&#x27;test_project.student.urls&#x27;</span>)), <span class="comment"># 其实就加了这一行，这里的include就是包含另一个urls的配置文件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>现在就是这样的，如果访问<code>http://127.0.0.1:8000/admin</code>还是之前的DjangoAdmin默认管理页面没问题，如果访问<code>http://127.0.0.1:8000/student/</code>的话就是到<code>StudentView</code>而<code>http://127.0.0.1:8000/student/exam/</code>就是<code>ExamView</code>了。</p>
<h1 id="0X02-参数与正则"><a href="#0X02-参数与正则" class="headerlink" title="0X02 参数与正则"></a>0X02 参数与正则</h1><p>url中常见的出现一些参数，一般来说参数分成两种：第一种是在path中作为路由的一部分，另一种是在后面以GET的查询参数方式出现例如<code>/student?name=shawn&amp;age__gt=16</code>这种。第二种方式比较简单，在传入到view后，从view的<code>request.GET</code>就能取到了。但是也经常会遇到第一种，例如这样一个path<code>/article/2019/11/20/why-linux</code>，可以猜测它指的是2019年11月20日的一篇名为’why-linux’的文章。那么这种该怎么取呢？其实很简单，在view里<code>request.path.split(&#39;/&#39;)</code>然后取下标就行了（当然这很蠢且很不靠谱，但是还不失为一种方案哈哈哈哈）。</p>
<p>这种时候比较靠谱的方式是使用url中的参数，有一个子url配置如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&lt;str:name&gt;/&#x27;</span>, StudentView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;int:year&gt;</code>就是指的一个参数，前三个是整型参数，最后一个是字符串参数。我们知道<code>view</code>中<code>GET</code>方法的定义是<code>def get(self, request, *args, **kwargs)</code>，那么其实后面的这个<code>**kwargs</code>里就是这里传进来的参数了，可以通过<code>year, month, day, name = kwargs[&#39;year&#39;], kwargs[&#39;month&#39;], kwargs[&#39;day&#39;], kwargs[&#39;name&#39;]</code>这种类似的方式来取到对应的值</p>
<p>还是上面这个例子，咱们知道年号一定是正整数，月份一定是1<del>12之间，日期一定是1</del>31之间（先不考虑闰年和大小月的问题，只是方便探讨url）。那上面这个例子中的url如果我传一个<code>/article/0/666/233/test/</code>过去其实是没有意义的，所以需要一些简单的校验。那么众所周知，正则表达式非常适合做这种事情。下面来修改一下刚刚的这个url配置好了，修改后的配置Django就可以根据正则来匹配了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">r&#x27;^[1-9]\d*/0[1-9]|1[0-2]/xxxxx&#x27;</span>, StudentView.as_view()),  <span class="comment"># 完整正则好长，就不都贴在这儿了</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Django在匹配的时候是按照<code>urlpatterns</code>这个列表的下标顺序来的，所一说如果先符合了上面的规则，即时再符合下面的规则也不会继续判断下去了。</p>
</blockquote>
<h1 id="0X03-DRF中的router-register"><a href="#0X03-DRF中的router-register" class="headerlink" title="0X03 DRF中的router.register"></a>0X03 DRF中的router.register</h1><p>一般使用Django的同时也会使用<strong>Django REST framework</strong>了，所以也简单介绍一下在DRF中特有的一种路由方式好了。因为DRF中大量使用<code>ViewSet</code>而非标准的Django View，所以可以使用DRF封装的下面这种方式来建立路由</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">router = routers.DefaultRouter()    <span class="comment"># 实例化一个router</span></span><br><span class="line">router.register(<span class="string">r&#x27;student/&#x27;</span>, views.xxxxxxxxViewSet) <span class="comment"># 注册viewset</span></span><br><span class="line">router.register(<span class="string">r&#x27;teacher/&#x27;</span>, views.xxxxxxxxViewSet)</span><br><span class="line"></span><br><span class="line">urlpatterns = router.urls   <span class="comment"># 最后还是要生成urlpatterns</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽说是叫做<code>router</code>不过翻译成路由器总是有点怪怪的，哈哈哈</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python之面向对象 2]]></title>
      <url>/2019/11/19/python-oop-2/</url>
      <content type="html"><![CDATA[<h1 id="0X00-Python3的super"><a href="#0X00-Python3的super" class="headerlink" title="0X00 Python3的super"></a>0X00 Python3的super</h1><p>Python中对象的概念都快被大家淡忘了，因为一切都是对象（话虽然这么说，但是怎么可能淡忘对象呢）。看下面一段Python2的代码，Python2中麻烦的就是这个<code>super()</code>的用法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&#x27;human&#x27;</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;hello, i im&#x27;</span>, self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Human</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super(Student, self).__init__()</span><br><span class="line">        self.name = <span class="string">&#x27;student&#x27;</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;hello, i im&#x27;</span>, self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Student()</span><br></pre></td></tr></table></figure>

<p>在初学Python的时候，如果是Python2很大可能会在<code>super(Student, self).__init__()</code>这段迷惑好一阵子，不过好在<a href="https://pythonclock.org/">Python2马上就要凉透了</a>，在Python3中可以将代码改写成如下方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>:</span>    <span class="comment"># 不用强行继承自object了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&#x27;human&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;hello, i im&#x27;</span>, self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">Human</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super().__init__()  <span class="comment"># super的用法也更明了</span></span><br><span class="line">        self.name = <span class="string">&#x27;student&#x27;</span></span><br><span class="line">        print(<span class="string">&#x27;hello, i im&#x27;</span>, self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Student()</span><br></pre></td></tr></table></figure>

<p>其中<code>super</code>的用法由<code>super(Student, self).__init__()</code>改成了<code>super().__init__()</code>，看起来清晰多了，在使用Python3后不建议以任何理由使用老式Python中的<code>super</code>调用。</p>
<a id="more"></a>

<h1 id="0X01-str"><a href="#0X01-str" class="headerlink" title="0X01 str"></a>0X01 <strong>str</strong></h1><p>写一个自己的类通常都需要实现一个<code>__str__</code>方法，这个方法用于粗略的展示对象，可以看下面这个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下面这一堆xxx表示其他很多属性</span></span><br><span class="line">        <span class="comment"># self.xxxx = xxxx</span></span><br><span class="line">        <span class="comment"># self.xxxx = xxxx</span></span><br><span class="line">        <span class="comment"># self.xxxx = xxxx</span></span><br><span class="line">        <span class="comment"># self.xxxx = xxxx</span></span><br><span class="line">        <span class="comment"># self.xxxx = xxxx</span></span><br><span class="line">        <span class="comment"># self.xxxx = xxxx</span></span><br><span class="line">        <span class="comment"># self.xxxx = xxxx</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;name:&#123;&#125; age:&#123;&#125; gender:&#123;&#125;&#x27;</span>.format(self.name, self.age, self.gender)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Student(<span class="string">&#x27;shawn&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">b = Student(<span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">c = Student(<span class="string">&#x27;bill&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

<p>可以尝试先把<code>__str__</code>的定义注释掉执行一下，看到的输出应该是类似这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Student object at 0x7f875f881d10&gt;</span><br><span class="line">&lt;__main__.Student object at 0x7f875f881d90&gt;</span><br><span class="line">&lt;__main__.Student object at 0x7f875f881e10&gt;</span><br></pre></td></tr></table></figure>

<p>如果再取消<code>__str__</code>的注释，看到的输出就是这样的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name:shawn age:24 gender:m</span><br><span class="line">name:lucy age:24 gender:f</span><br><span class="line">name:bill age:24 gender:m</span><br></pre></td></tr></table></figure>

<p>可以看到输出变成肉眼可识别的了。</p>
<blockquote>
<p>通过 str(object) 以及内置函数 format() 和 print() 调用以生成一个对象的“非正式”或格式良好的字符串表示。返回值必须为一个 字符串 对象。<br>此方法与 object.<strong>repr</strong>() 的不同点在于 <strong>str</strong>() 并不预期返回一个有效的 Python 表达式：可以使用更方便或更准确的描述信息。<br>内置类型 object 所定义的默认实现会调用 object.<strong>repr</strong>()。    <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html?highlight=repr#object.__str__">官方文档</a></p>
</blockquote>
<h1 id="0X02-repr"><a href="#0X02-repr" class="headerlink" title="0X02 repr"></a>0X02 <strong>repr</strong></h1><p><code>__str__</code>其实很多人都是知道的，毕竟这也算是Python中最基础的部分之一了，不过这里的<code>__repr__</code>貌似就有些同学不太清楚了。<code>__repr__</code>的功能和<code>__str__</code>是类似的，不过<code>__str__</code>输出的结果是方便肉眼识别的，而<code>__repr__</code>输出的结果是”可以通过输出反向还原对象“的，换句话说就是带有对象的详尽信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">print(repr(a))</span><br><span class="line"></span><br><span class="line">b = &#123;<span class="string">&#x27;a&#x27;</span>: a, <span class="string">&#x27;b&#x27;</span>: a, <span class="string">&#x27;c&#x27;</span>: a&#125;</span><br><span class="line">print(repr(a))</span><br></pre></td></tr></table></figure>

<p>执行上面这坨代码就理解这个方法的基本情况了，注：<code>repr(a)</code>算是<code>a.__repr__()</code>的语法糖了，效果相同。</p>
<blockquote>
<p>由 repr() 内置函数调用以输出一个对象的“官方”字符串表示。如果可能，这应类似一个有效的 Python 表达式，能被用来重建具有相同取值的对象（只要有适当的环境）。如果这不可能，则应返回形式如 &lt;…some useful description…&gt; 的字符串。返回值必须是一个字符串对象。如果一个类定义了 <strong>repr</strong>() 但未定义 <strong>str</strong>()，则在需要该类的实例的“非正式”字符串表示时也会使用 <strong>repr</strong>()。<br>此方法通常被用于调试，因此确保其表示的内容包含丰富信息且无歧义是很重要的。    <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html?highlight=repr#object.__repr__">官方文档</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> OOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Docker部署MySQL和Redis]]></title>
      <url>/2019/11/14/docker-mysql-redis/</url>
      <content type="html"><![CDATA[<h1 id="0X00-使用docker部署的优势"><a href="#0X00-使用docker部署的优势" class="headerlink" title="0X00 使用docker部署的优势"></a>0X00 使用docker部署的优势</h1><p>在使用docker部署之前，一般都是直接将MySQL和Redis这类服务直接安装在机器上的。以至于好多新手才开始安装使用的时候经常会出问题，出了问题解决不了就重装系统然后再重装软件，而且如果想同时用MySQL5和MySQL8就非常麻烦了。话说回来，在生产环境服务器上其实还是很多直装的服务的，不过其实使用docker部署一套相同的环境是非常有利于自己本地开发的。</p>
<p>我个人看来使用docker部署的优势有这几点比较明显的：</p>
<ol>
<li>很容易做到开发环境、测试环境和生产环境的“环境与版本”大统一；</li>
<li>很容易在开发环境本地同时部署多套不同版本的同一服务；（比如你负责8个项目，这8个项目要用8个不同版本的MySQL）</li>
<li>能很快部署一套开发环境；（事实证明在一台网络环境好的机器上，能在5分钟内部署一套数据库）</li>
<li>整理好配置文件后可以很容易备份整套配置；</li>
<li>安全问题，在物理机上直接装了MySQL，如果部署不够仔细的话有数据库被攻破后危及服务器的风险，而Docker部署的由于容器所在就不会有这种问题；</li>
</ol>
<a id="more"></a>

<h1 id="0X01-使用docker部署MySQL"><a href="#0X01-使用docker部署MySQL" class="headerlink" title="0X01 使用docker部署MySQL"></a>0X01 使用docker部署MySQL</h1><p>首先把最新的镜像拉下来<code>docker pull mysql:latest</code>，然后可以使用<code>docker run --name your_first_mysql -e MYSQL_ROOT_PASSWORD=your_password -d mysql:latest</code>这个命令来启动一个MySQL了。</p>
<p>现在来尝试连接一下MySQL吧（其实并不能，现在连端口都没映射出来，不信可以连一下试试）。要想真正连到刚刚的MySQL里的话需要这样操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建MySQL容器</span></span><br><span class="line">docker run --name your_first_mysql -e MYSQL_ROOT_PASSWORD=your_password -d mysql:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到MySQL容器里</span></span><br><span class="line">docker <span class="built_in">exec</span> -it your_first_mysql bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器里</span></span><br><span class="line">root@b42296a45a92:/<span class="comment"># mysql -p</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 9</span><br><span class="line">Server version: 8.0.18 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以发现这次终于连上了，不过这样直接启动还是有诸多问题存在的：容器被删除后数据也就没了、其他程序很难连接到这个MySQL上、只设置了密码还有好多配置没动呢。。。先不管这些个问题，只需要知道现在这个服务已经成功启动了就好，具体的配置会在<code>docker-compose编排</code>中介绍。</p>
<h1 id="0X02-使用docker部署Redis"><a href="#0X02-使用docker部署Redis" class="headerlink" title="0X02 使用docker部署Redis"></a>0X02 使用docker部署Redis</h1><p>首先把最新的镜像拉下来<code>docker pull redis:latest</code>，然后就可以用<code>docker run --name your_first_redis redis -d</code>这个命令来启动一个Redis了。</p>
<p>现在来试试连接到Redis吧（不知道你发现了没有，我完全就是在重复上面的过程。就算刚才没发现，现在也该发现了。既然你都发现了那我也就不重复了，直接来看docker-compose的编排吧）</p>
<h1 id="0X03-使用docker-compose编排"><a href="#0X03-使用docker-compose编排" class="headerlink" title="0X03 使用docker-compose编排"></a>0X03 使用docker-compose编排</h1><p>作为开发人员而非运维，<code>docker-compose</code>的使用次数是非常高的。通常来说使用Docker都是在Unix like环境中（也就是指的Linux、MacOS或者BSD），那我们安装和使用它就很方便了：<code>pip install docker-compose --user</code>就可以了。显然这又是一个Python编写的工具，装好就可以开始编写<code>docker-compose.yml</code>文件了下面看一下我完整的这个实例文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span>    <span class="comment"># 服务的名字</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span> <span class="comment"># 使用最新的MySQL镜像</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dev_mysql_latest</span>  <span class="comment"># 指定一个容器名</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># 自动重启（开机后也自动启动）</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">bridge</span>  <span class="comment"># 指定网络为桥接</span></span><br><span class="line">    <span class="attr">volumes:</span>  <span class="comment"># 挂载的目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mysql:/var/lib/mysql</span> <span class="comment"># 将容器中的/var/lib/mysql挂载到当前目录下的data/mysql（MySQL的数据文件，防止容器删除后数据丢失）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/mysql:/etc/mysql/conf.d</span>  <span class="comment"># 挂载好配置文件的目录（没有特殊配置的时候可以不用写这行）</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span> <span class="comment"># 将容器的3306端口映射到本地的3306</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=test_passwd</span> <span class="comment"># MySQL的root密码「必填」</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 以下皆为选填</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=test_db</span>  <span class="comment"># 如指定，则在容器生成时创建该数据库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=test_user</span>  <span class="comment"># 新用户名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=test_passwd</span> <span class="comment"># 新用户的密码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ALLOW_EMPTY_PASSWORD=no</span> <span class="comment"># 不允许使用空密码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_RANDOM_ROOT_PASSWORD=no</span> <span class="comment"># 不适用随机密码（为yes时会随机生成一个密码并输出到stdout上，通常是你看到的窗口）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ONETIME_PASSWORD=onetime_passwd</span> <span class="comment"># 一次性密码（使用时，第一次登录会强制要求修改密码）</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">dev_redis_latest</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--requirepass</span> <span class="string">&quot;mypassword&quot;</span>  <span class="comment"># 指定容器运行的命令，命令处设置密码</span></span><br></pre></td></tr></table></figure>

<p>接下来在这个<code>docker-compose.yml</code>所在的目录下执行<code>docker-compose up -d</code>，这时候两个服务就都在后台悄悄启动好并可以连接使用了。如果不想同时开启所有的服务可以在后面接服务名，例如：<code>docker-compose up -d redis</code>。</p>
<h1 id="0X04-其他关于docker与docker-compose"><a href="#0X04-其他关于docker与docker-compose" class="headerlink" title="0X04 其他关于docker与docker-compose"></a>0X04 其他关于docker与docker-compose</h1><ol>
<li><code>docker exec -it dev_mysql_latest bash</code>可以接入到<code>dev_mysql_latest</code>容器的bash中进行简单的操作；</li>
<li><code>docker-compose up -d</code>中的<code>-d</code>是在后台的意思，可以不加这个参数从而把输出都打在终端上方便调试；</li>
<li><code>docker-compose stop</code>和<code>docker-compose rm</code>分别是停止容器和销毁容器，容器必须先停止再销毁；</li>
<li>如果想直接销毁容器可以使用<code>docker-compose down</code>，从输出可以看到就是先执行了<code>stop</code>再执行了<code>rm</code>。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
            <tag> Docker </tag>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中的线程、进程池]]></title>
      <url>/2019/11/12/python-thread-process-pool/</url>
      <content type="html"><![CDATA[<h1 id="0X00-线程池和进程池"><a href="#0X00-线程池和进程池" class="headerlink" title="0X00 线程池和进程池"></a>0X00 线程池和进程池</h1><p>多线程和多进程在平时编程中是挺常见的操作，不过控制进程和线程的数量是一件比较麻烦的事情。尤其是线程，之前在搜索到的关于线程池的内容多数都是“造轮子”，实际上Python已经给我们造好了这个轮子。文档在这里，甚至还是中文的<a href="https://docs.python.org/zh-cn/3.7/library/concurrent.futures.html#module-concurrent.futures">https://docs.python.org/zh-cn/3.7/library/concurrent.futures.html#module-concurrent.futures</a></p>
<p>我这里简单的整理了一下，做个小样例展示出来方便查阅。这里就假装大家对Python有一定的了解，而且也对操作系统中的线程和进程有一些了解了。（哦对了，还需要了解一下GIL才行）</p>
<a id="more"></a>

<h1 id="0X01-使用线程池"><a href="#0X01-使用线程池" class="headerlink" title="0X01 使用线程池"></a>0X01 使用线程池</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个用来测试的方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_func</span>(<span class="params">num</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    res = num * num</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 构造一个可以容纳两个线程的线程池</span></span><br><span class="line">    thread_pool = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> thread_pool <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            pool.submit(test_func, i)   <span class="comment"># 将任务提交到线程池里</span></span><br></pre></td></tr></table></figure>

<p>这段代码执行下来耗时<code>3s</code>大概，因为有两个线程在执行，所以第一次执行了两个任务，第二次两个，第三次一个。可以通过调整<code>range()</code>数量和<code>max_workers</code>来观察输出结果。</p>
<h1 id="0X02-使用进程池"><a href="#0X02-使用进程池" class="headerlink" title="0X02 使用进程池"></a>0X02 使用进程池</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_func</span>(<span class="params">num</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    res = num * num</span><br><span class="line">    print(res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    process_pool = ProcessPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> process_pool <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            pool.submit(test_func, i)</span><br></pre></td></tr></table></figure>

<p>可以看到跟上面线程池的方案比起来就只是把<code>ThreadPoolExecutor</code>换成了<code>ProcessPoolExecutor</code>而已。</p>
<h1 id="0X03-通用的部分"><a href="#0X03-通用的部分" class="headerlink" title="0X03 通用的部分"></a>0X03 通用的部分</h1><p>其中<code>ProcessPoolExecutor</code>和<code>ThreadPoolExector</code>均接收参数<code>max_workers</code>，不过由于线程和进程的本质区别，所以还是要适当设置这两个值。默认情况下<code>max_workers</code>的值设置为自己的逻辑处理器个数，如果你的CPU是4核8线程的那就自动设置成8。在 Windows 上，max_workers 必须小于等于 61，否则将引发 ValueError。</p>
<p><code>pool.submit()</code>中的参数是<code>submit(func, *args)</code>，所以把需要传递给<code>func</code>的参数逐个写在后面就好了。</p>
<p><code>pool.submit()</code>后会返回一个<code>Future</code>对象，这个对象可以查看任务的执行情况：<code>cancel()</code>可以取消任务（如果任务还没开始的话）；<code>cancelled()</code>查看任务是否被取消了；<code>running()</code>任务是否在进行；<code>done()</code>任务是否执行完了。使用<code>result()</code>可以获得任务的结果，还未完成的任务会等待结果，可以使用<code>timeout</code>参数指定等待多少秒。</p>
<h1 id="与Python无关的部分"><a href="#与Python无关的部分" class="headerlink" title="与Python无关的部分"></a>与Python无关的部分</h1><ol>
<li>使用多线程要注意不要开过多的线程，因为在线程中切换也需要资源，线程过多可能反而会影响效率；</li>
<li>进程不宜过多，防止系统负载过大；</li>
<li>使用多进程时要万分小心不要失控，因为进程数量一旦失控可能会导致系统宕机（相关内容可以搜索了解一下<code>fork炸弹</code>）。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Thread </tag>
            
            <tag> Process </tag>
            
            <tag> Parallel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django信号初级]]></title>
      <url>/2019/11/06/django-signals-primary/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>实话讲，Django的信号(signal)机制其实用到的时候并不多，但是某些特定场景下一个信号能解决非常大的问题，所以信号这个东西还是值得了解一下的。那么为什么这里只说一些初级内容呢，主要是因为通过调查发现信号的高级知识用（我）的（也）很（不）少（会）。</p>
<p>目前我工作中用到的信号机制也比较少，所以可能有些事情说不到点上还请见谅。那我们开始吧~</p>
<h1 id="0X01-什么是信号"><a href="#0X01-什么是信号" class="headerlink" title="0X01 什么是信号"></a>0X01 什么是信号</h1><p>“信号机制”光从名字上来就大概能懂了。应该就是：某人发出某信号，某人接受到之后做一些事情。所以看起来非常类似我们熟悉的“订阅-发布”模式，实际上也也确实很类似。整个信号机制分成这么几个部分：发布者、信号、接收者和一个函数。</p>
<p>我们传统战场上的一个行为来类比会比较好解释</p>
<ol>
<li>发送者：类似于战场上打信号弹的人</li>
<li>信号：信号弹（信号弹会分成几种比如红色、蓝色、绿色的）</li>
<li>接受者：各个不同阵地都有人观察着战场的信号弹</li>
<li>一个函数：接受者看到信号弹后会对应作出战术动作</li>
</ol>
<p>比如我们有三个人：小明、小强和李铁蛋，每人又有三种信号弹：红色、蓝色和绿色，又有三个不同阵地：路口、广场和理发店。其中每个人的信号弹不同，小明的红色信号弹打出去是一个”明“字，小强的是”强“，李铁蛋的是个”蛋“。</p>
<p>那么这个时候场上的小明发射了蓝色的信号弹（发送者发送了特定信号），三个阵地的人都看到了，但是之前首长说只有广场的阵地要响应小明的蓝色信号弹（提前固定好接受者要接收哪部分信号），广场的阵地接受到信号之后按照之前的计划前去攻打碉堡（接受者收到指定信号后执行一个函数）。</p>
<p>大概的流程是这个样子的，中间可能有些不准确不过大体是对的，下面我们来看一下Django自身内置的一些信号。</p>
<a id="more"></a>

<h1 id="0X02-Django内置的信号"><a href="#0X02-Django内置的信号" class="headerlink" title="0X02 Django内置的信号"></a>0X02 Django内置的信号</h1><p>Django中的信号分两类：内置和自定义的。我们先来列出现有的部分信号：（更完整的Django内置信号可以看<a href="https://docs.djangoproject.com/en/2.2/topics/signals/">官方文档</a>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model部分</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_init   <span class="comment"># 数据模型构造前触发</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_init  <span class="comment"># 数据模型构造厚触发</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_save   <span class="comment"># 数据对象保存前触发  instance.save()</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_save  <span class="comment"># 数据对象保存厚触发</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_delete <span class="comment"># 数据对象删除前触发</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_delete    <span class="comment"># 数据对象删除厚触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># migrate部分</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_migrate    <span class="comment"># migrate前触发</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_migrate   <span class="comment"># migrate后触发</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># request部分</span></span><br><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> request_finished    <span class="comment"># 请求结束后触发</span></span><br><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> request_started     <span class="comment"># 请求开始前触发</span></span><br><span class="line"><span class="keyword">from</span> django.core.signals <span class="keyword">import</span> got_request_exception   <span class="comment"># 请求异常后触发</span></span><br></pre></td></tr></table></figure>

<h1 id="0X03-使用Django信号"><a href="#0X03-使用Django信号" class="headerlink" title="0X03 使用Django信号"></a>0X03 使用Django信号</h1><p>使用一个Django信号首先要导入（或者编写）signal，接下来再设置好接受者，紧接着写好要执行的函数，然后注册它，最后调用就好了。</p>
<p>首先个人建议给signal单独放一个文件，如果你signal用的很多很多那就可以给每个app安排一个<code>signal.py</code>，或者如果你用的不过的话整个项目用一个<code>signal.py</code>就好了。首先我来在我的项目的<code>School/</code>下搞一个<code>signal.py</code>并写上下面的内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> pre_save</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> School.models <span class="keyword">import</span> Student</span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(pre_save, sender=Student)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_hello_when_student_pre_save</span>(<span class="params">sender, instance, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;hello,world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>装饰器参数中：第一个参数是信号类型，第二个参数是发送者；自定义的函数中instance就是数据对象了，但是由于是<code>pre_save</code>参数所以此时的instance还没有被真正写入到数据库中，所以如果打印<code>instance.id</code>的话其实是为空的</p>
</blockquote>
<p>然后我们来注册这个，看一下现在<code>School/apps.py</code>的内容是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolConfig</span>(<span class="params">AppConfig</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;School&#x27;</span></span><br></pre></td></tr></table></figure>

<p>我们稍加改动就能完成注册：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolConfig</span>(<span class="params">AppConfig</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;School&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ready</span>(<span class="params">self</span>):</span>    <span class="comment"># 这里的ready在Django启动的时候会自动被执行，然后我们的注册就完成了（并没有其实）</span></span><br><span class="line">        <span class="keyword">from</span> .signal <span class="keyword">import</span> print_hello_when_student_pre_save</span><br></pre></td></tr></table></figure>

<p>但是现在其实还不能用，我们知道在<code>settings.py</code>中我们只需要在<code>INSTALLED_APPS</code>中添加一个app名就可以了，但是我们这次需要把它改成<code>apps.py</code>下的app类名。我之前写的是<code>School</code>现在就要改成<code>School.apps.SchoolConfig</code>才行。（现在才是真的好了）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> ~/W/learn_dj/learn_django  master +15 !3 ?4  python manage.py shell</span><br><span class="line">Python 3.7.4 (default, Oct  4 2019, 06:57:26)</span><br><span class="line">Type <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span> or <span class="string">&#x27;license&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">IPython 7.6.1 -- An enhanced Interactive Python. Type <span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">In [1]: from School.models import Student</span><br><span class="line"></span><br><span class="line">In [2]: Student.objects.create(name=<span class="string">&#x27;shawn&#x27;</span>)</span><br><span class="line">hello,world</span><br><span class="line">Out[2]: &lt;Student: Student object (1120)&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在我<code>create</code>一个数据对象的时候确确实输出了我们指定的<code>hello,world</code>。</p>
<blockquote>
<p>关于<code>pre_save/post_save</code>的提示</p>
<ol>
<li>当使用<code>obj = models.Student.objects.first(); obj.name = &#39;hello&#39;; obj.save()</code>的方法更新数据时会触发该信号，但是如果是用<code>models.Student.objects.filter().update(name=&#39;hello&#39;)</code>是不能触发的；</li>
<li>在<code>pre_save/post_save</code>的响应函数里切忌再执行该model的<code>.save()</code>否则会进入死循环。</li>
</ol>
</blockquote>
<h1 id="0X04-自定义信号"><a href="#0X04-自定义信号" class="headerlink" title="0X04 自定义信号"></a>0X04 自定义信号</h1><p>要使用自定义信号的时候并不是很多，不过还是可以说一下。我们拿上面信号弹的例子看一下</p>
<p>首先在目录下搞一个<code>custom_signals.py</code>文件，里面写好下面的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> django.dispatch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个信号：还接收两个参数（好像比信号弹强一些哈哈哈）</span></span><br><span class="line">blue_signal = django.dispatch.Signal(providing_args=[<span class="string">&#x27;attack_time&#x27;</span>, <span class="string">&#x27;attack_zone&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">sender, attack_time, attack_zone, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> sender == <span class="string">&#x27;小明&#x27;</span>:    <span class="comment"># 只相应小明的信号</span></span><br><span class="line">        print(<span class="string">&#x27;attack it from &#123;&#125; &#123;&#125;&#x27;</span>.format(attack_time, attack_zone))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">blue_signal.connect(callback)</span><br></pre></td></tr></table></figure>

<p>然后我们启动shell来试试<code>python manage.py shell</code>，在shell里模拟一下发送信号。这个过程在正常程序中是写在<code>view</code>中的，此处只是为了展示方便</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> ~/W/learn_dj/learn_django  master +15 !3 ?6  python manage.py shell</span><br><span class="line">Python <span class="number">3.7</span><span class="number">.4</span> (default, Oct  <span class="number">4</span> <span class="number">2019</span>, <span class="number">06</span>:<span class="number">57</span>:<span class="number">26</span>) </span><br><span class="line">Type <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;license&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">IPython <span class="number">7.6</span><span class="number">.1</span> -- An enhanced Interactive Python. Type <span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> School.custom_signal <span class="keyword">import</span> blue_signal    <span class="comment"># 首先导入我们的信号</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: blue_signal.send(sender=<span class="string">&#x27;李铁蛋&#x27;</span>, attack_time=<span class="string">&#x27;now&#x27;</span>, attack_zone=<span class="string">&#x27;left&#x27;</span>)     <span class="comment"># 发送信号</span></span><br><span class="line">Out[<span class="number">2</span>]:     <span class="comment"># 并没有输出，因为接受者并不相应铁蛋的信号</span></span><br><span class="line">[(&lt;function School.custom_signal.callback(sender, attack_time, attack_zone, **kwargs)&gt;,</span><br><span class="line">  <span class="literal">None</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: blue_signal.send(sender=<span class="string">&#x27;小明&#x27;</span>, attack_time=<span class="string">&#x27;now&#x27;</span>, attack_zone=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">attack it <span class="keyword">from</span> now left     <span class="comment"># 小明的信号得到了相应，并且对应的参数也成功传进去了</span></span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">[(&lt;function School.custom_signal.callback(sender, attack_time, attack_zone, **kwargs)&gt;,</span><br><span class="line">  <span class="literal">None</span>)]</span><br></pre></td></tr></table></figure>

<h1 id="0X05-结尾"><a href="#0X05-结尾" class="headerlink" title="0X05 结尾"></a>0X05 结尾</h1><p>Django的信号机制大概就是这个样子，我这里再贴出几个不错的参考资料吧</p>
<ol>
<li><a href="https://docs.djangoproject.com/en/2.2/topics/signals/">官方文档： Django signal</a></li>
<li><a href="https://www.kawabangga.com/posts/1997">Django的信号机制  卡瓦邦噶！</a></li>
<li><a href="https://www.cnblogs.com/qwj-sysu/p/4224805.html">django 信号（signal） 2BiTT</a></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Single </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL慢查询初步]]></title>
      <url>/2019/11/03/mysql-slowquery/</url>
      <content type="html"><![CDATA[<h1 id="0X00-IO总是比运算慢"><a href="#0X00-IO总是比运算慢" class="headerlink" title="0X00 IO总是比运算慢"></a>0X00 IO总是比运算慢</h1><p>众所周知计算机的IO都要比计算慢很多很多，即时是目前民用的高级SSD：三星970PRO，它的读写速度都要比内存慢上几个数量级，更不要说CPU了。所以软件的IO通常都是瓶颈，很多时候都是CPU等内存，内存等磁盘，磁盘等网络。</p>
<p>那么如何才能提升自己web服务的响应速度呢？通常来说简单的操作有如下两种：换硬盘或者改SQL。</p>
<h1 id="0X01-换硬盘"><a href="#0X01-换硬盘" class="headerlink" title="0X01 换硬盘"></a>0X01 换硬盘</h1><p>“这难道不是废话吗？”对呀，这就是废话。当瓶颈出现在数据库的查询上了，那么把正在用的机械硬盘换成固态硬盘当然会提升效率，稍微想想就呢能明白的事情。事实上也是这样的，之前我把同样量级的数据从我们的测试环境搞到我本地，测试环境是企业级HDD，而我本地是三星970EVOPlus的SSD，会发现查询同一个内容就快了好多好多。</p>
<p>那其实这个换硬盘并不是好办法，毕竟不能指望全都用上SSD。而且即使用上SSD了，在查询更复杂或者数据量更多的情况下还是会出现瓶颈。那首先想到的方式就是优化SQL了。</p>
<a id="more"></a>

<h1 id="0X02-慢查询"><a href="#0X02-慢查询" class="headerlink" title="0X02 慢查询"></a>0X02 慢查询</h1><p>大家都知道优化SQL，那么优化哪条呢？一个系统里可能有几千条SQL，总不能一个个看吧。而且现在还有很多很多项目用上了ORM，根本不在系统里写原生SQL了。</p>
<p>这时候MySQL的慢查询功能就帮得上忙了。顾名思义“慢查询”就是很慢的查询，我们通过简单的配置能够让MySQL记录下很慢的查询语句，通过整理分析再回去系统中找到产生这些慢查询的位置逐个优化就可以了。</p>
<h1 id="0X03-开启"><a href="#0X03-开启" class="headerlink" title="0X03 开启"></a>0X03 开启</h1><p>通常来说开启MySQL慢查询日志记录的方式有两种：直接改配置文件和修改全局变量。</p>
<p>改配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; ON     # 开始记录慢查询日志</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log     # 慢查询日志的位置</span><br><span class="line">long_query_time &#x3D; 1     # 对“慢”的定义，这里是耗时超过1s       蛤？这很暴力吗？</span><br></pre></td></tr></table></figure>
<p>修改配置文件的好处在于不论怎么重启数据库服务，这项配置都是存在的；缺点在于想让其生效需要重启一次数据库才行。</p>
<p>改全局变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log&#x3D;&#39;ON&#39;;  &#x2F;&#x2F; 打开慢查询记录</span><br><span class="line"></span><br><span class="line">mysql&gt; set global slow_query_log_file&#x3D;&#39;&#x2F;home&#x2F;shawn&#x2F;slow_query.log&#39;;     &#x2F;&#x2F; 慢查询日志的位置（我乱写的，不建议写在自己的$HOME下）</span><br><span class="line"></span><br><span class="line">mysql&gt; set global long_query_time&#x3D;1;    &#x2F;&#x2F; 还是1s</span><br></pre></td></tr></table></figure>
<p>修改全局变量的优势和缺点正好与上面相反，能立即生效但是重启会失效。</p>
<h1 id="0X04-使用"><a href="#0X04-使用" class="headerlink" title="0X04 使用"></a>0X04 使用</h1><p>我们来检查一下这个是不是配置好了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> ~/Workstadion/blog  master ?1  mycli -h 127.0.0.1 -uroot</span><br><span class="line">Password: </span><br><span class="line">mysql 5.7.17</span><br><span class="line">mycli 1.19.0</span><br><span class="line">Chat: https://gitter.im/dbcli/mycli</span><br><span class="line">Mail: https://groups.google.com/forum/<span class="comment">#!forum/mycli-users</span></span><br><span class="line">Home: http://mycli.net</span><br><span class="line">Thanks to the contributor - Ryan Smith</span><br><span class="line">mysql root@127.0.0.1:(none)&gt; show variables like <span class="string">&#x27;slow_query%&#x27;</span>;                                                                                                   </span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_query_log      | ON                                   |</span><br><span class="line">| slow_query_log_file | /home/shawn/slow.log                 |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line">Time: 0.042s</span><br><span class="line">mysql root@127.0.0.1:(none)&gt; show variables like <span class="string">&#x27;long_query_time&#x27;</span>;                                                                                               </span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 1.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line">Time: 0.035s</span><br></pre></td></tr></table></figure>

<p>现在看起来我们的慢查询日志就搞好了，开始试一试真正意义上的慢查询呢<code>SELECT SLEEP(5)</code>。其实这是个没有意义的查询（不太好拿测试数据出来给大家展示），不过没关系了，因为它会很扎实得等5s，满足我们对“慢查询”的认知了。</p>
<p>然后去看看我们的日志呢，可以看到如下输出，就没有问题了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@1971e980abad:&#x2F;var&#x2F;lib&#x2F;mysql# tail -f 1971e980abad-slow.log </span><br><span class="line">mysqld, Version: 5.7.17 (MySQL Community Server (GPL)). started with:</span><br><span class="line">Tcp port: 3306  Unix socket: &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br><span class="line">Time                 Id Command    Argument</span><br><span class="line"># Time: 2019-11-03T12:47:41.827832Z</span><br><span class="line"># User@Host: root[root] @  [172.17.0.1]  Id:    14</span><br><span class="line"># Query_time: 12.000459  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0</span><br><span class="line">SET timestamp&#x3D;1572785261;</span><br><span class="line">select sleep(12);</span><br></pre></td></tr></table></figure>

<p>这时候就可以将慢查询日志的时间设置成一个合理的值，然后就可以静待生产环境或者测试环境打一大堆log出来喽。我们可以看到每个超出我们定义的时长的SQL和其耗时，当日志累计起来我们就可以从耗时最长的或者出现最频繁的开始优化SQL了。</p>
<p>当然，有很多第三方的慢查询日志分析工具可以帮助我们，不过我这种初级MySQL用户遇到的也还不太需要。每次的慢查询日志自己搞下来逐行看一看总结一下规律也就能找到问题所在啦。如果后面日志越来越多越来越复杂的时候再考虑用第三方工具吧~</p>
<blockquote>
<p>这里连接MySQL用的不是mysql的官方命令行工具，而是一个Python编写的叫做<code>mycli</code>的工具。这个工具实现了<code>mysql</code>命令的几乎所有功能，并且支持语法高亮与自动补全，使用体验非常棒。可以直接用<code>pip install mycli --user</code>安装</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Linux桌面下活得舒服]]></title>
      <url>/2019/11/02/better-linux/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>这篇博客的目标读者：正在使用Linux桌面，打算长期继续使用下去的同学（这也就意味着熟悉Linux下的基础操作，理解Linux下的常见概念）。</p>
<p>这里有一个我之前写的“<a href="https://blog.just666.com/2019/10/29/use-linux/">在Linux桌面下存活</a>”可以参考一下。</p>
<h1 id="0X01-颜值就是战斗力"><a href="#0X01-颜值就是战斗力" class="headerlink" title="0X01 颜值就是战斗力"></a>0X01 颜值就是战斗力</h1><p><strong>Linux也不都是黑色背景白色字的命令行。</strong></p>
<p>首先要换的就是一套主题和图标，不论是KDE、Gnome还是Xfce都可以在对应的网站找到大量的主题，简单换过图标和主题之后再配合一张好看的壁纸，整个观感立马就好了不少。</p>
<blockquote>
<p>KDE: <a href="https://store.kde.org/">https://store.kde.org/</a><br>Gnome: <a href="https://www.gnome-look.org/">https://www.gnome-look.org/</a><br>Xfce: <a href="https://www.xfce-look.org/">https://www.xfce-look.org/</a></p>
</blockquote>
<p>然后要换的就是字体了，<a href="https://zh.wikipedia.org/zh-hans/%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93">等宽字体</a>我推荐这几个<a href="https://sourcefoundry.org/hack/">Hack</a>、<a href="https://github.com/adobe-fonts/source-code-pro">Source Code Pro</a>、<a href="https://github.com/microsoft/cascadia-code">Cascadia Code</a>都很好看，适合在终端、IDE和编辑器里使用。</p>
<p>最后就是zsh主题，如果使用的是zsh的话推荐使用<a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a>这个主题，是由<a href="https://github.com/Powerlevel9k/powerlevel9k">powerlevel9k</a>发展而来的，但是速度比<code>powerlevel9k</code>快好多。</p>
<h1 id="0X02-善用alias和bash函数"><a href="#0X02-善用alias和bash函数" class="headerlink" title="0X02 善用alias和bash函数"></a>0X02 善用alias和bash函数</h1><p>相信大家在初学Linux的时候都学过<code>alias</code>指令，没学过的话我简单介绍一句：“alias是给命令取别名的工具，例如执行<code>alias new_ls=&quot;ls -l&quot;</code>过后再使用<code>new_ls</code>命令就和使用<code>ls -l</code>一样了”。</p>
<p>首先我们知道将<code>alias</code>命令直接写在shell里，在关闭重开shell之后就失效了（起码现在知道了）。所以我们要把<code>alias</code>写在<code>.bashrc</code>或者<code>.zshrc</code>中（依你使用的shell而定）。现在我的<code>.zshrc</code>中就有很多已经写好了的，下面给大家分项几个对大家都有用的</p>
<a id="more"></a>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alias for simple command</span></span><br><span class="line"><span class="built_in">alias</span> f=<span class="string">&#x27;open .&#x27;</span>    <span class="comment"># 用图形文件管理器打开当前目录</span></span><br><span class="line"><span class="built_in">alias</span> h=<span class="string">&#x27;open ~&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> py=<span class="string">&#x27;ipython3&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> py2=<span class="string">&#x27;ipython2&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> du=<span class="string">&#x27;/usr/bin/ncdu&#x27;</span>    <span class="comment"># ncdu是一个命令行里可视化查看磁盘（目录）占用率的工具</span></span><br><span class="line"><span class="built_in">alias</span> cat=<span class="string">&#x27;/usr/bin/bat&#x27;</span>    <span class="comment"># bat是一个带语法高亮、行号显示且能够上下滚动的cat加强版</span></span><br><span class="line"><span class="built_in">alias</span> down=<span class="string">&#x27;aria2c -x16 -j4&#x27;</span>    <span class="comment"># 使用aria2进行多线程下载</span></span><br><span class="line"><span class="built_in">alias</span> me=<span class="string">&quot;cd <span class="variable">$HOME</span>/Workstadion/ &amp;&amp; ls&quot;</span></span><br><span class="line"><span class="built_in">alias</span> connect_android=<span class="string">&quot;scrcpy --bit-rate 256M&quot;</span>  <span class="comment"># 使用scrcpy连接到接入电脑的Android手机</span></span><br><span class="line"><span class="built_in">alias</span> code=<span class="string">&#x27;LANG=&quot;zh_CN.UTF-8&quot; LANGUAGE=&quot;zh_CN.UTF-8&quot; code&#x27;</span>     <span class="comment"># 用VSCode打开</span></span><br><span class="line"><span class="built_in">alias</span> jwt=<span class="string">&quot;python3 <span class="variable">$HOME</span>/Workstadion/script/get_token.py jwt&quot;</span>   <span class="comment"># 自己编写的方便获取开发环境jwt token的工具</span></span><br><span class="line"><span class="built_in">alias</span> token=<span class="string">&quot;python3 <span class="variable">$HOME</span>/Workstadion/script/get_token.py token&quot;</span></span><br><span class="line"><span class="built_in">alias</span> open=<span class="string">&#x27;LANG=&quot;zh_CN.UTF-8&quot; xdg-open &gt; /dev/null 2&gt; /dev/null&#x27;</span>   <span class="comment"># 使用对应的工具打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alias to source command   # 映射到原始工具</span></span><br><span class="line"><span class="built_in">alias</span> _du=<span class="string">&#x27;/usr/bin/du&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> _cat=<span class="string">&#x27;/usr/bin/cat&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alias some command for network and proxy  # 使用代理做一些事情</span></span><br><span class="line"><span class="built_in">alias</span> use_proxy=<span class="string">&quot;ALL_PROXY=socks5://127.0.0.1:1080&quot;</span></span><br><span class="line"><span class="built_in">alias</span> git_clone_with_proxy=<span class="string">&quot;ALL_PROXY=socks5://127.0.0.1:1080 git clone&quot;</span></span><br><span class="line"><span class="built_in">alias</span> yay_with_proxy=<span class="string">&quot;ALL_PROXY=socks5://127.0.0.1:1080 yay&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>alias</code>的功能还是比较单一，毕竟从“别名”这个名字上就看出来了。不过好在还可以写函数，写函数这就是我们程序员比较擅长的了。这里简单介绍（真的超简单的那种）一下<code>Bash</code>的函数（当然<code>zsh</code>也是兼容的）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="comment"># xxxxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个函数的基本结构了，再配合参数：<code>$0  $1  $2  $3</code>这种就足够搞一些特别简单的函数了。我们一段命令如果前面固定后面是变动的那么可以方便得用<code>alias</code>比如：<code>docker-compose up -d web</code>和<code>docker-compose up -d test</code>这种就可以将前半部分搞成<code>alias</code>再拼起来用比如<code>alias dp-up-d=&quot;docker-compose up -d&quot;</code>然后<code>dp-up-d web</code>就可以了。但是如果是<code>grep -Rn &quot;hello&quot; ~/articles</code>和<code>grep -Rn &quot;world&quot; ~/article</code>这种呢就比较麻烦，这时候就要用函数了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">grep_this</span></span>() &#123;</span><br><span class="line">    grep -Rn <span class="string">&quot;<span class="variable">$1</span>&quot;</span> .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数就可以通过<code>grep_this hello</code>来执行<code>grep -Rn &quot;hello&quot; .</code>这个命令。其中的参数：<code>$0</code>和<code>$1</code>指的就是整个命令用空格分隔之后的下标，例如<code>$1</code>指的就是整条命令用空格分隔后，下标为1的值，这里的实例函数也就是指的”hello”了。</p>
<p>这里给大家复制几条我自己的配置，可能是大家都用的到的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># v2er translate    # v2ex一老哥搞的词典api，直接用`v2 hello`就可以查到hello的中文（支持中英互转）</span></span><br><span class="line"><span class="function"><span class="title">v2</span></span>() &#123;</span><br><span class="line">  <span class="built_in">declare</span> q=<span class="string">&quot;$*&quot;</span></span><br><span class="line">  curl --user-agent curl <span class="string">&quot;https://v2en.co/<span class="variable">$&#123;q// /%20&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker    # 使用`attach mysql`可以接入到含有mysql的行的docker容器的bash中（当有且仅有一个grep结果时才有效，有兴趣的老哥可以自行修改）</span></span><br><span class="line"><span class="function"><span class="title">attach</span></span>() &#123;</span><br><span class="line">  docker <span class="built_in">exec</span> -it `docker ps | grep $* | awk -F <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>` bash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">attach_django</span></span>() &#123;</span><br><span class="line">  docker <span class="built_in">exec</span> -it `docker ps | grep $* | awk -F <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>` python manage.py shell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">grep_this</span></span>() &#123;   <span class="comment"># `grep_this test`从当前目录递归找下去，将所有含有test的文本文件的行都输出出来</span></span><br><span class="line">  grep -Rn <span class="string">&quot;<span class="variable">$1</span>&quot;</span> .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">find_this</span></span>() &#123;   <span class="comment"># `find_this test`递归当前目录找到路径含test的</span></span><br><span class="line">  find . -name \*<span class="variable">$1</span>\*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0X03-本地服务尽量Docker化"><a href="#0X03-本地服务尽量Docker化" class="headerlink" title="0X03 本地服务尽量Docker化"></a>0X03 本地服务尽量Docker化</h1><p>传统方式我们都是将本地开发所依赖的服务例如：MySQL和Redis这种直接部署一份。但是其实这种部署方式在开发环境是不太好的，强烈建议使用Docker部署。如果你同时要用3个MySQL版本，3个Redis版本，这只还要用5个Mongo版本，那怕不是要疯了对吧。</p>
<p>首先我们搞一个<code>docker</code>再搞一个<code>docker-compose</code>然后开始尝试部署环境（docker和docker-compose的安装这里就不说了）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:latest</span><br><span class="line">    container_name: dev_mysql</span><br><span class="line">    network_mode: bridge</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/mysql:/var/lib/mysql</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=你的密码</span><br><span class="line">    <span class="built_in">command</span>: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    container_name: dev_redis</span><br><span class="line">    network_mode: bridge</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line"></span><br><span class="line">  mongo:</span><br><span class="line">    image: mongo:latest</span><br><span class="line">    container_name: dev_mongo</span><br><span class="line">    network_mode: bridge</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;27017:27017&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/mongo:/var/lib/mongo</span><br></pre></td></tr></table></figure>

<p>我们将内容保存为<code>docker-compose.yml</code>，并放到一个空目录下开始一波复杂的操作：首先执行<code>docker-compose up -d</code>，然后等一会儿，等拉完这三个镜像，接下来。。。。。。就好了（是的，这就好了）。这样你就在本地部署了<code>MySQL+Redis+Mongo</code>并且都是最新的版本，如果需要不同的版本可以这个样子</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:latest</span><br><span class="line">    container_name: dev_mysql</span><br><span class="line">    network_mode: bridge</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/mysql:/var/lib/mysql</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=你的密码</span><br><span class="line">    <span class="built_in">command</span>: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">    </span><br><span class="line">  mysql_old:</span><br><span class="line">    image: mysql:5.7.17</span><br><span class="line">    container_name: dev_mysql</span><br><span class="line">    network_mode: bridge</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/mysql:/var/lib/mysql</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=你的密码</span><br><span class="line">    <span class="built_in">command</span>: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>

<p>这时候用<code>docker-compose up -d mysql</code>和<code>docker-compose up -d mysql_old</code>就可以启动相应的版本了。</p>
<p><strong>注意</strong></p>
<blockquote>
<ol>
<li>这里展示只是改了版本，不过改了版本的话数据文件的映射一定要改，要不然两个不同版本的MySQL用同一套数据文件会出问题的</li>
<li>这里展示只是用了最简单的配置，除了MySQL其他的服务甚至没有密码，即使是开发欢迎也要<strong>注意数据安全</strong></li>
<li>如果需要更深度的自定义每个服务就需要取看对应镜像和服务的官方文档了</li>
</ol>
</blockquote>
<p>事实上我还用Docker部署过FTP方便同事的不同操作系统间快速传递文件，所以大大小小的服务只要想得到都可以用Docker来部署，不仅方便还能降低搞坏了的风险。</p>
<h1 id="0X03-一个Py的小操作"><a href="#0X03-一个Py的小操作" class="headerlink" title="0X03 一个Py的小操作"></a>0X03 一个Py的小操作</h1><p>现在有歌场景：你同事想从你电脑上搞个文件过去，该怎么搞？当然这有很多方法，但是有一个是非常简单快速的：找到你文件所在的目录<code>python3 -m http.server 2333</code>然后把<code>http://ip:2333</code>发给你的同事就好了。是的你没看错，用一行命令就启动了一个临时的web服务器。</p>
<p>这个操作应用场景也很多：你通过跳板机到服务器上导出了个数据，因为用的跳板机所以不能scp，那这时候<code>http.server</code>就是个好办法；甚至我还临时用这个命令给同事提供过<a href="https://github.com/kasuganosoras/cxk-ball">CXK打球</a>的游戏呢哈哈哈。</p>
<h1 id="0X04-zsh没插件就像喝酒没酒精"><a href="#0X04-zsh没插件就像喝酒没酒精" class="headerlink" title="0X04 zsh没插件就像喝酒没酒精"></a>0X04 zsh没插件就像喝酒没酒精</h1><p><code>zsh</code>作为一个所谓的“终极Shell”，支持的插件是非常非常多的。这里给大家看看我正在用的插件，配置文件是<code>~/.zshrc</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">    z</span><br><span class="line">    git</span><br><span class="line">    fabric</span><br><span class="line">    extract</span><br><span class="line">    thefuck</span><br><span class="line">    fzf-zsh</span><br><span class="line">    git-open</span><br><span class="line">    virtualenvwrapper</span><br><span class="line">    colored-man-pages</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里挑几个介绍一下</p>
<h2 id="z"><a href="#z" class="headerlink" title="z"></a>z</h2><p>我们在Linux下最常用的可能就是<code>cd</code>了，<code>z</code>配合<code>zsh</code>的原生功能可以让我们不再需要<code>cd</code>。比如我们经常去<code>~/Workstadion/too_young/simple</code>这个目录，那么以后就可以直接<code>z simple</code>跳过去了。其实是这样，你可以在终端直接用<code>z</code>来查看当前各个目录的权重，<code>z</code>命令就是从权重最高开始找，直到找到对应的目录并跳转过去。</p>
<p>另外我说的<code>zsh</code>原生功能是指：默认就是cd。比如我们在<code>zsh</code>中直接输入<code>/</code>就会跳到根目录，直接<code>..</code>就是上级，直接<code>~/Workstadion</code>就是对应的目录，省下了<code>cd</code>的过程</p>
<h2 id="fabric"><a href="#fabric" class="headerlink" title="fabric"></a>fabric</h2><p>如果你用<code>fabric</code>的话，在<code>fabfile.py</code>存在的目录下输入<code>fab </code>再tab就可以补全<code>fabric</code>中的命令</p>
<h2 id="extract"><a href="#extract" class="headerlink" title="extract"></a>extract</h2><p>我们知道解压<code>zip</code>要用<code>unzip</code>，解压<code>rar</code>要用<code>unrar</code>，解压<code>tar.gz</code>要用<code>tar -zxvf</code>……知道是知道了，但是每次用起来还是有点麻烦，所以有了这个插件。不管你是啥<code>tar.gz/tar.xz/tar.bz2/zip/rar</code>，统统一个<code>x</code>全部解压。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x qwer.zip</span><br><span class="line">x asdf.rar</span><br><span class="line">x zxcv.tar.gz</span><br><span class="line">x qwer.tar.xz</span><br></pre></td></tr></table></figure>

<h2 id="thefuck"><a href="#thefuck" class="headerlink" title="thefuck"></a>thefuck</h2><p>顾名思义，当你想吼<code>fxxk</code>的时候，这个插件就有用了。<code>thefuck</code>是一个python程序，要用<code>pip install thefuck --user</code>来安装。装好之后再配合上这个插件就可以实现神奇的效果。比如当你在命令行里输入了一长串命令<code>git commmt -m &quot;feat: 新增了什么鬼的需求点&quot;</code>，显然前面的<code>commit</code>拼错了，如果是以前的话就只有返回去改。这时候就很想大吼<code>fxxk</code>了，但是请淡定。双击一下你的ESC键，会发现你的命令已经被自动修正并写在命令行里了。</p>
<p>是的，这个<code>thefuck</code>就是自动修复写错的命令的工具。</p>
<h2 id="zsh-autosuggestions和zsh-syntax-highlighting"><a href="#zsh-autosuggestions和zsh-syntax-highlighting" class="headerlink" title="zsh-autosuggestions和zsh-syntax-highlighting"></a>zsh-autosuggestions和zsh-syntax-highlighting</h2><p>这两个都是需要手动安装的，可以去GitHub上搜一下，很简单。分别是实时提示命令的正确性和预先提示类似的历史命令的</p>
<h2 id="一句话介绍其他的："><a href="#一句话介绍其他的：" class="headerlink" title="一句话介绍其他的："></a>一句话介绍其他的：</h2><ol>
<li>git 是一堆现成的git的<code>alias</code></li>
<li>fzf-zsh 需要先安装<code>fzf</code>。在命令行里按下Ctrl+R，用新的逆向搜索替换原来不好用的老式搜索</li>
<li>git-open 用浏览器打开当前git仓库：支持GitHub和GitLab</li>
<li>colored-man-pages 彩色高亮的man</li>
</ol>
<h1 id="0X05-好像没啥了"><a href="#0X05-好像没啥了" class="headerlink" title="0X05 好像没啥了"></a>0X05 好像没啥了</h1><p>一时半会也想不到有什么要补充的了，等什么时候想到新的了再搞吧。祝大家生活工作愉快~</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Linux桌面下存活]]></title>
      <url>/2019/10/29/use-linux/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>这篇博客的目标读者：有Linux使用基础，打算使用Linux作为桌面系统的人（这也就意味着熟悉Linux下的基础操作，理解Linux下的常见概念）。</p>
<p>注：这篇博客不讨论不对比Linux/Windows/MacOS等不同的操作系统。</p>
<h1 id="0X01-首先选择一个发行版本"><a href="#0X01-首先选择一个发行版本" class="headerlink" title="0X01 首先选择一个发行版本"></a>0X01 首先选择一个发行版本</h1><p>众所周知Linux是一个内核，在这个内核基础上有很多发行版本例如：Archlinux、Manjaro、Ubuntu、Deepin、Debian、openSUSE、Fedora等等。那我们首先要选择一个来安装到自己电脑上。</p>
<p>基于我自己的使用体验比较推荐使用的是：Manjaro、Ubuntu、Deepin这三个，他们共同的优点是：适合初次使用Linux桌面的人。</p>
<h2 id="Manjaro"><a href="#Manjaro" class="headerlink" title="Manjaro"></a>Manjaro</h2><p>基于Archlinux，滚动更新。该发行版本最大的特点是软件版本紧跟最新，而且由于是滚动更新所以不用像多数系统一样隔一段时间来一次大版本更新。只要按照系统提示进行常规系统升级就可以将整个系统一直保持在最新的状态。</p>
<p>Manjaro能够使用Archlinux的AUR软件仓库，算是软件仓库最丰富的发行版本之一了，很多其他系统要操作很多步骤才能装好的软件在Manjaro下一个命令就能装好。</p>
<p>另一个优势是可以使用ArchWIKI，很多问题在WIKI里都有详细的解释。</p>
<p>而Manjaro的缺点也是有的，例如用户群体还是不够大。如果你电脑出现了点问题，那么极有可能你的同事和朋友都没有用过这个操作系统，只有一点点在网上找解决方案。如果是Ubuntu的话可能好多人都用过，可以给你一些提示或者建议。</p>
<a id="more"></a>

<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>Ubuntu是基于Debian的发行版本，应该是目前用户数量最庞大的Linux桌面发行版本了。最大的优势也是上述的用户足够多，几乎你遇到的一切问题都会有人遇到过，网上一搜几本就有答案了。</p>
<p>缺点就是跟Manjaro比起来软件比较少，倒不是不能安装而是装起来可能更麻烦一点。还有就是据说Ubuntu的图形界面会无缘无故挂掉，不知道现在的情况是怎么样了。</p>
<p>注：Ubuntu的版本号为xx.04和xx.10两个，例如”14.04/14.10/15.04/15.10/16.04/16.10”这种，代表的意思是“发布的年份.发布的月份”。Ubuntu每年4月和6月会发布新的版本，然后偶数年发布的是LTS也就是长期支持版。所以建议使用最大的偶数年的四月份版本，目前来说的话就是18.04。</p>
<h2 id="Deepin"><a href="#Deepin" class="headerlink" title="Deepin"></a>Deepin</h2><p>Deepin是基于Ubuntu的发行版本，是国内的一个团队在维护的。界面比较漂亮，又由于是国内团队维护的系统所以集成了一些常用的Windows软件例如：微信、QQ这种。通常来说在Linux上运行Windows程序还是有点麻烦的，尤其是完美运行，所以Deepin做的这个工作是非常值得肯定的。尤其适合初次使用Linux桌面的人。</p>
<p>而且Deepin有很多优秀的高质量的自研软件，例如深度音乐、深度影院、深度终端等，不仅好用而且好看。</p>
<p>仍然是因为国产的原因，开发团队设计团队都是中国人，用户群体也很多中国人，所以有一个维护的很棒的中文论坛，方便大家交流问题。</p>
<p>注：Deepin即将发布V20版本，值得期待</p>
<blockquote>
<p>Archlinux并非不好，只是安装起来比较麻烦，而且有N卡独立显卡的话驱动也是一个问题，不是很适合新手使用，如果不在乎这些的话Archlinux则是一个更棒的发行版本；<br>openSUSE并非不好，只是国内的用户太少了，而且给openSUSE打包的程序也不多，不过据说openSUSE的KDE调教很棒。如果不太在乎这些的话openSUSE也是非常棒的发行版本；<br>Fedora并非不好，只是更新太快了，半年就有一个大更新。而且作为红帽系列的发行版本，相对来说提供的软件包也比较少。如果能接收半年一个大版本并且一年就不再对旧版本提供支持的话，Fedora也不失为一个好发行版本（实际上我自己也用过大概一年）；<br>LinuxMint等等也并非不好，有些我自己也没有体验过，再有些确实不太适合新手使用这里也就不再一一列出；</p>
</blockquote>
<p><strong>有一点要注意的是：尽可能不要使用极小众的发行版本在生产电脑上，因为一旦出问题可能很难解决。</strong></p>
<h1 id="0X02-然后选择一个桌面环境"><a href="#0X02-然后选择一个桌面环境" class="headerlink" title="0X02 然后选择一个桌面环境"></a>0X02 然后选择一个桌面环境</h1><p>桌面环境简称DE，在Windows上我们只有一个可选，在MacOS上同样只有一个可选，但是Linux上我们有非常多的选择，主流的就有：KDE、Gnome、dde、Xfce、i3等。那么我们应该怎么选呢？</p>
<p>首先使用Linux桌面有一个准则（我自己认为的，不一定所有人都认同）：尽可能少的调整你的桌面，所以我们尽可能使用原生的桌面样子。因为Linux桌面环境并没有Windows和MacOS那么稳定，所以越多的修改就意味着越多的不稳定。而且由于Linux桌面允许极高程度的自定义，初次使用很容易掉到“美化桌面”的坑里。</p>
<p>综合来说我目前推荐的三个DE是：KDE、Gnome、Xfce、dde</p>
<h2 id="KDE"><a href="#KDE" class="headerlink" title="KDE"></a>KDE</h2><p>自从KDE5之后，KDE就变得非常非常棒了，也正是我现在使用的桌面环境。整体设计风格比较统一，也比较漂亮。KDE的默认桌面初看起来有点像Windows（可能就是因为下面的“任务栏”吧）</p>
<h2 id="Gnome"><a href="#Gnome" class="headerlink" title="Gnome"></a>Gnome</h2><p>Gnome与KDE一起位居Linux桌面环境市场的前两名。与KDE不同，Gnome的设计初看起来有点像MacOS（应该是因为顶部的“Topbar”）</p>
<h2 id="Xfce"><a href="#Xfce" class="headerlink" title="Xfce"></a>Xfce</h2><p>Xfce的最大特点就是简洁高效。我记得之前使用Xfce的时候开机默认才使用不到500M的内存。总之Xfce就是那种简单的，不华丽的高效的桌面环境。</p>
<h2 id="dde"><a href="#dde" class="headerlink" title="dde"></a>dde</h2><p>dde是Deepin团队的作品，风格与以往不同，我也不太会说，可以去官网看一下具体的。</p>
<h2 id="如何选择呢？"><a href="#如何选择呢？" class="headerlink" title="如何选择呢？"></a>如何选择呢？</h2><p>实际上操作系统和DE是完全剥离的，不过我们既然是新手就最好使用官方自带的或者直接支持的，防止出现意外对吧。其中Manjaro官方支持最多：同时提供了KDE、Gnome和Xfce的安装镜像，又由社区提供了dde的版本；Ubuntu官方使用Gnome，但有社区提供的kUbuntu使用KDE和xUbuntu使用Xfce；Deepin的话就使用dde，使用其他DE的话会使Deepin丧失优势（Deepin里很多官方提供的Windows程序在非dde桌面下支持并不好）。</p>
<p>现在操作系统和DE已经对应好了，可以选择一个自己喜欢的组合了。选好之后可以先搞一个虚拟机来体验一下，觉得不错的话就来装系统吧。</p>
<h1 id="0X03-软件部分"><a href="#0X03-软件部分" class="headerlink" title="0X03 软件部分"></a>0X03 软件部分</h1><p>都已经打算使用Linux作为桌面系统了，那应该很清楚Windows、MacOS、Linux的二进制文件是不互通的吧。所以有可能你在Windows、MacOS中使用的程序在Linux下并没有。当然，这也是目前Linux桌面的最大瓶颈（我自己这么认为）。</p>
<p>不过也不用过分担心，我们常用的工具比如：Chrome、Firefox、PyCharm（IDEA等Jetbrains家所有IDE）、Postman、VScode等还是原生支持的，甚至比其他系统有更好的体验。接下来主要介绍一些那些没有的软件的替代方案</p>
<h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>输入法在Linux下是有一个搜狗的，不过我不喜欢，大家有兴趣可以搜索一下尝试尝试。如果不用搜狗的话我个人比较推荐两个：sunpinyin和Rime。其中sumpinyin几乎是所有Linux都带的，选好就能用；Rime是一个开源输入法，使用门槛稍高，但是我觉得更好用。</p>
<h2 id="梯子"><a href="#梯子" class="headerlink" title="梯子"></a>梯子</h2><p>我自己是使用的v2ray作为梯子，在Linux下很容易就能装好。如果是用ssr的可能会比较麻烦，虽然有ssr的解决方案但是我没用过不太好说。ss倒是简单，可以搜索安装一个<code>shadowsocks-qt5</code>的图形工具，就可以正常使用了。</p>
<blockquote>
<p>Linux下一般梯子都是一个独立的服务，需要在浏览器上配置代理。不论是Chrome还是Firefox都推荐使用<code>switchomega</code>这个扩展来配置浏览器代理</p>
</blockquote>
<h2 id="影音播放"><a href="#影音播放" class="headerlink" title="影音播放"></a>影音播放</h2><p>Linux下本地视频播放器两个大佬：mpv和VLC。其中VLC开箱即用，简单粗暴；mpv则是异常简单，想要使用高级功能？麻烦您自己编写配置文件。所以可以见得如果对播放器自定义要求很高的话建议使用mpv或者如果没有什么要求也能用mpv，否则vlc更合适。</p>
<p>当然这两个播放器都贼厉害，没有说谁好谁坏。</p>
<p>本地音频播放器我用的是<code>deadbeef</code>，简单、好看、好用。在线播放器的话，网易云音乐是提供官方Linux客户端的。</p>
<h2 id="Office"><a href="#Office" class="headerlink" title="Office"></a>Office</h2><p>这里我只想说<code>&quot;金山NB！&quot; * 100</code>。金山公司搞的<code>wps-office</code>是提供官方Linux版本的，对Office支持度非常高，轻度使用的话能替换掉MS-Office了。如果对开源比较敏感的话，可以使用<code>libreoffice</code>，是开源的。</p>
<h2 id="终端模拟器"><a href="#终端模拟器" class="headerlink" title="终端模拟器"></a>终端模拟器</h2><p>MacOS的用户应该知道<code>iTerm2</code>，Linux中优秀的终端模拟器层出不穷，不过我最推荐的还是<code>terminator</code>。不仅可以轻松的分多个tab，还可以在每个tab中左右上下分栏。再配合一个好看的<code>zsh</code>主题、<code>hack</code>字体、自己喜欢的配色，简直找不到任何缺点。</p>
<h2 id="virtualbox"><a href="#virtualbox" class="headerlink" title="virtualbox"></a>virtualbox</h2><p>虚拟机是不得已的方案，毕竟有时候要用的程序真的在Linux下没有替代方案，所以我选择用一个开源的虚拟机工具<code>virtualbox</code>来应对不时之需。</p>
<h1 id="0X04-最后"><a href="#0X04-最后" class="headerlink" title="0X04 最后"></a>0X04 最后</h1><p>我个人觉得Linux是一个非常有魅力的操作系统，虽然它的桌面还不够好，学习成本也比较高。但是就像Vim一样，当你越过鸿沟之后会发现另一个世界。到现在位置我使用Linux桌面已经两年多了，目前对自己的所用的系统非常满意。系统信息、桌面环境和主题们如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">██████████████████  ████████   shawn@T480 </span><br><span class="line">██████████████████  ████████   ---------- </span><br><span class="line">██████████████████  ████████   OS: Manjaro Linux x86_64 </span><br><span class="line">██████████████████  ████████   Host: 20L5A027HK ThinkPad T480 </span><br><span class="line">████████            ████████   Kernel: 4.19.79-1-MANJARO </span><br><span class="line">████████  ████████  ████████   Uptime: 12 hours, 23 mins </span><br><span class="line">████████  ████████  ████████   Packages: 1374 (pacman) </span><br><span class="line">████████  ████████  ████████   Shell: zsh 5.7.1 </span><br><span class="line">████████  ████████  ████████   Resolution: 2560x1440 </span><br><span class="line">████████  ████████  ████████   DE: Plasma </span><br><span class="line">████████  ████████  ████████   WM: KWin </span><br><span class="line">████████  ████████  ████████   WM Theme: Materia-Manjaro </span><br><span class="line">████████  ████████  ████████   Theme: Breath-Dark [GTK2&#x2F;3] </span><br><span class="line">████████  ████████  ████████   Icons: Tela-dark [GTK2&#x2F;3] </span><br><span class="line">                               Terminal: terminator </span><br><span class="line">                               CPU: Intel i7-8550U (8) @ 4.000GHz </span><br><span class="line">                               GPU: Intel UHD Graphics 620 </span><br><span class="line">                               GPU: NVIDIA GeForce MX150 </span><br><span class="line">                               Memory: 14795MiB &#x2F; 32058MiB </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dockerfile中的COPY与ADD指令]]></title>
      <url>/2019/09/25/dockerfile-add-vs-copy/</url>
      <content type="html"><![CDATA[<h1 id="0X00-就算只有一节我也要写标题"><a href="#0X00-就算只有一节我也要写标题" class="headerlink" title="0X00 就算只有一节我也要写标题"></a>0X00 就算只有一节我也要写标题</h1><p>众所周知Dockerfile是构建Docker镜像的优良方式，而使用Dockerfile构建镜像最重要的就是为数不多的几个命令，而本次的主题<code>COPY</code>和<code>ADD</code>就是其中两个。我们知道这两个命令都是将文件搞到Docker镜像里用的，那究竟有没有区别，有什么区别呢？</p>
<p>首先我们看一下当前这个目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ  ~&#x2F;Workstadion&#x2F;learn_docker  ls</span><br><span class="line">Dockerfile  excited.tar</span><br></pre></td></tr></table></figure>

<p>我们有着么一个Dockerfile，可以看到是基于<code>fedora</code>的一个镜像，并且将目录下的<code>excited.tar</code>放进了创建好的<code>shawn</code>目录中</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> fedora</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir shawn</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> shawn</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> excited.tar .</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到工作目录下已经存在了一个<code>excited.tar</code>了，也就意味着我们成功将这个文件搞进去了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ  ~&#x2F;Workstadion&#x2F;learn_docker  docker build . -t wtf ; docker rm learn_docker; docker run --name learn_docker -it wtf bash</span><br><span class="line">Sending build context to Docker daemon  23.04kB</span><br><span class="line">Step 1&#x2F;4 : FROM fedora</span><br><span class="line"> ---&gt; e9ed59d2baf7</span><br><span class="line">Step 2&#x2F;4 : RUN mkdir shawn</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5014855b8533</span><br><span class="line">Step 3&#x2F;4 : WORKDIR shawn</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 82f9d06a4d3c</span><br><span class="line">Step 4&#x2F;4 : COPY excited.tar .</span><br><span class="line"> ---&gt; 1bc293d81b33</span><br><span class="line">Successfully built 1bc293d81b33</span><br><span class="line">Successfully tagged wtf:latest</span><br><span class="line">learn_docker</span><br><span class="line">[root@f6a4f34ed504 shawn]# ls -l</span><br><span class="line">total 20</span><br><span class="line">-rw-r--r-- 1 root root 20480 Sep 25 14:15 excited.tar</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果同样的操作用<code>ADD</code>呢？看上去是类似的操作实际上并不是</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> fedora</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir shawn</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> shawn</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> excited.tar .</span></span><br></pre></td></tr></table></figure>
<p>我们进到容器里可以看到打包文件被拆解了（压缩文件也会被解压）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">λ  ~&#x2F;Workstadion&#x2F;learn_docker  docker build . -t wtf ; docker rm learn_docker; docker run --name learn_docker -it wtf bash</span><br><span class="line">Sending build context to Docker daemon  23.04kB</span><br><span class="line">Step 1&#x2F;4 : FROM fedora</span><br><span class="line"> ---&gt; e9ed59d2baf7</span><br><span class="line">Step 2&#x2F;4 : RUN mkdir shawn</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5014855b8533</span><br><span class="line">Step 3&#x2F;4 : WORKDIR shawn</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 82f9d06a4d3c</span><br><span class="line">Step 4&#x2F;4 : ADD excited.tar .</span><br><span class="line"> ---&gt; cc1d067d0dbe</span><br><span class="line">Successfully built cc1d067d0dbe</span><br><span class="line">Successfully tagged wtf:latest</span><br><span class="line">learn_docker</span><br><span class="line">[root@89276af7b0a2 shawn]# ls -l</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 2 1000 1000 4096 Sep 25 14:15 excited</span><br><span class="line">[root@89276af7b0a2 shawn]# cd excited&#x2F;</span><br><span class="line">[root@89276af7b0a2 excited]# ls</span><br><span class="line">file_0  file_10  file_12  file_14  file_16  file_18  file_2  file_4  file_6  file_8</span><br><span class="line">file_1  file_11  file_13  file_15  file_17  file_19  file_3  file_5  file_7  file_9</span><br></pre></td></tr></table></figure>

<p>其实不止这样，<code>ADD</code> 命令还能下载文件：<code>ADD https://too.young/too/simple.pdf /hello</code>就能将文件下载下来并且命名为<code>hello</code>；如果是<code>ADD https://too.young/too/simple.pdf /hello/</code>（只是最后多了斜杠），docker会认为你想将文件下载到<code>/hello</code>的目录下，如果没有他会自己创建；还有我们不是说<code>ADD</code>能下载文件还能解压文件吗，但是这两个又不能同时生效，意味着如果你想用<code>ADD https://too.young/too/simple.zip /sometimes/naive/</code>将下载好的<code>simple.zip</code>文件解压到<code>/sometimes/naive/</code>目录里是不行的，最后结果只是将压缩包下载到了那个目录而已。</p>
<p>总结来说的话就是 <strong><code>COPY</code>简简单单复制，<code>ADD</code>灵活多变</strong>。但是其实我们最好就直接用<code>COPY</code>命令，真的需要解压什么的操作多写一个管道符也没有多麻烦。而且其他人看管道符后面接命令参数要比分析<code>ADD</code>命令来的舒服得多。</p>
<p>算下来<code>ADD</code>能做的没有什么是<code>COPY</code>加管道做不了的。而且又加上<code>ADD</code>的结果变换多端，不管是自己写还是其他人看都很麻烦，所以说大家能不用<code>ADD</code>就不用了吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis入门使用：分库、认证与持久化]]></title>
      <url>/2019/09/19/ez-redis/</url>
      <content type="html"><![CDATA[<h1 id="0X00-Redis的分库"><a href="#0X00-Redis的分库" class="headerlink" title="0X00 Redis的分库"></a>0X00 Redis的分库</h1><p>使用过MySQL或者类似的数据库都应该知道，一个数据库内部是可以分成多个库的。比如MySQL从上到下是<code>MySQL service -&gt; database -&gt; table -&gt; field</code>，但是一开始使用redis的时候好像是没有database这一层的呢？其实是存在这么一层的，redis默认是存在编号0到15这总共16个库的，每个库除了命名空间不同以外都是相同的。也就是说在编号为0的库里<code>set name shawn</code>之后跑到编号为1的库里<code>get name</code>是拿不到的。</p>
<p>那这么说来这个分库究竟有什么用呢？其实很少用的到，甚至就连<code>redis</code>的<a href="https://groups.google.com/forum/#!msg/redis-db/vS5wX8X4Cjg/8ounBXitG4sJ">设计者自己都说搞这个是较蠢的操作</a>。我们日常用到的唯一一处地方就是在测试服务器上，因为一台机器部署了太多服务，而且每个服务又都要用redis所以就每个服务分开使用0~15这些数据库。</p>
<p>因为开一个完整redis实例的资源消耗本身就很小，所以分库这个操作就更显的不太用的到了，毕竟我们完全可以在一台机器上开多个redis实例从而实现相同的效果，而且又方便管理。</p>
<p>不过也还是简单介绍一下好了：<code>/etc/redis.conf</code>文件中的<code>databases</code>参数是设置redis实例具有多少个数据库的，如果真的需要的话可以修改这个参数然后重启redis从而生效。</p>
<a id="more"></a>

<p>那么怎么切换这些库呢？我们使用<code>redis-cli</code>连上数据库之后可以看到类似这么一个命令提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<p>这就意味着我们在操作0库，使用<code>select</code>指令可以切换库，切换后在命令行上会提示出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[2]&gt; select 6</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[6]&gt; select 15</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[15]&gt; select 16</span><br><span class="line">(error) ERR DB index is out of range</span><br><span class="line">127.0.0.1:6379[15]&gt;</span><br></pre></td></tr></table></figure>
<p>这里可以看到在默认情况下切到一个并不存在的库会报错。（真是一本正经的废话）</p>
<h1 id="0X01-Redis的认证"><a href="#0X01-Redis的认证" class="headerlink" title="0X01 Redis的认证"></a>0X01 Redis的认证</h1><p>redis的认证要比MySQL要简单的多，在MySQL中要配置用户名、密码甚至还要校验网段，不过redis中就只有一个简简单单的密码校验。而且是那种不需要用户名，仅有密码的校验。还有一点不同的就是，redis不支持设置多个密码。</p>
<p>在默认情况下redis刚刚装完是不需要认证直接使用的，设置密码有下面两种常用方式：</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改<code>/etc/redis.conf</code>配置文件，里面有一个<code>requirepass</code>参数，默认是加了注释的也就意味着并没有密码。如果要为其加上密码就将那一行改为<code>requirepass this_is_password</code>，然后使用类似<code>systemctl restart redis</code>的命令来重启一下你的redis服务，密码就生效了。</p>
<h2 id="执行redis命令"><a href="#执行redis命令" class="headerlink" title="执行redis命令"></a>执行redis命令</h2><p>另一种方法就是使用redis命令<code>config set</code>的方式来设置密码，这种方式好在不需要重启redis服务，但是默认情况下一旦重启密码也就跟着失效了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set requirepass this_is_password</span><br></pre></td></tr></table></figure>

<h2 id="认证登录"><a href="#认证登录" class="headerlink" title="认证登录"></a>认证登录</h2><p>那密码搞上了，怎么登录呢？登录也有两种方式，一种是直接把密码写在连接的命令里，另一种是进入到redis-cli的交互界面再输入密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">λ  blog master ✗ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; exit</span><br><span class="line"></span><br><span class="line"># 直接将密码写在连接的命令行里</span><br><span class="line">λ  blog master ✗ redis-cli -a this_is_password</span><br><span class="line">Warning: Using a password with &#39;-a&#39; or &#39;-u&#39; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; exit</span><br><span class="line"></span><br><span class="line"># 进入到redis-cli交互界面后再验证</span><br><span class="line">λ  blog master ✗ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; auth this_is_password</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;a&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有验证也能进入到redis-cli的交互界面，只是没有权限而已</p>
</blockquote>
<blockquote>
<p>其中<code>keys *</code>可以看到当前库里的所有key</p>
</blockquote>
<h1 id="0X02-Redis持久化"><a href="#0X02-Redis持久化" class="headerlink" title="0X02 Redis持久化"></a>0X02 Redis持久化</h1><p>本来还像要自己写一些关于持久化的初级知识，结果发现<a href="https://segmentfault.com/a/1190000002906345">这篇文章</a>已经写的超级棒了，索性补充一小部分他这里没有提到的吧。</p>
<ol>
<li>默认情况下redis装好就启用了RDB；</li>
<li>默认情况下重启redis的时候会写入一次RDB；</li>
</ol>
<p><strong>使用docker部署redis需要注意的点</strong>：如果使用docker部署redis，并且需要对数据进行持久化的话一定记得将redis数据文件挂载出来，否则会导致数据丢失。因为持久化的文件存在与docker容器内部，只是重启容器还好问题不大，但是如果<code>docker stop/rm/run</code>一波下来就会导致容器内部的数据被删的一干二净了（准确地说容器都不是之前的那个了，数据当然也就不在了）。</p>
]]></content>
      
        
        <tags>
            
            <tag> Database </tag>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正确构建Docker镜像]]></title>
      <url>/2019/09/17/docker-image/</url>
      <content type="html"><![CDATA[<h1 id="0X00-最常见的两种构建方式"><a href="#0X00-最常见的两种构建方式" class="headerlink" title="0X00 最常见的两种构建方式"></a>0X00 最常见的两种构建方式</h1><p>构建Docker镜像的方式并不多，最常用的也就只有：编写Dockerfile和使用docker commit这两种。既然方式分为两种那么肯定是有区别的（废话），那我们来看看吧。</p>
<p>首先来介绍一下这两种构建方式，假设打算使用docker部署我们的服务，那么我们来使用两种方式来构建一下这个镜像吧。</p>
<h1 id="0X01-docker-commit"><a href="#0X01-docker-commit" class="headerlink" title="0X01 docker commit"></a>0X01 docker commit</h1><p>像我们这种新手平时用的比较多的应该就是<code>docker commit xxxxx hub.xxx.xxx/xxx:xxx</code>这种方式了，我们称之为<code>docker commit</code>。这种方式比较好操作，比较好理解，操作也比较容易。如果掌握了<code>git</code>的工作流程，那么使用<code>docker commit</code>方式来构建镜像简直是小菜一碟。</p>
<ol>
<li>我们搞一个基础镜像比如<code>fedora</code>，那我们把它搞下来：<code>docker pull fedora</code></li>
<li>运行并进入到容器里<code>docker run --name our_container -it fedora /bin/bash</code>，此时shell已经接入到容器里了</li>
<li>我们来安装吧 <code>dnf install python3</code>然后<code>pip3 install Django</code> 这样就装好了，可以退出docker里的shell了</li>
<li><code>docker commit -m &quot;安装了Python和Django&quot; our_container our_image:latest</code>这样就将刚刚的容器打包成名为<code>our_image</code>的镜像了</li>
<li>现在使用<code>docker images</code>就可以看到刚刚打包的<code>our_image</code>了</li>
<li>后面如果还需要更新这个镜像那么就可以继续运行这个<code>docker run --name our_container -it our_image:latest</code>然后更新完了再<code>docker commit -m &quot;balabalabala&quot; our_container our_image:latest</code>打包一层新的上去就好了</li>
</ol>
<a id="more"></a>
<h1 id="0X02-Dockerfile"><a href="#0X02-Dockerfile" class="headerlink" title="0X02 Dockerfile"></a>0X02 Dockerfile</h1><p>另一种常见构建镜像的方式是编写<code>Dockerfile</code>文件，通过Dockerfile构建一个新的镜像。</p>
<ol>
<li>创建一个名为<code>Dockerfile</code>的文件，并写入以下内容</li>
<li>在当前目录执行<code>docker build . -t our_image:latest</code>就可以了</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> fedora</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dnf install python3</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install Django</span></span><br></pre></td></tr></table></figure>


<h1 id="0X03-对比两种方法"><a href="#0X03-对比两种方法" class="headerlink" title="0X03 对比两种方法"></a>0X03 对比两种方法</h1><p>两者的对比从下面几个方面来进行</p>
<h2 id="docker-hub"><a href="#docker-hub" class="headerlink" title="docker hub"></a>docker hub</h2><p>这两种方法其中<code>docker commit</code>方法通常需要使用私有<code>docker hub</code>，而<code>Dockerfile</code>则可以不使用。因为<code>docker commit</code>完成的镜像如果要分享给其他人的话最方便的途径就是走<code>docker hub</code>（自己构建完push到hub上，其他人再pull下来），而<code>Dockerfile</code>只要保证使用的是公共的基础镜像那么所有人就都可以直接构建出目标镜像。</p>
<blockquote>
<p>之所以说是最方便，是因为还有一种<code>docker save</code>的方式可以打包镜像成<code>xxx.tar</code>，别人再<code>docker load</code>。这种方式虽然能用但是很麻烦，也不是常规操作</p>
</blockquote>
<blockquote>
<p>docker 镜像当然可以上传到公共的hub上，但是公司的商业内容怕是不允许呦</p>
</blockquote>
<h2 id="使用难度"><a href="#使用难度" class="headerlink" title="使用难度"></a>使用难度</h2><p><code>docker commit</code>操作简单，每次更新镜像时接入到容器里一波操作最后<code>docker commit xxxxx</code>封装一下再使用<code>docker push</code>将镜像推到hub就可以了。基本所有人都可以很快搞清楚流程并且开始上手使用。</p>
<p><code>Dockerfile</code>就显得难了不少，构建复杂一点的镜像往往<code>Dockerfile</code>就几十上百行了，再算上里面十多种<code>Dockerfile</code>语法，并不是所有人都能很快上手的。</p>
<h2 id="镜像层数"><a href="#镜像层数" class="headerlink" title="镜像层数"></a>镜像层数</h2><p>众所周知<strong>Docker镜像的每次commit都会在文件系统上新增一层</strong>（反正现在你肯定知道了），而层数的增加意味着“镜像体积膨胀”。如果决定使用<code>docker commit</code>的方式维护镜像，那么不免后期会大量通过commit来更新镜像从而导致镜像层数过多，体积过大。</p>
<p>而<code>Dockerfile</code>中的每个指令也都会为镜像摞上一层，但是可以通过换行整合的方式使之缩小很多，比如将内容写成下面这种</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> dnf install python3 gcc \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cat /data/our_hosts &gt; /etc/hosts \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cat /<span class="built_in">log</span>/balabala.log | grep <span class="string">&quot;test&quot;</span> &gt; /data/test_group.log \</span></span><br><span class="line"><span class="bash">    &amp;&amp; pip install Django \</span></span><br><span class="line"><span class="bash">    &amp;&amp; django-admin startproject testproject</span></span><br></pre></td></tr></table></figure>

<p>将本来要写很多行的整理到一个命令后面，以此来缩减镜像层数</p>
<h2 id="镜像的可追溯性"><a href="#镜像的可追溯性" class="headerlink" title="镜像的可追溯性"></a>镜像的可追溯性</h2><p><code>Dockerfile</code>比<code>docker commit</code>具有更好的可追溯性。所谓的<strong>可追溯性</strong>就是说可以追溯这个镜像从基础镜像开始到最新的这个版本都做了什么。</p>
<p>如果使用<code>docker commit</code>的方式维护镜像，那么可以通过commit时候的备注和shell的历史记录来追溯，但是这两种方式都是不确定的，这样时间长久下去就会导致<strong>祖传镜像</strong>的出现。所谓祖传镜像就是指那些“我也不知道这个镜像里都改过哪些配置，装过哪些软件和第三方包，反正还能用就凑合用把”的镜像。</p>
<p>如果是使用的<code>Dockerfile</code>那么就很容易了，构建这个镜像所经历的所有所有步骤都清清楚楚写在<code>Dockerfile</code>里了，可追溯性比<code>docker commit</code>高到不知道哪里去了。</p>
<h1 id="0X04-精简镜像"><a href="#0X04-精简镜像" class="headerlink" title="0X04 精简镜像"></a>0X04 精简镜像</h1><p>精简镜像其实原则很简单，就是<strong>删除不用的东西，减少镜像层数</strong>。首先正确使用<code>Dockerfile</code>就可以大幅度精简镜像了，其次就是在Dockerfile中记得清理一些无用的东西。</p>
<ol>
<li>比如你要再容器中编译安装一个C库，那么最后是不是<code>gcc</code>就用不到了？用不到了就卸载掉。</li>
<li>每次<code>apt install &amp; dnf install &amp; pip install</code>是不是要有缓存文件？用完了就删掉</li>
<li>以此类推，将用不到的内容清理掉就行了</li>
</ol>
<p>比较重要的一点就是选择一个合适的基础镜像，通常来说我们自己使用<code>ubuntu</code>搞一个镜像装上<code>Python</code>再搞上<code>Django</code>(Python的一个web框架)所构建的镜像不会比直接用<code>Django</code>的官方基础镜像更好。</p>
<h1 id="0X05-需要注意"><a href="#0X05-需要注意" class="headerlink" title="0X05 需要注意"></a>0X05 需要注意</h1><p>有几个需要注意的点：</p>
<ol>
<li><code>docker image</code>是有层数限制的，目前是127层，超出的话再commit是会报错的</li>
<li><code>docker build</code>实际上就是自动的<code>docker run/xxx/commit/stop/rm</code>工作流</li>
<li><code>docker build .</code>中的<code>.</code>看起来是<code>Dockerfile</code>所在位置，实际并不是，而是“上下文环境”。具体的内容比较多，可以自行搜索了解</li>
<li>指定<code>Dockerfile</code>要用<code>docker buld -f xxx/xxx/xxx/hello .</code>，其中<code>xxx/xxx/xxx/hello</code>被当作<code>Dockerfile</code></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关系型数据库索引初步使用（搞不好性能提升百倍呦）]]></title>
      <url>/2019/09/15/database-index/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>不论多初级的后端程序员，只要认可自己是“后端程序员”那最起码也是听过“数据库索引”这个东西的，应该也直到这东西能让数据库变快。但是具体“数据库索引”是个什么东西，怎么用，为什么能让数据库变快可能就不一定清楚了。</p>
<p>这篇博客仅仅是简述了“数据库索引”的最基础内容，不涉及内部原理（其实我也还没搞懂）。阅读了本篇博客可以（也许）搞清楚怎么给一张表添加索引，索引加在哪儿，以及为什么不能给所有字段加索引。</p>
<h1 id="0X01-一个业务场景"><a href="#0X01-一个业务场景" class="headerlink" title="0X01 一个业务场景"></a>0X01 一个业务场景</h1><p>假设我们搞了一个电商平台“并夕夕”，现在有超多用户大概几百万，很多人都在我们系统里买了东西，大概下了1000W单。那么我们用来存储订单的表就有大概1000W条数据了，那么我们这个没有进行过任何优化的数据库就已经顶不住了，我们每次在后台查看订单列表的时候一个查询就要快20s，显然是一个接受不了的速度了。</p>
<p>那么我们来看一下这个列表都干了什么：“根据 订单状态（下单待支付/已支付/配送中/已收货/退货中/已完成），订单类型（直接购买/拼单购买/分享白拿）等状态筛选，并取出前20条展示出来”。后台SQL是这个样子的<code>SELECT * FROM bxx_order WHERE order_status = xxx AND order_type = xxx ORDER BY -id LIMIT 20</code>，我们可以看到真正会影响性能的主要就在<code>WHERE</code>子句里的查询条件。接下来我们给这两个字段分别加上索引，查询效率就会高非常非常多。</p>
<a id="more"></a>

<blockquote>
<p>我在公司的一张400W的表中为“状态”字段添加索引后对比未添加索引的时候快了不止100倍。</p>
</blockquote>
<p>下面我们来看一下索引是怎么使用的</p>
<h1 id="0X02-什么是索引-amp-为什么用索引会加快查询"><a href="#0X02-什么是索引-amp-为什么用索引会加快查询" class="headerlink" title="0X02 什么是索引&amp;为什么用索引会加快查询"></a>0X02 什么是索引&amp;为什么用索引会加快查询</h1><p>网上常见的解释是将“书的目录”与“数据库索引”关联理解，其实是没有问题的，但是第一次理解这个概念光直到这个也没什么用啊，还是不太能明白呢。我们来把一本书作为一张数据库表好了，其中有如下字段<code>一级标题，二级标题，小节，正文</code>。比如一级标题就是“1. 引论”，二级标题是“1.1 什么是操作系统”，小节是“1.1.1 作为扩展机器的操作系统”，正文就是“balabalabalabala”，那么一般的书籍都会对一二级标题建立索引（目录）。</p>
<p>我们想想这本500多页的《现代操作系统》如果没有索引，那我想看“多核处理器上的虚拟机”这一部分要怎么找呢，就只有从第一页开始翻书一直到找到为止。这就是数据库不添加索引时候的查询方式，逐条查看。</p>
<p>现在我们给标题添加了索引，也就多出了一部分名为“目录”的内容。但是这个目录只有7页，我可以在这7页目录里找到我需要的内容在500页中的位置然后直接翻到对应的那一页。数据库也是这样的，假设我们给订单状态添加了索引，数据库就会知道状态为“待支付”的订单在数据库的什么位置，状态为“已完成”的在什么位置。也就不用每次都一条条的查看这1000W条订单数据了。</p>
<h1 id="0X03-如何添加索引"><a href="#0X03-如何添加索引" class="headerlink" title="0X03 如何添加索引"></a>0X03 如何添加索引</h1><p>那说了这么多，怎么才能给数据库表添加上索引呢？如果是在建表阶段就考虑到了索引，本来的建表SQL是这样的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> bxx_order(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">order_status <span class="built_in">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">order_type <span class="built_in">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>那么只需要在最后加上索引指定就行了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> bxx_order(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">order_status <span class="built_in">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">order_type <span class="built_in">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line"><span class="comment">-- 上面没变，只是加了最后的逗号</span></span><br><span class="line"><span class="keyword">INDEX</span> (order_status)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>那如果表已经存在了呢？也只需要<code>ALERT TABLE bxx_order ADD INDEX order_status</code>就可以将已经存在的表添加上索引。</p>
<p><strong>注意在生产环境上添加索引时可能会锁表从而导致业务收到影响。所以请务必调查清楚自己使用的数据库版本和当前的业务，结合数据库版本特性和业务情况酌情在生产环境操作</strong></p>
<p><strong>注意在生产环境上添加索引时可能会锁表从而导致业务收到影响。所以请务必调查清楚自己使用的数据库版本和当前的业务，结合数据库版本特性和业务情况酌情在生产环境操作</strong></p>
<p><strong>注意在生产环境上添加索引时可能会锁表从而导致业务收到影响。所以请务必调查清楚自己使用的数据库版本和当前的业务，结合数据库版本特性和业务情况酌情在生产环境操作</strong></p>
<h1 id="0X04-索引加在那儿"><a href="#0X04-索引加在那儿" class="headerlink" title="0X04 索引加在那儿"></a>0X04 索引加在那儿</h1><p>好了，我们已经知道了索引是什么也知道索引怎么加了，那在哪些字段加索引才会有很好的效果呢？<strong>给<code>WHERE</code>后面用的字段加索引，给<code>ORDER BY</code>后面的字段加索引，给“选择的值”加索引</strong>。</p>
<p><code>SELECT create_time, pay_time, username, amount FROM bxx_order WHERE order_status = &quot;done&quot; AND order_type = &quot;free&quot; ORDER BY -pay_time LIMIT 20</code></p>
<p>第一部分是“给<code>WHERE</code>后面的字段加索引”，也就是上面这个实例中的<code>order_status</code>和<code>order_type</code>字段；第二部分是”给<code>ORDER BY</code>后面的字段加索引”，也就是上面实例中的<code>pay_time</code>字段。因为我们加了索引是方便查询和排序的，你看我们的书上不会给正文加索引，更不会给每一页的字数加索引，因为这些索引加了之后对我们翻看目录并没有任何帮助。</p>
<p>重点是第三点<strong>给“选择的值”加索引</strong>。什么是“选择的值”呢？就是说某个字段的值就只有这些，这个字段的值值可能是这几种十几种里的一种。</p>
<p>我们看这样一个SQL<code>SELECT * FROM bxx_order WHERE order_status = &quot;done&quot;</code>。因为我们的<code>order_status</code>一共就这么几种，假设这些状态的订单都差不多数量的话，应该是每种状态的订单都是167W左右。那么我们给这个字段加了索引后，数据库查询时候就可以瞬间将查询范围从1000W缩减为167W，效率一下就是原来的6倍，如果状态更多那效果会更明显。（当然不是越多越好，副作用后面会提到）</p>
<h1 id="0X05-联合索引"><a href="#0X05-联合索引" class="headerlink" title="0X05 联合索引"></a>0X05 联合索引</h1><p>联合索引可以理解为将索引后的数据再索引一次。比如这么一个SQL<code>SELECT * FROM bxx_order WHERE order_status = &quot;done&quot; AND ORDER_TYPE = &quot;free&quot;</code>，如果建立了<code>order_status</code>和<code>order_type</code>的联合索引，那么就会在对<code>order_status</code>索引完成后的167W条数据的g基础上再来一次对<code>order_type</code>的索引，速度会进一步变快。不过要注意的是联合索引要是<code>AND</code>条件下才会触发，如果用了<code>SELECT * FROM bxx_order WHERE order_status=&quot;done&quot; OR order_type=&quot;free&quot;</code>这种就不会触发了。</p>
<p>建立联合索引也比较简单，建表的时候将上述的<code>INDEX (order_status)</code>改成<code>INDEX (order_status, order_type)</code>就好了，改表也是同理。</p>
<h1 id="0X06-索引当然有副作用"><a href="#0X06-索引当然有副作用" class="headerlink" title="0X06 索引当然有副作用"></a>0X06 索引当然有副作用</h1><p>那是不是给所以字段都加上索引数据库就飞快了？当然不是，如果是的话那索引这东西就应该不需要手动添加而是直接自动实现了是吧。那索引的副作用是什么呢？下面这几种情况都是建立索引的副作用，或是无用功:</p>
<ol>
<li>想想把书写完了，生成了一个目录，读者读起来开开心心是吧。突然你说要往书的第三章和第四章中间插入一些新内容，本来是只需要修改内容的，现在还要对应修改目录部分。数据库也是一样，本来一次的写入变成了两次写入，性能自然下降了；</li>
<li>如果建立了过多的索引，那么索引占用的内存就会很大，对机器造成过多的负载。想想如果我们给书的所有内容都建立了索引，甚至正文页建立了索引，那索引也就没什么太大的意义了；</li>
<li>如果我们把索引添加在了经常只出现在<code>SELECT</code>后面的字段上，那不仅每次写入数据的时候都要更新索引数据，而且这个索引对我们的系统性能还毫无提升甚至因为这个索引我们系统还更慢了。</li>
</ol>
<h1 id="0X07-总结"><a href="#0X07-总结" class="headerlink" title="0X07 总结"></a>0X07 总结</h1><p>总结起来说的话，索引的建立应该遵循其设计初衷与原理，否则不仅对查询毫无帮助反而会加大消耗的内存并且减慢写入的速度。</p>
]]></content>
      
        
        <tags>
            
            <tag> Database </tag>
            
            <tag> Index </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 装饰器]]></title>
      <url>/2019/08/22/python-decorator/</url>
      <content type="html"><![CDATA[<h1 id="0X00-给一个方法计时"><a href="#0X00-给一个方法计时" class="headerlink" title="0X00 给一个方法计时"></a>0X00 给一个方法计时</h1><p>现在我们有一个需求，需要给程序中的一部分方法计时，以监控他们执行完具体用了多久。那么在没有装饰器的情况下我们会写出类似这样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">pass</span>    <span class="comment"># some code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = datetime.datetime.now()</span><br><span class="line">foo()</span><br><span class="line">end = datetime.datetime.now()</span><br><span class="line">print((end - start).seconds)</span><br></pre></td></tr></table></figure>

<h1 id="0X01-引入装饰器"><a href="#0X01-引入装饰器" class="headerlink" title="0X01 引入装饰器"></a>0X01 引入装饰器</h1><p>如果只是临时给一个方法使用也不是不行，但是如果我们需要监控大量的方法呢？众所周知Python中<code>function</code>也是可以作为参数传递的，那来看一下下面这种写法呢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_func</span>():</span> <span class="comment"># 方法内部将之前计时的功能封装起来</span></span><br><span class="line">        start = datetime.datetime.now()</span><br><span class="line">        result = func() <span class="comment"># 得到参数方法的返回值</span></span><br><span class="line">        end = datetime.datetime.now()</span><br><span class="line">        print((end - start).seconds)</span><br><span class="line">        <span class="keyword">return</span> result   <span class="comment"># 将真正的结果返回给调用者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> run_func   <span class="comment"># 调用内部方法，进行计时</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">pass</span>    <span class="comment"># some code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="keyword">pass</span>    <span class="comment"># some code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将方法作为参数发送给 timer()</span></span><br><span class="line">timer(foo)()</span><br><span class="line">timer(bar)()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>因为上面timer(foo)返回的结果是一个<code>func</code>，所以后面需要再加一对括号来调用这个方法</strong></p>
<p>这种方法只写了一次计时的逻辑，但是可以给任意一个方法使用，其实这时候<code>def timer(func)</code>已经是装饰器了，下面调用的方法<code>timer(foo)/timer(bar)</code>也是正确的装饰器使用方法。那是不是觉得和常见的装饰器使用不太一样呢？其实常见的<code>@timer</code>用法是Python中提供的一种语法糖。</p>
<a id="more"></a>
<h1 id="0X02-语法糖"><a href="#0X02-语法糖" class="headerlink" title="0X02 @语法糖"></a>0X02 @语法糖</h1><p>其实上面的代码就可以直接使用@语法糖了，具体用法是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">pass</span>    <span class="comment"># some code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>语法糖实际只是便于我们编码的一种设计，按理说一切被称为语法糖的东西都不是必须的。比如说这里的语法糖完全可以用上面的方法来应用装饰器，但是为什么还是设计了这个语法糖呢？我们对比下面两种方法的调用，我们假设<code>get_data_from_server/db</code>是一个耗时较久的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data_from_server</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data_from_db</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timer(get_data_from_server))()</span><br><span class="line"></span><br><span class="line">get_data_from_db()</span><br></pre></td></tr></table></figure>
<p>这两种方法看起来明显是后面<code>get_data_from_db</code>的用法更易读。所以这处语法糖的出现能大幅度的提升代码的可读性，更能提升维护性质：当代码中调用了1W次非语法糖形式的装饰器计时时，取消计时就要修改1W行代码；如果用了@语法糖，那就只需要将方法定义处的<code>@timer</code>注释掉就可以了。</p>
<h1 id="0X03-传参"><a href="#0X03-传参" class="headerlink" title="0X03 传参"></a>0X03 传参</h1><p>“那要传参咋搞哇？” “这么搞”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_func</span>(<span class="params">secs</span>):</span> <span class="comment"># 这儿接受参数</span></span><br><span class="line">        start = datetime.datetime.now()</span><br><span class="line">        result = func(secs) <span class="comment"># 这儿把参数搞进去</span></span><br><span class="line">        end = datetime.datetime.now()</span><br><span class="line">        print((end - start).microseconds)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> run_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">secs</span>):</span></span><br><span class="line">    time.sleep(secs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">secs</span>):</span></span><br><span class="line">    time.sleep(secs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    foo(<span class="number">3</span>)  <span class="comment"># 和不使用@timer时候的timer(foo)(3)是一样的</span></span><br><span class="line">    bar(<span class="number">5</span>)  <span class="comment"># 和不使用@timer时候的timer(bar)(5)是一样的</span></span><br></pre></td></tr></table></figure>

<p>“那我要是有好几个参数呢，怎么搞？” “就还是这么搞啊”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_func</span>(<span class="params">*args</span>):</span> <span class="comment"># 这儿接受参数，几个都行</span></span><br><span class="line">        start = datetime.datetime.now()</span><br><span class="line">        result = func(*args) <span class="comment"># 这儿把参数搞进去，几个都行</span></span><br><span class="line">        end = datetime.datetime.now()</span><br><span class="line">        print((end - start).microseconds)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> run_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">start_secs, end_secs</span>):</span></span><br><span class="line">    time.sleep(random.randint(start_secs, end_secs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Decorator </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中的可迭代对象、迭代器与生成器]]></title>
      <url>/2019/08/20/iterator-generator/</url>
      <content type="html"><![CDATA[<h1 id="0X00-什么是可迭代对象"><a href="#0X00-什么是可迭代对象" class="headerlink" title="0X00 什么是可迭代对象"></a>0X00 什么是可迭代对象</h1><p>我们平时用到的<code>list/set/tuples</code>是最常见的可迭代对象，简单判断就是说当可以<code>for item in this_obj</code>的时候<code>this_obj</code>就是可迭代对象。所以不只是<code>list/set/tuples</code>，打开的文件或是Django中的<code>queryset</code>也都是可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: user_list = iter([<span class="string">&#x27;shawn&#x27;</span>, <span class="string">&#x27;danny&#x27;</span>, <span class="string">&#x27;jenny&#x27;</span>, <span class="string">&#x27;liming&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: next(user_list)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;shawn&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: next(user_list)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">&#x27;danny&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: next(user_list)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: next(user_list)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">&#x27;liming&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>iter()</code>可以将列表变为一个迭代器，然后使用<code>next</code>方法访问下一个元素。实际上<code>iter(this_obj)</code>方法和<code>next(this_obj)</code>方法分别调用的是<code>this_obj.__iter__()</code>和<code>this_obj.__next__()</code>，所以我们如果想要自己实现迭代器的话就需要实现这两个方法。</p>
<a id="more"></a>
<h1 id="0X01-迭代器"><a href="#0X01-迭代器" class="headerlink" title="0X01 迭代器"></a>0X01 迭代器</h1><p>那我们来实现实现一个计算斐波纳契数列的迭代器吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pre = <span class="number">0</span></span><br><span class="line">        self.cur = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代器的iter方法返回自身&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;每次计算下一个值&quot;&quot;&quot;</span></span><br><span class="line">        res = self.cur</span><br><span class="line">        self.cur = self.cur + self.pre</span><br><span class="line">        self.pre = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>运行起来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> fib:</span><br><span class="line">        print(i)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">89</span></span><br><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">233</span></span><br></pre></td></tr></table></figure>

<p>这里没有中断的判定，如果需要中断的话就抛出一个<code>StopIteration</code>异常就好了，就像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span></span><br><span class="line">    .......</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        res = self.cur</span><br><span class="line">        self.cur = self.cur + self.pre</span><br><span class="line">        self.pre = res</span><br><span class="line">        <span class="keyword">if</span> res &gt; <span class="number">100</span>:   <span class="comment"># 数列最后值小于100</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="0X02-生成器"><a href="#0X02-生成器" class="headerlink" title="0X02 生成器"></a>0X02 生成器</h1><p><strong>生成器是一类特殊的迭代器</strong>，将我们平时写的这种<code>[i for i in range(100)]</code>列表生成式的方括号换成小括号，就是将结果从列表变成生成器了<code>(i for i in range(100))</code>。</p>
<p>我们可以从这里看出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: b = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: type(a)</span><br><span class="line">Out[<span class="number">3</span>]: list</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: type(b)</span><br><span class="line">Out[<span class="number">4</span>]: generator</span><br></pre></td></tr></table></figure>

<h1 id="0X03-区别在哪儿呢"><a href="#0X03-区别在哪儿呢" class="headerlink" title="0X03 区别在哪儿呢"></a>0X03 区别在哪儿呢</h1><p>既然迭代器用起<code>for .. in ..</code>来跟列表之类的差不多，那为什么还要搞这个东西出来呢。显然不是用来玩票的，用处是大大的有。下面来举个例子，有一个10GB大小的日志文件，但是我们机器只有8G的内存，还打算逐行分析日志内容，那肯定就不能直接把文件全部都读入内存了，显然内存是不够用的。这种类似的时候就可以使用迭代器的方法打开这个文件，其实也就是我们常用的这种<code>for line open(&#39;nginx.log&#39;)</code>的方式。这种方式可以发现不管多大的文件，只要不是单行超长的文件，读取起来都是差不多的。</p>
<p>因为迭代器只是每次要用下一行的时候才去读取下一行，而不是把整个文件都读到内存里再在需要的时候去取。简单地来说就是<strong>列表元组之类的结构是保存数据，而迭代器是保存算法</strong>。</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Data Structure </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Django中的select_related和prefetch_related优化查询]]></title>
      <url>/2019/05/12/django-2-query/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>没有什么前言，只有一个数据库模型，下面的代码使用这个模型拿来测试。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Major</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(</span><br><span class="line">        <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">        max_length=<span class="number">100</span>,</span><br><span class="line">        blank=<span class="literal">True</span>,</span><br><span class="line">        null=<span class="literal">True</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(</span><br><span class="line">        <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">        max_length=<span class="number">100</span>,</span><br><span class="line">        blank=<span class="literal">True</span>,</span><br><span class="line">        null=<span class="literal">True</span>,</span><br><span class="line">    )</span><br><span class="line">    select_major = models.ForeignKey(</span><br><span class="line">        Major,</span><br><span class="line">        verbose_name=<span class="string">&#x27;专业&#x27;</span>,</span><br><span class="line">        on_delete=models.SET_NULL,</span><br><span class="line">        blank=<span class="literal">True</span>,</span><br><span class="line">        null=<span class="literal">True</span>,</span><br><span class="line">        related_name=<span class="string">&#x27;main_student&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">    ext_major = models.ManyToManyField(</span><br><span class="line">        Major,</span><br><span class="line">        verbose_name=<span class="string">&#x27;附加专业&#x27;</span>,</span><br><span class="line">        related_name=<span class="string">&#x27;ext_student&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们先假设Major表存在10条数据，而Student表存在1万条数据。</p>
<a id="more"></a>

<h1 id="0X01-使用select-related"><a href="#0X01-使用select-related" class="headerlink" title="0X01 使用select_related"></a>0X01 使用select_related</h1><p>如果我们要得到所有的学生和他们所学专业的名字，那么我们可以轻松写出下面的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> Student.objects.all():</span><br><span class="line">    print(student.name, <span class="string">&#x27;--&gt;&#x27;</span>, student.selected_major.name)</span><br></pre></td></tr></table></figure>
<p>这样就能得到所有学生姓名和他们所学的专业名了，但是重点在于这次查询其实是一个很低效的查询，因为在<code>Student.objects.all()</code>的时候查询了一次数据库，而且每次访问<code>student.selected_major.name</code>的时候都会再查询一次数据库，基于上述条件这两行代码将会查询10001次数据库，是一个比较夸张的数字了。那么如何用<code>select_related</code>来优化这次查询呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> Student.objects.all().select_related(<span class="string">&#x27;major&#x27;</span>):</span><br><span class="line">    print(student.name, <span class="string">&#x27;--&gt;&#x27;</span>, student.selected_major.name)</span><br></pre></td></tr></table></figure>

<p>其实就是在<code>all()</code>之后添加了<code>select_related(&#39;major&#39;)</code>，这次就只需要对数据库进行一次查询。在我本地的类似环境下测试结果是不使用<code>select_related</code>消耗的时间是优化后的400%左右。</p>
<blockquote>
<p>本质上是<code>select_related</code>进行了数据库级的JOIN操作，具体的大家可以通过查看<code>print(Model.objects.filter().query)</code>或者<code>django-extensions</code>等方法查看具体的SQL</p>
</blockquote>
<p>这里可能会有一种声音“查询从10001次到1次差了几乎10000倍时间却只省下了70%多？”这个问题其实比较好理解，JOIN操作本来就会使一次SQL查询变的很慢，毕竟要跨越多张表。</p>
<p><code>select_related</code>是用于优化“多对一”结构中从“多”表出发查“一”表，也就是这里的多个学生对一个专业，从学生出发查询得到“专业”。</p>
<p>这里我贴出使用前和使用后的两坨SQL，大家可以对比一下。（这些SQL都是Django-extensions分析得出的）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">优化前</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;name&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;select_major_id&quot;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">&quot;School_student&quot;</span></span><br><span class="line"> <span class="keyword">LIMIT</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;name&quot;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">&quot;School_major&quot;</span></span><br><span class="line"> <span class="keyword">WHERE</span> <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;id&quot;</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;name&quot;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">&quot;School_major&quot;</span></span><br><span class="line"> <span class="keyword">WHERE</span> <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;id&quot;</span> = <span class="number">5</span></span><br><span class="line">一直重复，直到循环结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优化后</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;name&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;select_major_id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;name&quot;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">&quot;School_student&quot;</span></span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="string">&quot;School_major&quot;</span></span><br><span class="line">    <span class="keyword">ON</span> (<span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;select_major_id&quot;</span> = <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;id&quot;</span>)</span><br><span class="line">只剩下了一条使用了<span class="keyword">JOIN</span>的<span class="keyword">SQL</span>，显然会比上面快很多</span><br></pre></td></tr></table></figure>



<h1 id="0X02-使用prefetch-related"><a href="#0X02-使用prefetch-related" class="headerlink" title="0X02 使用prefetch_related"></a>0X02 使用prefetch_related</h1><p><code>prefetch_related</code>是从“一对多”结构中“一”表出发查“多”表，也就是说从专业表出发查询得到学生信息。比如我们想看这所有专业中每个专业下的学生</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> major <span class="keyword">in</span> Major.objects.filter():</span><br><span class="line">    print(major.main_student.all())</span><br></pre></td></tr></table></figure>

<p>这种查询是最容易写出来的，不过需要注意的一点是，这里第一行循环前有一个<code>filter()</code>会查询一次数据库，后面每一次<code>main_student.all()</code>都会再查询数据库。我们只有10个专业，查11次数据库还行问题不大，但是随着数据增多这里查询数据库的次数会呈线性增长。那么如何解决这个问题呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> major <span class="keyword">in</span> Major.objects.filter().prefetch_related(<span class="string">&#x27;main_student&#x27;</span>):</span><br><span class="line">    print(major.main_student.all())</span><br></pre></td></tr></table></figure>

<p>就只是向上面使用<code>select_related</code>一样添加一个<code>prefetch_related</code>在<code>filter()</code>后面就可以了。修改了之后的代码只会查询两次数据库：第一次把所有的专业查出来了，也就是<code>Major.objects.filter()</code>的作用；第二次是使用一个<code>SELECT * FROM student WHERE select_major_id IN (x,x,x,x,x,x)</code>形式的SQL查询到了对应的Student。<strong>然后使用Python将其组装整合而非数据库</strong>，这样就能大幅度减少查询数据库的次数了。</p>
<p>这里我贴出使用前和使用后的两坨SQL，大家可以对比一下。（这些SQL都是Django-extensions分析得出的）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">优化前</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;name&quot;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">&quot;School_major&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;name&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;select_major_id&quot;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">&quot;School_student&quot;</span></span><br><span class="line"> <span class="keyword">WHERE</span> <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;select_major_id&quot;</span> = <span class="number">4</span></span><br><span class="line"> <span class="keyword">LIMIT</span> <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;name&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;select_major_id&quot;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">&quot;School_student&quot;</span></span><br><span class="line"> <span class="keyword">WHERE</span> <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;select_major_id&quot;</span> = <span class="number">5</span></span><br><span class="line"> <span class="keyword">LIMIT</span> <span class="number">21</span></span><br><span class="line">......一直重复直到循环完所有的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优化后</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_major&quot;</span>.<span class="string">&quot;name&quot;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">&quot;School_major&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;id&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;name&quot;</span>,</span><br><span class="line">       <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;select_major_id&quot;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="string">&quot;School_student&quot;</span></span><br><span class="line"> <span class="keyword">WHERE</span> <span class="string">&quot;School_student&quot;</span>.<span class="string">&quot;select_major_id&quot;</span> <span class="keyword">IN</span> (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">87</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>)</span><br></pre></td></tr></table></figure>



<h1 id="0X03-总结"><a href="#0X03-总结" class="headerlink" title="0X03 总结"></a>0X03 总结</h1><p>还有总结？大家都有，我也有好了</p>
<p>通常来说恰当的使用<code>select_related</code>和<code>prefetch_related</code>可以大幅度提升自己ORM查询的速度，很多时候大家只是写了能用的查询，现在可以尝试着使用<code>select_related/prefetch_related</code>写出好用的查询啦</p>
]]></content>
      
        
        <tags>
            
            <tag> Database </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么Https是安全的（简单介绍）]]></title>
      <url>/2019/04/09/why-https-security/</url>
      <content type="html"><![CDATA[<h1 id="0X00-没有什么用的开头"><a href="#0X00-没有什么用的开头" class="headerlink" title="0X00 没有什么用的开头"></a>0X00 没有什么用的开头</h1><p>众所周知https是安全加密的协议，那么https究竟是如何保证数据传输的安全性的呢？这里来简单介绍一下https的安全机制。</p>
<h1 id="0X01-简介"><a href="#0X01-简介" class="headerlink" title="0X01 简介"></a>0X01 简介</h1><p>HTTPS全称是 <em>Hypertext Transfer Protocol Secure</em> 也就是传统的HTTP加上了S <em>Secure</em>，也可以叫 <em>HTTP over TLS</em>，总之就是加了密的HTTP嘛。</p>
<p>最常见的加密就是通信双方共有一个密钥，使用这个密钥对原文进行加密和解密，简单粗暴。但是万一密钥泄露了，那么任何人都可以用这个密钥解密你们通信的所有内容，甚至通信双方都是无感知的。（想象一下你和小姐姐的聊天记录被一个扣脚大汉一行行的看完还嘿嘿傻笑是不是贼恐怖）</p>
<p>这种加密方式有一个严肃的问题就在于通信双方得有一个约定密钥的机会，还要保证传输密钥的信道是绝对安全的。（想象一下你想跟小姐姐聊天的话需要先私下悄悄碰面，然后再一个没有人的地方悄咪咪的交换密钥，然后再用这个密钥进行加密通信）这还不是重点，重点就是你俩明明已经有了一个可以保证绝对安全的通信方法（在没有人的地方悄咪咪地通信）了，那为啥还非要交换密码然后加密通信呢，是不是觉得贼蠢。</p>
<p>HTTPS就能解决这种问题，下面我们来开始吧。我们假设一个场景就是客户端（你）和一台web服务器（小姐姐）通信的场景，在这个场景下描述HTTPS。</p>
<h1 id="0X02-HTTPS的前提条件"><a href="#0X02-HTTPS的前提条件" class="headerlink" title="0X02 HTTPS的前提条件"></a>0X02 HTTPS的前提条件</h1><p>HTTPS通信有两个重要前提条件，没有这些条件的话HTTPS是没有实际作用的</p>
<ol>
<li>使用非对称加密算法对内容进行加密，目前我们使用的RSA算法就是非对称加密算法</li>
<li>存在一个绝对安全的第三方机构，我们称之为CA（Certificate Authority），我们认为它不会被攻击，他发布的信息都是可靠的</li>
</ol>
<blockquote>
<p>非对称加密：与对称加密的一个密钥用来加密解密不同，非对称加密有一对密钥，分为“公钥”和“私钥”。使用密钥对中的公钥对原文进行加密之后再次使用公钥解密是行不通的，必须使用对应的私钥才能对密文进行解密；</p>
</blockquote>
<blockquote>
<p>CA：CA是一个被认为绝对安全且诚实的第三方机构，服务器将自己密钥对中的公钥交由CA管理。客户端访问服务器时候可以从CA处取得服务器的公钥；</p>
</blockquote>
<a id="more"></a>

<h1 id="0X03-开始吧"><a href="#0X03-开始吧" class="headerlink" title="0X03 开始吧"></a>0X03 开始吧</h1><p><strong>无论客户端还是服务器，所有人的公钥都是可以对外公开的，私钥都是绝对绝对不能公开的，要保证私钥绝对安全，一旦私钥泄露即可造成HTTPS加密失效</strong></p>
<p>首先你打算以安全的方式联系小姐姐，从你这里开始整个流程。 </p>
<ol>
<li>首先你知道小姐姐的住址，然后通过小姐姐的住处前往CA去取得小姐姐的公钥；</li>
<li>你把想给小姐姐说的话用小姐姐的密钥加密好，连同自己的公钥一起发送给小姐姐；</li>
<li>小姐姐收到了你的密文，使用自己的私钥解密得到了你发送的原文；</li>
<li>小姐姐写好了给你的回复，使用你提供的公钥对原文加密，并传输给了你；</li>
<li>你收到小姐姐的密文后使用私钥将内容解密，得知了小姐姐的心意；</li>
<li>重复上面的操作。</li>
</ol>
<h1 id="0X04-如果被截取"><a href="#0X04-如果被截取" class="headerlink" title="0X04 如果被截取"></a>0X04 如果被截取</h1><p>我们假设在上面任意地方数据被黑客截取了，那他能获取你和小姐姐的消息内容吗？</p>
<h2 id="截取了你和CA的通信"><a href="#截取了你和CA的通信" class="headerlink" title="截取了你和CA的通信"></a>截取了你和CA的通信</h2><p>黑客截取了你和CA的通信，那么他能得到的信息就是：“你要和哪个小姐姐通信，小姐姐的公钥是什么”。虽然你也泄露了一点点信息（你要和谁通信），但是这些并非敏感数据，黑客并不能对这个做什么。小姐姐的公钥就更不重要了，任何人都能获得；</p>
<h2 id="截取了你第一次发给小姐姐的内容"><a href="#截取了你第一次发给小姐姐的内容" class="headerlink" title="截取了你第一次发给小姐姐的内容"></a>截取了你第一次发给小姐姐的内容</h2><p>如果黑客截取了你发送给小姐姐的内容，那内容中只有：“你发给小姐姐的密文，你自己的公钥”。密文由于他没有小姐姐的私钥，所以无法解密；你自己的公钥也是所有人都可以获取的，也没有用；</p>
<h2 id="截取了小姐姐回复给你的内容"><a href="#截取了小姐姐回复给你的内容" class="headerlink" title="截取了小姐姐回复给你的内容"></a>截取了小姐姐回复给你的内容</h2><p>假设黑客截取了小姐姐回复给你的内容，那内容中只有：“小姐姐给你的密文”。由于黑客并没有你的私钥，所以他并不能知道小姐姐给你发送了什么内容。</p>
<h1 id="0X05-总结"><a href="#0X05-总结" class="headerlink" title="0X05 总结"></a>0X05 总结</h1><p>总结下来，黑客即使截取了所有的数据，那也只有下面这些：</p>
<ol>
<li>客户端访问的服务器地址</li>
<li>客户端request携带的加密数据</li>
<li>服务端response携带的加密数据</li>
<li>客户端服务端双方的公钥</li>
</ol>
<p>其中加密数据由于没有对应的私钥所以无法解密，而双方的公钥本来就是公开的所以并没有什么用。</p>
]]></content>
      
        
        <tags>
            
            <tag> HTTP Secure </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vim 寄存器的使用]]></title>
      <url>/2019/01/19/vim-register/</url>
      <content type="html"><![CDATA[<p><strong>编辑器之神可不是浪得虚名</strong></p>
<h1 id="0X00-遇到了一些问题"><a href="#0X00-遇到了一些问题" class="headerlink" title="0X00 遇到了一些问题"></a>0X00 遇到了一些问题</h1><p>如果你看到了这篇文章那么我可以认为你至少已经掌握了vim基本用法。在我个人使用vim的过程中遇到了一些问题，这次就挑“寄存器”这部分出来说一下吧。</p>
<p>我这里贴一段代码过来，这段代码出自我在学校时写的一个小项目<a href="https://github.com/shawn-bluce/open_disframe">open_disframe</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> slave_method == <span class="string">&#x27;handshake&#x27;</span>:</span><br><span class="line">    process_handshake_request(slave_id)</span><br><span class="line">    slave_socket.send(<span class="string">&quot;handshake success&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">elif</span> slave_method == <span class="string">&#x27;heartbeat&#x27;</span>:</span><br><span class="line">    process_heartbeat_request(slave_id)</span><br><span class="line">    slave_socket.send(<span class="string">&quot;heartbeat success&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">elif</span> slave_method == <span class="string">&#x27;submit_message&#x27;</span>:</span><br><span class="line">    process_submit_message_request(message[<span class="string">&#x27;message_list&#x27;</span>])</span><br><span class="line">    slave_socket.send(<span class="string">&quot;submit success&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">elif</span> slave_method == <span class="string">&#x27;get_message&#x27;</span>:</span><br><span class="line">    send_message_list = process_get_message_request(slave_id, <span class="number">10</span>)</span><br><span class="line">    slave_socket.send(send_message_list.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">elif</span> slave_method == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">    process_exit_request(slave_id)</span><br><span class="line">    slave_socket.send(<span class="string">&quot;exit success&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    slave_socket.send((<span class="string">&quot;not found request: &quot;</span> + slave_method).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>现在我们在编辑编辑这段代码的时候需要将其中的部分内容替换掉，比如将第一个if中的<code>slave_socket.send.....</code>和第二个if中的<code>process_heartbeatxxx</code>和第三个if中的<code>continue</code>替换成<code>break</code>。虽然这么做可能有点诡异，不过这里实在没找到完美的适用场景，公司的代码也不能贴出来，又懒得编造一个完美适用场景，就先这样看吧。</p>
<a id="more"></a>
<p>通常我们与到这种情况都会是下面的操作流</p>
<ol>
<li>手动替换第一处的<code>break</code></li>
<li>复制<code>break</code></li>
<li>找到下一处需要替换的地方选中</li>
<li><code>p</code>粘贴过去</li>
<li>找到下一处需要替换的地方选中</li>
<li><code>p</code>粘贴过去</li>
<li>发现“剪贴板”被上面那次被替换掉的数据覆盖了，以至于将上次删掉的内容贴过来了，而不是自己想要的<code>break</code></li>
<li>沮丧中。。一个个复制粘贴替换过来</li>
</ol>
<p>这个问题困扰了我还是挺久的，一度认为vim居然这么蠢，后来才发现是我自己太蠢了，vim中有一个“寄存器”机制是我们均大多数人要么没用过要么听都没听过的，而这个“寄存器”就是用来解决这种问题的。</p>
<h1 id="0X01-什么是vim中的寄存器"><a href="#0X01-什么是vim中的寄存器" class="headerlink" title="0X01 什么是vim中的寄存器"></a>0X01 什么是vim中的寄存器</h1><p>我们可以大致将vim中的寄存器想像成系统使用的剪贴板，我们平时用的剪贴板只有一个格子，每次复制/剪切了新的数据就会覆盖掉之前格子里的数据。而vim中的寄存器有多种，每种有不同的功能特性，而且每种寄存器又有一个到多个不等。总的来说vim中有下述十种寄存器。</p>
<ol>
<li>匿名寄存器 <code>&quot;&quot;</code></li>
<li>编号寄存器 <code>&quot;0</code> 到 <code>&quot;9</code></li>
<li>小删除寄存器 <code>&quot;-</code></li>
<li>26个命名寄存器 <code>&quot;a</code> 到 <code>&quot;z</code></li>
<li>3个只读寄存器 <code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code></li>
<li>Buffer交替文件寄存器 <code>&quot;#</code></li>
<li>表达式寄存器 <code>&quot;=</code></li>
<li>选区和拖放寄存器 <code>&quot;*</code>, <code>&quot;+</code>, <code>&quot;~</code></li>
<li>黑洞寄存器 <code>&quot;_</code></li>
<li>搜索模式寄存器 <code>&quot;/</code></li>
</ol>
<p>在命令模式下<code>: register</code>就可以看到各个寄存器的值了</p>
<h1 id="0X02-如何使用这些寄存器"><a href="#0X02-如何使用这些寄存器" class="headerlink" title="0X02 如何使用这些寄存器"></a>0X02 如何使用这些寄存器</h1><p>这些寄存器种类较多，只挑选一些我个人常用到的吧，更完善的一篇博客可以<a href="https://harttle.land/2016/07/25/vim-registers.html">看这里</a></p>
<h2 id="如何使用寄存器"><a href="#如何使用寄存器" class="headerlink" title="如何使用寄存器"></a>如何使用寄存器</h2><p>先简单说一下，下面会具体介绍的。当你选中一坨内容后想要复制他到命名寄存器<code>&quot;a</code>中，那就需要在选中后依次按下<code>&quot;ay</code>。其中<code>&quot;a</code>相当于是选中了一个寄存器，而<code>y</code>就是当前选中内容与寄存器之间的操作。因为是<code>y</code>所以就是将当前选中的内容复制到<code>&quot;a</code>中，如果是<code>&quot;ap</code>的话就是将命名寄存器<code>&quot;a</code>中的内容粘贴到选中的位置上来。</p>
<h2 id="匿名寄存器"><a href="#匿名寄存器" class="headerlink" title="匿名寄存器"></a>匿名寄存器</h2><p>匿名寄存器基本就是我们最常用的那个，平时<code>d/x</code>的删除操作都会将被删除的内容存到这个匿名寄存器中，而通过<code>y</code>复制的内容则会放到<code>&quot;0</code>的编号寄存器上，不过这个<code>&quot;0</code>寄存器会一直保持与匿名寄存器<code>&quot;&quot;</code>相同的内容。正因为如此才会出现上面提到的现象：“复制了一段内容A，选中B粘贴，原来B的位置就被A替换了；再选中C粘贴，替换C位置的不是A而是B”，因为在B被A替换时，匿名寄存器<code>&quot;&quot;</code>中就已经是内容B了。</p>
<h2 id="编号寄存器"><a href="#编号寄存器" class="headerlink" title="编号寄存器"></a>编号寄存器</h2><p>编号寄存器中，<code>&quot;0</code>保存的是你复制的内容，<code>&quot;1</code>~<code>&quot;9</code>保存的是删除的内容、上次删除的内容、上上次删除的内容等历史9次删除的内容。</p>
<p>这也正是解决上述问题的关键所在了。下面我们来尝试这解决上面的问题，前三步是一样的，从第四步开始就有区别了。</p>
<ol>
<li>手动替换第一处的<code>break</code></li>
<li>复制<code>break</code></li>
<li>找到下一处需要替换的地方选中</li>
<li>在命令模式下输入<code>&quot;0p</code></li>
<li>找到下一处需要替换的地方选中</li>
<li>再命令模式下输入<code>&quot;0p</code></li>
<li>重复操作直到完成</li>
</ol>
<p>其中<code>&quot;0p</code>操作就是从编号为0的编号寄存器中粘贴内容。如果直接<code>p</code>的话是从默认的匿名寄存器中粘贴的，内容也就是刚刚被删掉的内容了。</p>
<h2 id="小删除寄存器"><a href="#小删除寄存器" class="headerlink" title="小删除寄存器"></a>小删除寄存器</h2><p>不足一行的删除操作会将被删除的内容放到小删除寄存器<code>&quot;_</code>中</p>
<h2 id="命名寄存器"><a href="#命名寄存器" class="headerlink" title="命名寄存器"></a>命名寄存器</h2><p>命名寄存器就很好理解了，就相当于一些贴了标签的小盒子。<code>&quot;ay</code>就是复制内容到命名寄存器<code>&quot;a</code>中，<code>&quot;bp</code>就是从命名寄存器<code>&quot;b</code>中粘贴内容出来。</p>
<p>当你选中了一坨内容<code>&quot;ay</code>后，再选中另一坨<code>&quot;ay</code>，如你所想，之前的内容被替换了；但是需要注意的一点是，如果你选中了一坨内容<code>&quot;ay</code>后，再选中另一坨<code>&quot;Ay</code>就会将当前内容追加到<code>&quot;a</code>中。也就是说当使用大写字母表示命名寄存器复制时，是会追加而非覆盖的。</p>
<h2 id="黑洞寄存器"><a href="#黑洞寄存器" class="headerlink" title="黑洞寄存器"></a>黑洞寄存器</h2><p>默认情况下删除内容时会将被删除的内容放到<code>&quot;1</code>和<code>&quot;&quot;</code>两个寄存器中，但是如果选中后使用<code>&quot;_x</code>或者<code>&quot;_d</code>的方式删除，则会将被删除的内容丢到黑洞中，也就是说并不会覆盖<code>&quot;1</code>和<code>&quot;&quot;</code>。所以使用黑洞寄存器也能解决上述问题</p>
<ol>
<li>手动替换第一处的<code>break</code></li>
<li>复制<code>break</code></li>
<li>找到下一处需要替换的地方选中</li>
<li><code>&quot;_x</code>删除</li>
<li><code>p</code>粘贴过去</li>
<li><code>&quot;_x</code>删除</li>
<li><code>p</code>粘贴过去</li>
<li>重复操作直到完成</li>
</ol>
<h1 id="0X03-后记"><a href="#0X03-后记" class="headerlink" title="0X03 后记"></a>0X03 后记</h1><p>vim果然是真的<strong>编辑器之神</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> vim </tag>
            
            <tag> tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我眼中的「正版」与「盗版」]]></title>
      <url>/2019/01/13/genuine-piracy/</url>
      <content type="html"><![CDATA[<h1 id="0X00-何为正版"><a href="#0X00-何为正版" class="headerlink" title="0X00 何为正版"></a>0X00 何为正版</h1><blockquote>
<p>正版的即“正确地使用版权”。而版权是属于版权所有人的，版权所有人提出使用条件，使用者只要符合条件，就算是正确地使用，就不违反版权法。</p>
</blockquote>
<p>以上来自<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E7%89%88">维基百科：“正版”词条</a></p>
<h1 id="0X01-我的正版观念"><a href="#0X01-我的正版观念" class="headerlink" title="0X01 我的正版观念"></a>0X01 我的正版观念</h1><p>正确的版权观念当然应该是在任何情况下都要“正确的使用版权”。但是几乎不会有人能做到这一点，我这里不谈政治正确，只是说一下我个人的正版观念。我的正版观念简单说来就是“在自己条件允许的情况下尽可能的使用正版”，当然这里的条件允许不只是指的经济条件，还有各种其他的因素。</p>
<p>比如说电影，按照最正确的正版意识来说应该是在上映时在电影院观看，院线下映后在各个视频网站观看或单独购买光盘/数字授权等。我个人只做到一部分，电影还在院线时我要么去电影院观看要么就等下映后在线观看，从来不下载观看“枪版”和“泄漏版”，不过下映比较久后也有可能会通过“torrent（也就是种子）”下载到本地观看。</p>
<p>音乐也是类似。我一般都是使用本地音乐播放器听歌，不论是在电脑还是手机上。不过每次发现新音乐都是通过在线播放器，当喜欢的新音乐达到了一定数量后就充值对应平台的会员把他们下载下来，继续使用本地播放器播放。</p>
<a id="more"></a>
<p>书籍则比较简单，选择性购买纸质版或Kindle的电子版就行了，坚决抵制盗版图书。</p>
<p>游戏和书籍比较类似，坚决抵制盗版游戏。尤其是现在PS4商店和Steam越发成熟，获得正版游戏的方式越来越简单，而且游戏也没有那么贵的情况下没有理由不购买正版。毕竟作为一个程序员非常清楚一款游戏背后要付出多少东西，所以一个 <em>GTA V</em> 卖一百多块真的不贵了，更不用说那些只卖几十块的独立游戏和国产游戏了。</p>
<p>软件方面打算单独说，作为一名程序员同样清楚一款优秀的软件背后所要付出的努力与心血。</p>
<h1 id="0X02-开源不等于免费，更不等于无限制"><a href="#0X02-开源不等于免费，更不等于无限制" class="headerlink" title="0X02 开源不等于免费，更不等于无限制"></a>0X02 开源不等于免费，更不等于无限制</h1><blockquote>
<p>在英语中，“自由软件”，即Free Software，这个词很容易被误解：Free一词既有免费的意思，也有自由的意思。而我们所谓的自由软件，则是“一类可以赋予用户指定自由的软件”。要解决这个问题，我们发布了自由软件的定义。为了方便理解，我们解释自由软件中Free，是自由言论中所说的自由，而非免费赠饮中的免费。这显然不是个理想的解决方案，它无法完全杜绝这一问题。一个意思正确，又没有歧异的词显然更好些，不过前提是这词不会引起其他麻烦。</p>
</blockquote>
<p>上述内容出自<a href="https://www.gnu.org/philosophy/open-source-misses-the-point.html">GNU组织  关于“自由软件”和“开源”的常见误解</a></p>
<p>除了费用问题意外还有一个常见的误解“这不是开源软件吗，难道不是我随便怎么搞？”。其实不然，开源软件也都会拥有一个开源许可证，常见的有<code>GPL/MIT/Apache</code>等，使用这些软件也需要遵守他们所使用的许可证。这样才算是真正的“正确的使用版权”。</p>
<h1 id="0X03-软件授权需要注意的地方"><a href="#0X03-软件授权需要注意的地方" class="headerlink" title="0X03 软件授权需要注意的地方"></a>0X03 软件授权需要注意的地方</h1><p>很多时候软件授权协议是一个比较麻烦的事情，以为自己购买了正版就随意使用，经常会违反对应的协议。</p>
<ol>
<li>比如当你购买了一份Office授权后，在自己公司的电脑上激活了软件，在自己家里也登录了对应的账号，那么此时也就违反了Office的个人版用户协议；</li>
<li>比如当你使用Teamviewer时，从朋友家里连接到自己家里是免费的，因为用户协议说个人使用免费。但是从自己家里连接到公司就违反了个人用户的协议，虽然软件不一定可以识别到这种违规，但是这确实是不符合用户协议的；</li>
<li>某些IDE会区分社区版、个人版和企业版。社区版开发的软件不能售卖、个人版的IDE不能用与企业等。</li>
<li>Jetbarins家的协议就比较宽松，社区版可用于一切形式的开发，个人购买的也可以用于公司的商业开发。但是其中需要注意的一点是个人购买是授权给个人的，而企业购买则是授权给某一位置。简单地说就是“你自己买的Jetbarins的IDE离职后可以在家里用，也可以到下一家使用。但是如果你用的是公司提供的IDE授权，则不能带回家更不能带到另一家公司”。</li>
</ol>
<h1 id="0X04-后记"><a href="#0X04-后记" class="headerlink" title="0X04 后记"></a>0X04 后记</h1><p>写这篇博文主要是为了让自己进一步的提升版权意识，并能为大家的版权意识尽一分力。</p>
]]></content>
      
        
        <tags>
            
            <tag> None </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何将自己的时间管理起来]]></title>
      <url>/2018/11/25/manage-our-time/</url>
      <content type="html"><![CDATA[<h1 id="0X00-时间都去哪儿了"><a href="#0X00-时间都去哪儿了" class="headerlink" title="0X00 时间都去哪儿了"></a>0X00 时间都去哪儿了</h1><p>好多人都会有这种情况，整整两天的周末回忆起来却不知道自己做了什么，明明也没看几部电影、没怎么打游戏，也没怎么学习，时间怎么就不见了呢？更为常见的一种是“等我有空了就搞”、“等我空了一定去一趟哪儿哪儿哪儿”、“下周六一定要去吃XXX”，然后就再也想不起来了。真正空下来的时候又觉得自己没事做，完全想不起来之前列出来比卷纸还长的todo list了。</p>
<p>实际上大家几乎不会真的有“无事可做”的时候，只是有空的时候想不起来之前的计划，定了计划又不定执行时间。最后到头来就落得这么一个不仅很闲又啥事都做不了的境况。比如你一定会有过上午还在说“有空了一定去一趟本地的博物馆看看”，下午的时候就趴在床上不知道要干啥的情况。这种在我们中太长见了，通常我们都是就这么趴在床上继续下去了。</p>
<p>以我个人来说，在主动管理自己时间的时候我一天下来有很多事要做，感觉自己很充实。那段时间里我玩游戏、看书、写代码甚至去一公里外的镇上吃一家好吃的包子都会列在我的计划中，严格按照计划行事。</p>
<p>后来大四实习的一年因为刚刚出来独自生活再加上刚开始工作觉的比较累，那一年基本就什么都没做。每天晚上对着电脑不知道在干吗，周末在家里也是完全懵逼的。都不说学习了，就连游戏和电影都没怎么碰过，所以将自己的时间管理起来指的当然不是说只于学习和提升自己，而是单纯的管理时间而已。把自己的时间管理起来了以后会发现自己的游戏通关更快了、看书效率更高了、电影看得更多了、好多计划过没有付诸时间的事情都从TODO中清理掉了。唯一边少的时间就是自己无聊发呆的时间，所以说来这是一门血赚的生意。换句话说周末两天趴在床上发呆玩手机是最咸鱼的，就算是起来看三部电影玩几个小时PS4都要比这发呆来的好吧。</p>
<p>最近这段时间又将时间管理起来了，才觉得自己的生活又充实了起来。不仅通关了几款早就想玩的游戏、看了好多部想看却没看的电影、就连好多本想看没看的书也都看完了。</p>
<a id="more"></a>
<h1 id="0X01-日历方案"><a href="#0X01-日历方案" class="headerlink" title="0X01 日历方案"></a>0X01 日历方案</h1><p>说是将自己的时间管理起来，那具体该怎么实施呢？最简单的一个方案就是日历了，几乎任何手机都带有日历和日程提醒功能，用它就可以了。每个周期定一个时间来安排下一个周期的日程。</p>
<p>比如每周日晚上睡前拿出半个到一个小时来安排接下来一周的任务，安排日程最重要的一点就是“时间精确”。当你把“参观省博物馆”的日程设置为“本周的周三到周五”，那么基本上就代表着这周是去不成博物馆了，因为八成会被拖到最后然后放弃掉。所以一定要精确到具体时间，比如“2018-11-25 14:00参观省博物馆”、“2018-11-25 10:00收拾屋子”这种。到了时间就去做该做的事，一定要有很高的自控力和执行力。</p>
<p>在系统日历中通常都可以给一个日程设置多个提醒，要利用好这一点。比如你计划下午要看电影，那就设置一个类似这样的日程“今天 15:00观看XX 电影，并添加一个提前半小时的提醒”。这样在14:30的时候你就会被提醒半小时后的看电影日程，便于安排此时手中正在做的事情。</p>
<h1 id="0X02-Google日历"><a href="#0X02-Google日历" class="headerlink" title="0X02 Google日历"></a>0X02 Google日历</h1><p>如果能够科学上网的话，建议Android用户使用Google日历。Google日历比一般系统自带的日历功能更加完善，而且还带有同步的功能。首先来说Google日历可以给不同的日程设置不同的颜色标签，我们可以使用颜色标签给这些日程分类或是区分他们的优先级和重要度。Google日历在登录了自己的账号后可以跟Chrome进行同步，在Chrome上安装一个Google日历的扩展之后能同步查看到手机上看到的日程，并且在对应的时间电脑也会弹出通知提示日程。</p>
<p>在Android上的Google日历体验是很不错的，建议有条件的同学都使用Google日历替换掉系统的日历功能。在IOS上我不清楚有没有Google日历可以用，不过Apple也有自己对应的方案呢。</p>
<h1 id="0X03-Microsoft套件"><a href="#0X03-Microsoft套件" class="headerlink" title="0X03 Microsoft套件"></a>0X03 Microsoft套件</h1><p>微软套件中的outlook也是一个这样的工具，在邮件功能之外的日程管理也是很好用的。outlook可以从邮件中智能识别相关日程并导入（Gmail/Google日历也可以，Apple其实也可以）。如果是在Windows环境下使用outlook也是一个不错的选择，在Windows下微软的日程可以直接以系统通知的形式推送，在手机上安装一个outlook就可以实现手机与电脑的同步了。</p>
<h1 id="0X04-Apple套件"><a href="#0X04-Apple套件" class="headerlink" title="0X04 Apple套件"></a>0X04 Apple套件</h1><p>Apple套件我是没用过的，毕竟没买过苹果的任何产品。不过IOS和Mac上同步日程还是完全没问题的，而且配合siri使用起来应该也是很方便的。</p>
<h1 id="0X05-GTD软件"><a href="#0X05-GTD软件" class="headerlink" title="0X05 GTD软件"></a>0X05 GTD软件</h1><p>更好的选择是使用GTD软件，比如滴答清单这种，以滴答清单为例介绍一下这类软件。滴答清单是一个以任务为基础的时间管理软件，用户每次想到的任何东西都要在滴答清单中创建为一个任务，我们可以个任务指定“开始时间、提醒时间、优先级、评论备注、附件”等一系列属性。</p>
<p>我是在滴答清单中创建了多个目录，而且是支持多级目录的，每个目录下有着对应的任务，例如“工作内容：研发工作、工作会议、其他工作，个人提升：专业进阶、博客更新、业余领域、阅读进度，业余生活：个人生活、电影电视、兴趣爱好、社交活动”这样。</p>
<p>每次创建的任务默认放在一个叫做“收集箱”的地方，等一周下来收集箱里应该就有了好多任务，再找一个时间将收集箱里的任务一个个的配置时间并且分到对应的目录中。</p>
<p>而且滴答清单还集成了“番茄时间法”，这个就不多介绍了，可以搜索了解一下。对于我来说比较重要的是滴答清单集成的“统计总结”功能，每周最后的时候我都喜欢点开滴答清单的这个功能来看一下自己这周都完成了什么任务。也不是为了总结这一周我有多少多少的收获，单纯的是看着这些被划掉的任务觉得很爽，感觉特别有成就感。</p>
<h1 id="0X06-最重要的一点"><a href="#0X06-最重要的一点" class="headerlink" title="0X06 最重要的一点"></a>0X06 最重要的一点</h1><p>说了这么多，如果说这篇博文中最重要的一点，就是这段说到的“自控力”了。如果没有良好的“自控力”，就算用再好的工具，弹出再多的提醒，进行再周密的安排如果不去执行也是完全没有用的。</p>
<p>在这里希望所有看到这篇博文的同学都有不错的自控力 :)</p>
]]></content>
      
        
        <tags>
            
            <tag> GTD </tag>
            
            <tag> TickTick </tag>
            
            <tag> Todo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[把自己的VPS/Server用起来]]></title>
      <url>/2018/11/22/using-vps/</url>
      <content type="html"><![CDATA[<p>好多人的VPS或是服务器就只跑了一个小服务或是小程序，虽然我们多数人的VPS性能比较差但是只跑一个小服务一个小程序未免还是有些浪费。大可将其充分利用起来，毕竟性能再差也是一个24小时不停机且带有一个独立公网IP的机器。这里我介绍一下我跑在VPS上的一些服务和使用中的一些经验和建议，希望可以给各位带来些许的帮助吧。</p>
<h1 id="0X00-操作系统"><a href="#0X00-操作系统" class="headerlink" title="0X00 操作系统"></a>0X00 操作系统</h1><p>通常我们自己的VPS性能都不怎么强，很多人都是买的单核512M内存的，所以Windows Server系统通常是不用想了。那么众多的Linux发行版本又该如何选择呢？其实因为我们是个人使用，不用过分考虑发行版本的区别，哪个用着习惯就用哪个。我自己的VPS用过一段时间的Fedora和Debian，都是很不错的。如果是针对Linux新手的话我还是比较建议使用Ubuntu和CentOS，因为这两个系统的用户群体很大，出现问题时候在网络上也更容易找到相关的解决方案。</p>
<p>还有就是图形界面，Linux作为服务器操作系统时是完全没有必要安装图形界面的。想必购买了VPS的用户应该也多少能操作一下Linux，就更没有必要浪费系统资源和时间去安装图形界面和VNC了。</p>
<h1 id="0X01-机场建设"><a href="#0X01-机场建设" class="headerlink" title="0X01 机场建设"></a>0X01 机场建设</h1><p>大家如果购买的是国外的VPS那么多数情况下都是为了跨过长城，不过好多人在使用的都是基于命令行的Shadowsocks服务，不仅配置起来不太直观，分享给其他人用的时候也不好管理。有一个开源项目<a href="https://github.com/go-ignite/ignite">ignite</a>可以部署一整套的Shadowsocks管理系统。这样你的VPS就不再是飞机跑道了，而是进化成了一个国际机场 :)</p>
<p>这是一个Go语言实现的基于Web的Shadowsocks管理工具。多个用户使用时会创建多个Docker容器，每个连接使用独立的环境与公网端口便于管理。</p>
<p>配置好后可以在admin端创建邀请码，每个邀请码对应着使用时间与可用的流量。将邀请码分发给其他人后，其他人登录到你的client端便可以使用激活码注册自己的用户，并且启动一个新的Shadowsocks连接。作为管理员可以实时观察各位用户的剩余时间和剩余流量，并且可以进行延长时间和重置流量等操作。</p>
<a id="more"></a>

<h1 id="0X02-搭建博客"><a href="#0X02-搭建博客" class="headerlink" title="0X02 搭建博客"></a>0X02 搭建博客</h1><p>搭建博客也是一个常规操作了，通常的选择是两种：以<a href="https://hexo.io/zh-cn/">Hexo</a>为代表的静态博客和以<a href="https://cn.wordpress.org/">Wordpress</a>为代表的动态博客。这里更推荐使用Hexo，这也是处于对VPS性能的考虑。我们的VPS通常性能都不强劲，所以使用静态博客可以每次编辑完博文后编译上传，每次用户访问时也只是访问了几个静态文件，再加上Nginx的配合完全可以实现个人博客的需求。Wordpress类的动态博客虽然扩展性很强，评论和浏览量等常见功能的高度集成也很方便，不过问题在于博客的运行需要数据库来支持，这在我们的低性能VPS上通常会导致访问速度缓慢。</p>
<p>静态博客对比与动态博客还有一个好处就是非常便于迁移，针对静态博客只需要修改一下地址重新发布就算是完成了迁移；但是动态博客迁移不仅要重新配置PHP或是其他语言的运行环境，还需要备份并迁移数据库。</p>
<p>相比来说动态博客最大的优势就在于大量的插件与“动态”本身，很多比较大的网站也都是使用Wordpress搭建的。</p>
<h1 id="0X03-自己的Github"><a href="#0X03-自己的Github" class="headerlink" title="0X03 自己的Github"></a>0X03 自己的Github</h1><p>众所周知Github上的私有仓库是收费的，国外的Gitlab与国内的gitee个人是可以使用免费私有仓库的，不过有时候为了折腾我们还是可以打造一个自己的私人Github。其中<a href="https://gogs.io/">Gogs</a>就是一个极易搭建的自助Git服务，可以简单的使用docker部署，甚至可以直接下载二进制文件运行。而且Gogs对系统配置要求极低，运行在VPS甚至是树梅派上都是没问题的。</p>
<p>部署好Gogs后也可以使用Web进行仓库与用户的管理，通过git命令进行版本控制<code>push pull clone</code>，就像Github一样。并且由于是国人主导开发的项目，整个系统与帮助文档等都是100%汉化的，对新手来说是相当有好的。</p>
<h1 id="0X04-代理下载点"><a href="#0X04-代理下载点" class="headerlink" title="0X04 代理下载点"></a>0X04 代理下载点</h1><p>代理下载点就比较简单，每次遇到在国内网络环境中下载特别慢的文件，我都喜欢在VPS上下载好再从VPS上拖回来。在VPS上可以使用aria2来进行多线程下载，拖回本地的时候可以在VPS上长期启一个Nginx作为下载站，也可以在文件目录下通过命令<code>python3 -m http.server</code>临时启一个web服务，等文件拖回来了再关掉。</p>
<h1 id="0X05-注意安全"><a href="#0X05-注意安全" class="headerlink" title="0X05 注意安全"></a>0X05 注意安全</h1><p>毕竟我们的VPS都是处在公网环境下的，所以一定要注意安全。比如防火墙不要彻底关掉，用到哪个端口就开放哪个端口；ssh尽量使用公钥验证登录而非密码；对外开放的服务比如数据库或web端的密码不要使用弱密码。</p>
<p>一旦自己的VPS被拿下，轻则被删库跑路，重则拿着你的用户名密码到处撞库，搞不好就会有更多的损失。所以平时自己不同网站不同用户的密码也尽量区分开吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> VPS </tag>
            
            <tag> Shadowsocks </tag>
            
            <tag> git </tag>
            
            <tag> Server </tag>
            
            <tag> blog </tag>
            
            <tag> proxy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux上的简单文本处理]]></title>
      <url>/2018/11/19/linux-text/</url>
      <content type="html"><![CDATA[<h1 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h1><p>最开始使用Linux的时候一直搞不懂为什么Linux下会有这么多在命令行里操作文本的工具。一度以为这些玩意儿没啥大用，但是随着使用频率与强度的增加才发现这些东西是Linux上非常有魅力的部分。</p>
<h1 id="0X01-cat"><a href="#0X01-cat" class="headerlink" title="0X01 cat"></a>0X01 cat</h1><p><code>cat</code>命令是最简单的，<code>cat filename</code>就是将文件内容以文本的形式输出到命令行。这个命令主要是作为后面组合技的基础，威力到后面cat的作用才能发挥出来。</p>
<h1 id="0X02-head"><a href="#0X02-head" class="headerlink" title="0X02 head"></a>0X02 head</h1><p><code>head</code>是查看文件的前面部分，默认情况下是前10行，可以使用<code>-n</code>参数指定具体的行数。如果你有一个文件巨大无比，比如说几个G，且你只关心前100行，那怎么搞呢。使用<code>cat</code>是不可能的了，毕竟你cat一下之后回去睡一觉屏幕都可能还没滚完，何况你还得翻回最上面查看开头的内容。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head filename -n 100   <span class="comment"># 查看文件的前100行</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0X03-tail"><a href="#0X03-tail" class="headerlink" title="0X03 tail"></a>0X03 tail</h1><p><code>tail</code>类似于<code>head</code>命令，不过这个是用来查看文件最后的，同样支持使用<code>-n</code>参数来指定最后多少行。不过这个命令最多用于查看日志文件。例如你有一个日志文件每秒都在源源不断的写入新内容，此时又想看最新的日志怎么搞呢。<code>tail</code>提供了一个<code>-f</code>的参数，使用<code>tail filename -f</code>就可以输出文件最后的部分且每当新内容写入文件时会追加显示，直到你<code>Ctrl + C</code>为止。</p>
<p>这个技能也是后面组合技的基础技能之一，在组合技中更能发挥威力。</p>
<h1 id="0X04-grep"><a href="#0X04-grep" class="headerlink" title="0X04 grep"></a>0X04 grep</h1><p>查找文件中带有某些特征的行。一个例子：你想找到文件<code>student_list.txt</code>中所有带有“小明”的行，那就可以<code>grep 小明 student_list</code>。这样就可以看到这个文件中所有包含“小明”的行，并且“小明”二字通常会高亮输出，而不包含的则完全不会输出。</p>
<p>值得注意的一点是<code>grep</code>是使用正则表达式进行检索的，所以可以使用正则来匹配内容，所以grep的战斗力很强。比如我们可以使用grep配合正则表达式查找日志文件中所有符合我们要求的内容。</p>
<p>grep还有一种常用的方法，试想这样一个例子：你的一个目录里有大量的文件，你想找到包含<code>db_password</code>的行来修改刚刚更换的密码，但是已经忘了在几个地方配置过了，那该咋搞？可以在目录中使用<code>grep -Rn &quot;db_password&quot; .</code>来查找。这个命令可以递归的grep当前目录下所有的文件，找到含有<code>db_password</code>的行并带有文件名和行号。</p>
<p>grep是组合技中的神技，在grep的加持下组合技可以变得更强大。</p>
<h1 id="0X05-ag"><a href="#0X05-ag" class="headerlink" title="0X05 ag"></a>0X05 ag</h1><p>上面谈到的<code>grep -Rn &quot;xxxxx&quot; .</code>的方法固然好用，但是每次都写一便还是有些麻烦。所以有了这个命令<code>ag</code>，它可以完全替换掉这个<code>grep -Rn &quot;xxx&quot; .</code>的组合，不仅省时而且得到的输出也更人性化更好看。</p>
<blockquote>
<p>通常系统不会自带ag命令，包含在一个名为<code>the_silver_searcher</code>的包中，如果找不到这个的话可以搜索安装一下。</p>
</blockquote>
<h1 id="0X06-jq"><a href="#0X06-jq" class="headerlink" title="0X06 jq"></a>0X06 jq</h1><p><code>jq</code>是一个用于在命令行中解析输出Json内容并格式化高亮的工具，今天他才帮了我的大忙。jq命令可以将其中的字符串转码为人类可读的类型，并且进行缩进和高亮上色。</p>
<p>如果你有一个名为<code>test_file.json</code>的文件，内容为标准的Json，想要查看的话就可以使用<code>jq . test_file.json</code>命令来查看格式化并高亮之后的结果。jq工具也可以作为组合技的一部分提升工作效率。</p>
<h1 id="0X07-组合技基础：管道"><a href="#0X07-组合技基础：管道" class="headerlink" title="0X07 组合技基础：管道"></a>0X07 组合技基础：管道</h1><p>管道就是键盘上的那个小竖线<code>|</code>，在Linux中是一个非常重要的概念。简单的理解就是通过管道连接的两串命令可以将前面一串的输出作为后面一串的输入。</p>
<p>具体用法展示就在下面的组合技部分吧，直接在这里说也说不太清楚。</p>
<h1 id="0X08-重定向"><a href="#0X08-重定向" class="headerlink" title="0X08 重定向"></a>0X08 重定向</h1><p>重定向类似于管道，只是重定向是将输出作为文件或使用文件作为输入。在命令中重定向是使用<code>&lt; / &gt;</code>这对大于好和小于号表示的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello,world&quot;</span> &gt; new_file <span class="comment"># 将本应该输出的hello,world写入到名为new_file的文件中</span></span><br><span class="line">cat &lt; new_file  <span class="comment"># 将new_file的内容作为cat的传入参数</span></span><br></pre></td></tr></table></figure>

<h2 id="0X08-1-标准输出、标准错误、标准输入"><a href="#0X08-1-标准输出、标准错误、标准输入" class="headerlink" title="0X08-1 标准输出、标准错误、标准输入"></a>0X08-1 标准输出、标准错误、标准输入</h2><p>系统中存在”标准输出/标准输入/标准错误”三个概念，通常标准输出与标准错误都是我们的终端，而标准输入是键盘。<br>一个命令的输出会分为“标准输出”与“标准错误”。顾名思义，通常的内容使用“标准输出”进行输出，“标准错误”是用来输出错误信息的。<br>直接使用 <code>echo &quot;hello,world&quot;</code> 的时候是将输出内容定向到“标准输出”的，默认是我们的终端。使用命令<code>ping baidu.com &gt; output</code>与<code>ping baidu.com 1&gt; output</code>是一样的，<code>1&gt;</code>代表标准输出，是默认的<br>使用命令<code>ping zdlkfjwle &gt; output</code>会发现还是有内容被打印到了终端上，是因为错误信息使用了“标准错误”来输出，想要重定向标准错误的输出就需要使用<code>ping lkzsdjf  2&gt; output</code>了</p>
<h1 id="0X09-常用组合技"><a href="#0X09-常用组合技" class="headerlink" title="0X09 常用组合技"></a>0X09 常用组合技</h1><p>组合技才是本次的重点，这里介绍几种常用的组合技供大家参考。</p>
<p>追踪日志：<br><code>tail -f nginx_xxx.log | grep timeout</code>实时追踪在一个持续追加的日志文件，并且只展示其中包含<code>timeout</code>的行</p>
<p>追踪多个日志：<br><code>tail -f nginx_success.log nginx_error.log | grep submit</code>实时追踪多个文件，并展示其中包含<code>submit</code>的行</p>
<p>格式化一个Json文件：<br><code>cat old_file.json | jq &gt; new_file.json</code>将<code>old_file.json</code>格式化并生成一个新文件<code>new_file.json</code></p>
<p>找到记不起来ip的服务器：<br><code>history | grep ssh</code>将你的命令行历史中所有包含ssh的找出来</p>
<p>查找一些进程：<br><code>ps aux | grep java</code>查找你的java进程</p>
<p>给文件行排序：<br><code>cat student.txt | sort &gt; new_student.txt</code>给一个名为student.txt的文件排序并生成一个新的</p>
<p>假装模糊搜索：<br><code>find . | grep xxx | grep yyy | grep zzz</code>你忘了文件在哪，文件名也记不全，可以用这种方式。在母目录执行，相当于找到所有当前目录下的文件中同时包含<code>xxx</code>和<code>yyy</code>和<code>zzz</code>的</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用nose与mock对Python程序进行简单的单元测试]]></title>
      <url>/2018/11/03/python-unittest/</url>
      <content type="html"><![CDATA[<h1 id="0X00-install"><a href="#0X00-install" class="headerlink" title="0X00 install"></a>0X00 install</h1><p>安装nose：<code>pip install nose</code><br>安装mock：<code>pip install mock</code></p>
<blockquote>
<p>Python3 中mock模块已成为标准库，无需单安装</p>
</blockquote>
<p>在任意目录下执行<code>nosetests</code>看到有输出就是已经安装好了<code>nose</code>。进入到<code>Python shell</code>中执行<code>import mock</code>没有报错也就是<code>mock</code>安装好了。</p>
<h1 id="0X01-用于测试的代码"><a href="#0X01-用于测试的代码" class="headerlink" title="0X01 用于测试的代码"></a>0X01 用于测试的代码</h1><p>这里先贴出这次被测的代码<code>simple_math.py</code>，是一个非常简单的数字计算类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_add</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_subtraction</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">and</span> b:</span><br><span class="line">            <span class="keyword">return</span> a - b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的代码是有问题的，毕竟是要拿来作为单元测试的样例的嘛。</p>
</blockquote>
<a id="more"></a>
<h1 id="0X02-编写单元测试"><a href="#0X02-编写单元测试" class="headerlink" title="0X02 编写单元测试"></a>0X02 编写单元测试</h1><p>我们要针对上述文件创建一个新的<code>test.py</code>来测试其中的<code>MyMath</code>类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> simple_math <span class="keyword">import</span> MyMath</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mt = MyMath()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add</span>():</span></span><br><span class="line">    res = mt.my_add(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">assert</span> res == <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_subtraction_001</span>():</span></span><br><span class="line">    res = mt.my_subtraction(<span class="number">233</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">assert</span> res == <span class="number">233</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_subtraction_002</span>():</span></span><br><span class="line">    res = mt.my_subtraction(<span class="number">233</span>, <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">assert</span> res == <span class="number">222</span></span><br></pre></td></tr></table></figure>

<p>从代码中可以看到首先导入了需要测试的类<code>MyMath</code>，然后就写了几个<code>test_</code>开头的方法，方法内部是模拟调用<code>MyMath</code>中的方法，并将得到的结果与预期结果相互匹配，最终使用<code>assert</code>语法来判断是否返回了理想的值。测试代码写好之后在当前目录下执行<code>nosetest -v</code>来运行我们的单元测试吧，输出结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">test.test_add ... ok</span><br><span class="line">test.test_subtraction_001 ... FAIL</span><br><span class="line">test.test_subtraction_002 ... ok</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">FAIL: test.test_subtraction_001</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;nose&#x2F;case.py&quot;, line 197, in runTest</span><br><span class="line">    self.test(*self.arg)</span><br><span class="line">  File &quot;&#x2F;home&#x2F;shawn&#x2F;Workstadion&#x2F;utils_test&#x2F;test.py&quot;, line 17, in test_subtraction_001</span><br><span class="line">    assert res &#x3D;&#x3D; 233</span><br><span class="line">AssertionError</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 3 tests in 0.002s</span><br><span class="line"></span><br><span class="line">FAILED (failures&#x3D;1)</span><br></pre></td></tr></table></figure>

<h1 id="0X003-简单解释一下"><a href="#0X003-简单解释一下" class="headerlink" title="0X003 简单解释一下"></a>0X003 简单解释一下</h1><p>上面的测试就执行完了，那我们来拆分一下这个单元测试的流程吧。</p>
<ol>
<li>首先我们执行了<code>nosetest -v</code>命令，这个命令就是开始进行单元测试的，其中<code>-v</code>参数是用来展示更加丰富的输出的，如果不加这个参数的话运行结果会更清爽一些</li>
<li>执行命令之后nose会自己查找当前目录下名为<code>test.py</code>或其他以<code>test_</code>开头的python文件，并且执行这些文件中编写好的以<code>test_</code>开头的方法（就比如我们代码中的<code>test_add/test_subtraction</code>）</li>
<li>逐个执行上面找到的方法</li>
<li>输出最后结果</li>
</ol>
<p>如果在执行单个<code>test_xxx</code>方法的时候没有抛出异常，那么就认为这个测试(test case)是通过了的，如果抛出了异常则认为此处的测试不能通过。但是在单元测试中有一点与普通Python程序不同，普通Python程序遇到抛出的异常时就会层层上抛，而这里会收集展示出来，然后继续运行下面的测试。</p>
<h1 id="0X04-换一个姿势写测试"><a href="#0X04-换一个姿势写测试" class="headerlink" title="0X04 换一个姿势写测试"></a>0X04 换一个姿势写测试</h1><p>还是上面的被测代码，这次不是单纯使用多个方法来完成测试了。面向对象的思想也可以对应的放到单元测试中，比如我们针对<code>MyMath</code>类搞一个单元测试，这些测试内容也整理为一个类，不过值得注意的是**这里的类名一定要为<code>TestClass</code>**否则是运行不到的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> simple_math <span class="keyword">import</span> MyMath</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        mt = MyMath()</span><br><span class="line">        res = mt.my_add(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">assert</span> res == <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_subtraction_001</span>(<span class="params">self</span>):</span></span><br><span class="line">        mt = MyMath()</span><br><span class="line">        res = mt.my_subtraction(<span class="number">233</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">assert</span> res == <span class="number">233</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_subtraction_002</span>(<span class="params">self</span>):</span></span><br><span class="line">        mt = MyMath()</span><br><span class="line">        res = mt.my_subtraction(<span class="number">233</span>, <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">assert</span> res == <span class="number">222</span></span><br></pre></td></tr></table></figure>

<h1 id="0X05-setup与teardown方法"><a href="#0X05-setup与teardown方法" class="headerlink" title="0X05 setup与teardown方法"></a>0X05 setup与teardown方法</h1><p>上面的测试中我们每一个test_case中都有一行<code>mt = MyMath()</code>是不是感觉有些蠢，其实是可以避免这个方法的。定义两个方法<code>setup/teardown</code>，这些方法在每执行一个testcase的时候都会执行，不同的是<code>setup</code>执行在testcase之前，而<code>teardown</code>执行在testcase之后。下面例子中就是这样的，每次使用<code>mt</code>对象时都实例化一个新的，用完再删掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> simple_math <span class="keyword">import</span> MyMath</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.mt = MyMath()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teardown</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.mt = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span>(<span class="params">self</span>):</span></span><br><span class="line">        res = self.mt.my_add(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">assert</span> res == <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_subtraction_001</span>(<span class="params">self</span>):</span></span><br><span class="line">        res = self.mt.my_subtraction(<span class="number">233</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">assert</span> res == <span class="number">233</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_subtraction_002</span>(<span class="params">self</span>):</span></span><br><span class="line">        res = self.mt.my_subtraction(<span class="number">233</span>, <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">assert</span> res == <span class="number">222</span></span><br></pre></td></tr></table></figure>

<p>虽然上面的<code>mt</code>对象没有必要每次生成新的，但是很多情况下其实是需要我们这么做的。考虑这么一种情况：有一个<code>class Student</code>需要测试，而且待测方法有非常非常多，不仅会计算Student实例的各个属性，还要对其进行更新、添加、删除等操作。那么这种情况下每次操作都生成一个新的Student实例并且在testcase结束之后删掉它就是非常有必要的了。</p>
<blockquote>
<p>因为我们不能保证每个方法的幂等性，比如万一这个Student是男的，你在测试了<code>student.change_sex()</code>方法之后显然他就不再是男的了。那接下来再测试一些依赖与性别的地方时就会出问题，比如<code>get_gender()</code>方法你很有可能会写<code>assert student.get_gender() == &quot;Male&quot;</code>，那这个时候就出错了。</p>
</blockquote>
<h1 id="0X06-模拟一些对象"><a href="#0X06-模拟一些对象" class="headerlink" title="0X06 模拟一些对象"></a>0X06 模拟一些对象</h1><p>对，你没有对象的时候可以模拟对象出来(hhh。</p>
<p>还是，首先有一个场景：工作中编写单元测试，被测功能简单说是“从某一接口拿到数据，并对数据进行处理”。那么我们就可以写成这么一个操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_operation_data_from_api</span>(<span class="params">parms</span>):</span></span><br><span class="line">    response = get_data_from_api(parms)</span><br><span class="line">    op_result = operation_data(</span><br><span class="line">        id=response.id,</span><br><span class="line">        order_type=response.order_type,</span><br><span class="line">        administrator_name=response.administrator_name,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">assert</span> op_result.status == <span class="string">&#x27;success&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这段代码看起来是没有问题的，但是如果<code>get_data_from_api</code>调用的API是收费API呢，每次跑单元测试都要去请求一次吗？如果API巨慢无比，每次都要几秒钟才回得来，所有测试有需要调用上百次这个接口呢，我们就干等着吗？这显然是不合理的。此时就可以使用最初提到的<code>mock</code>来模拟数据从而解决上述问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_operation_data_from_api</span>(<span class="params">parms</span>):</span></span><br><span class="line">    response = mock.Mock(   <span class="comment"># Mock可以模拟几乎所有对象、方法等</span></span><br><span class="line">        id=<span class="number">3</span>,</span><br><span class="line">        order_type=<span class="string">&#x27;cpu&#x27;</span>,</span><br><span class="line">        administrator_name=<span class="string">&#x27;root&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    op_result = operation_data(</span><br><span class="line">        id=response.id,</span><br><span class="line">        order_type=response.order_type,</span><br><span class="line">        administrator_name=response.administrator_name,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">assert</span> op_result.status == <span class="string">&#x27;success&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过对response的模拟，我们可以实现不用真正去请求API就能继续测试的方法。因为我们这里编写测试的目的是正确处理response所以可以模拟response。如果我们的目的是测试<code>get_data_from_api()</code>这个方法的话那就不能想这样模拟了。</p>
<h1 id="0X07-Mock模拟其他东西"><a href="#0X07-Mock模拟其他东西" class="headerlink" title="0X07 Mock模拟其他东西"></a>0X07 Mock模拟其他东西</h1><p>mock可以模拟一个属性，多层属性还能模拟方法。模拟多个属性与模拟一个属性是一样的，只需要一路<code>.</code>下去就可以。中途遇到没有自己定义过的会自动生成一个<code>mock.Mock()</code>放进去。比较有意思的是模拟方法，使用<code>Mock.method_name.return_value</code>就可以模拟<code>method_name</code>方法，并且<code>return_value</code>就是这个方法的返回值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 模拟一个属性</span></span><br><span class="line">    mk = mock.Mock()</span><br><span class="line">    mk.name = <span class="number">233</span></span><br><span class="line">    <span class="keyword">print</span> mk.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟多层属性</span></span><br><span class="line">    mk = mock.Mock()</span><br><span class="line">    mk.base_attribute.name = <span class="string">&#x27;Shawn&#x27;</span></span><br><span class="line">    <span class="keyword">print</span> mk.base_attribute.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟一个方法</span></span><br><span class="line">    mk = mock.Mock()</span><br><span class="line">    mk.get_data_from_api.return_value = &#123;<span class="string">&#x27;data&#x27;</span>: []&#125;</span><br><span class="line">    <span class="keyword">print</span> mk.get_data_from_api()</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Mock </tag>
            
            <tag> nose </tag>
            
            <tag> unittest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django REST framework中不那么常用的Fields]]></title>
      <url>/2018/10/13/drf-fields/</url>
      <content type="html"><![CDATA[<p>平时使用Django REST framework的时候除了常用的几个字段类型之外其实没有哪些字段是必须的了，不过了解一下这些「非必需」的字段能给日常的编程任务带来大幅度的效率提升呢。</p>
<h1 id="0X00-EmailField"><a href="#0X00-EmailField" class="headerlink" title="0X00 EmailField"></a>0X00 EmailField</h1><p>首先是<code>EmailField</code>，这个字段本质上是<code>CharField</code>但是单纯的添加了一个完善的校验，可以免去我们手工编写正则和对应报错信息的过程，简单地定义之后就可以使用了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user_email = EmailFIeld(</span><br><span class="line">  min_length=<span class="number">5</span>,</span><br><span class="line">  max_length=<span class="number">30</span>,</span><br><span class="line">  allow_blank=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="0X01-URLField"><a href="#0X01-URLField" class="headerlink" title="0X01 URLField"></a>0X01 URLField</h1><p>这里的<code>URLField</code>跟上面的<code>EmailField</code>类似，在<code>CharField</code>的本质上添加了对应的校验，使用时会校验该字段是否符合url的校验规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">article_url = URLField(</span><br><span class="line">  min_length=<span class="number">10</span>,</span><br><span class="line">  max_length=<span class="number">100</span>,</span><br><span class="line">  allow_blank=<span class="literal">False</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0X02-IPAddressField"><a href="#0X02-IPAddressField" class="headerlink" title="0X02 IPAddressField"></a>0X02 IPAddressField</h1><p><code>IPAddressField</code>也是一样，只是在<code>CharField</code>上添加校验。不过有一个针对ip的参数<code>protocol</code>，顾名思义，可以设定校验不同版本的ip地址。<code>protocol</code>参数的值从这三个中选一个<code>both/IPv4/IPv6</code>，其中默认选择的是<code>both</code>，也就是说同时会接受IPv4和IPv6两种地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">source_ip4 = IPAddressField(</span><br><span class="line">  required=<span class="literal">True</span>,</span><br><span class="line">  protocol=<span class="string">&#x27;IPv4&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">source_ip6 = IPAddressField(</span><br><span class="line">  required=<span class="literal">True</span>,</span><br><span class="line">  protocol=<span class="string">&#x27;IPv6&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="0X03-DecimalField-带有精度的"><a href="#0X03-DecimalField-带有精度的" class="headerlink" title="0X03 DecimalField  带有精度的"></a>0X03 DecimalField  带有精度的</h1><p>与<code>FloatField</code>不同的是，<code>DecimalField</code>会校验小数点位数，两个重要参数：<code>max_digits</code>数字总长度(不含小数点)，<code>decimal_places</code>小数点后几位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不含小数点最长5位，精确到2位小数；也就是说最大为999.99</span></span><br><span class="line">num_a = DecimalField(</span><br><span class="line">  max_digits=<span class="number">5</span>,</span><br><span class="line">  decimal_places=<span class="number">2</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不含小数点最长7位，精确到3位小数；也就是说最大为9999.999</span></span><br><span class="line">num_b = DecimalField(</span><br><span class="line">  max_digits=<span class="number">7</span>,</span><br><span class="line">  decimal_places=<span class="number">3</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="0X04-DurationField"><a href="#0X04-DurationField" class="headerlink" title="0X04 DurationField"></a>0X04 DurationField</h1><p>关于时间的字段用的最多的就是<code>DateTimeField/DateField/TimeField</code>了，但是这些都是时间点，而<code>DurationField</code>是时间段，就像Python中<code>datetime.timedelta</code>一样，使用的是<code>[DD] [HH:[MM:]]ss[.uuuuuu]</code>格式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">work_duration = DurationField(</span><br><span class="line">  min_value=datetime.timedelta(days=<span class="number">12</span>, hours=<span class="number">10</span>, minutes=<span class="number">32</span>, seconds=<span class="number">4</span>, microseconds=<span class="number">3</span>),</span><br><span class="line">  max_value=datetime.timedelta(days=<span class="number">10</span>, hours=<span class="number">1</span>, minutes=<span class="number">2</span>, seconds=<span class="number">4</span>, microseconds=<span class="number">3</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="0X05-ListField"><a href="#0X05-ListField" class="headerlink" title="0X05 ListField"></a>0X05 ListField</h1><p>列表类型，自身是一个列表，需要单独指定<code>child</code>的类型。create/update的时候需要提供类似这样的参数<code>name_list = [&#39;shawn&#39;, &#39;nwahs&#39;, &#39;shanw&#39;, &#39;sahwn&#39;]</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">email_list = ListField(</span><br><span class="line">  min_length=<span class="number">3</span>,         <span class="comment"># 列表最少有3个元素</span></span><br><span class="line">  max_length=<span class="number">100</span>,       <span class="comment"># 列表最多有100个元素</span></span><br><span class="line">  child=EmailField(     <span class="comment"># 列表中的元素为EmailField</span></span><br><span class="line">    min_length=<span class="number">5</span>,</span><br><span class="line">    max_length=<span class="number">30</span>,</span><br><span class="line">    allow_blank=<span class="literal">False</span>,</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="0X06-DictField"><a href="#0X06-DictField" class="headerlink" title="0X06 DictField"></a>0X06 DictField</h1><p>与<code>ListField</code>很类似，<code>DictField</code>也需要单独指定<code>child</code>的类型，这里的child指的是dict的value，而key则默认为字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">email_list = DictField(</span><br><span class="line">  child=EmailField(     <span class="comment"># dict中的元素为EmailField</span></span><br><span class="line">    min_length=<span class="number">5</span>,</span><br><span class="line">    max_length=<span class="number">30</span>,</span><br><span class="line">    allow_blank=<span class="literal">False</span>,</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="0X07-HiddenField"><a href="#0X07-HiddenField" class="headerlink" title="0X07 HiddenField"></a>0X07 HiddenField</h1><p>有些字段需要用，但是又不需要用户提供，比如说某条数据的更新时间应该在更新数据的时候自动设置为当前时间，而非用户传递的值。这时就可以使用这个<code>HiddenField</code><br>字段。这个字段对用户来说是隐形的，只需要自己在serializer中设定好就可以。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update_time = HiddenField(default=datetime.datetime.now())</span><br></pre></td></tr></table></figure>


<blockquote>
<p>关于Django REST framework中Serializer fields更多的内容可以参考<a href="https://www.django-rest-framework.org/api-guide/fields/#serializer-fields">官方文档</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Django REST framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[职场新人培训总结]]></title>
      <url>/2018/09/19/ks-course/</url>
      <content type="html"><![CDATA[<p>上周参与了公司举办的针对应届毕业生员工的一次培训课程，讲到了职场新人需要注意的一些问题。每个人的收获都是不同的，针对我自己认为的重点总结一下也算是给两天的时间一个交代。</p>
<h1 id="0X00-同理心与同情心"><a href="#0X00-同理心与同情心" class="headerlink" title="0X00 同理心与同情心"></a>0X00 同理心与同情心</h1><p>同情心和同理心我们大家多少都会听过，不过多数人可能都会像我一样没有思考过其中的区别。其实同情心大家都会有，比如你看到一个人流离失所，被家人朋友抛弃，身上破破烂烂蹲在马路边乞讨，多少都会有些同情他，比如给他一些零钱之类的。这能够算是同情心，但是同情心并不是帮助别人的良好方案。我们古人就有“嗟来之食”之说：一位乞讨的人在面对别人用脚踢来的食物时宁可饿死也不会吃一口。我们也都知道既然要给别人食物就不应该用脚踢过去。所以这个提供食物的人是具有同情心的，但是不具有同理心。同理心强调“感同身受”，这不是随随便便就能做到的。</p>
<p>具有同理心的人肯定不会用脚踢过去，可能会带着食物过去他旁边聊起天来。说一说自己以前窘困的时候也是饥不择食，真切的体会他此时的痛苦，在这种情况下大家才能互相坦诚的交流。</p>
<p>同事之间相处也是这样，一天你的同事说最近工作不顺利生活也不如意该怎么办呢？如果你冲上去说“人生不如意十有八九，早晚都会过去的”。听起来是在安慰他，但是实际上并没有用，甚至还会让他变得更丧更不开心。如果你能坐在他旁边分享分享自己工作不顺利的时候，再询问一下他的具体情况，最后再结合自己以前的经历给提供一些好的建议，他一定会好起来的。</p>
<blockquote>
<p>这里不讨论“可怜之人必有可恨之处”等问题，也没有别的什么意思，只是举例而已</p>
</blockquote>
<a id="more"></a>

<h1 id="0X01-通过多个Why找到本质"><a href="#0X01-通过多个Why找到本质" class="headerlink" title="0X01 通过多个Why找到本质"></a>0X01 通过多个Why找到本质</h1><p>有一个例子：有一天下午你同事买了一罐“死亡之翼”(一种高咖啡因含量的咖啡)，为了阻止下午工作的时候犯困。这个问题看起来很合理实际上如果我们尝试这通过几个“为什么”来找到问题的根本原因就可以更彻底的解决问题。</p>
<ul>
<li>A: 为什么要买高因咖啡呢？</li>
<li>S: 因为下午会困「解决点1」</li>
<li>A: 为什么下午会困呢？</li>
<li>S: 因为晚上没睡好「解决点2」</li>
<li>A: 为什么晚上没睡好？</li>
<li>S: 因为三点钟才睡的「解决点3」</li>
<li>A: 为什么三点钟才睡的？</li>
<li>S: 因为昨天下午喝了太多咖啡「解决点4」</li>
<li>A: 为什么喝了太多咖啡？</li>
<li>S: 因为下午太困</li>
</ul>
<p>看似像是一个智障一样的对话，如果我们从不同的地方着手解决就会得到不同的方案。当然这里只是一个例子哈，其实是真的挺智障的，哈哈。在通常逻辑下我们会因为下午困就去买一杯咖啡，但是如果多问一个“为什么”从而得到一个新的答案，就可以着手从「解决点2」来解决问题。「解决点2」的情况下我们可能会尽可能改善睡眠质量，比如改造卧室隔音，更换床垫被褥枕头等。但是如果我们再一次深入下去得到「解决点3」，就可以得到一个“早睡”的解决方案。如果继续深入下去得到「解决点4」，其实就得到了最终的原因：这是一个恶性循环，可能是因为某一天的特殊原因导致休息不好-&gt;下午就喝了很多咖啡-&gt;导致晚上睡不着-&gt;白天犯困-&gt;下午更困-&gt;下午喝大量咖啡-&gt;晚上睡不好。。。所以我们只要克服下来一天的下午，晚上就能睡个好觉，第二天也能精神饱满的工作了。</p>
<p>这个问题虽然说起来比较简单，但是真正运用起来的时候并不是这么简单。就比如上面的例子，“为什么晚上没睡好？”之后就会有多个原因，每个原因再追问下去可能还会得到更多的原因，从而远离真实的原因。</p>
<h1 id="0X02-我说明白了吗？你听懂了吗？"><a href="#0X02-我说明白了吗？你听懂了吗？" class="headerlink" title="0X02 我说明白了吗？你听懂了吗？"></a>0X02 我说明白了吗？你听懂了吗？</h1><p>如果有人跟你说话的时候一直在问“你听懂了吗？理解吗？明白了吗？”，可能你会觉得他把你当成智障了。谁长期面对这种对话都是会不太舒服的，如果有人给你讲一件事情的时候，遇到重点难点问的是“我说明白了嘛？我说的清楚嘛？”，就会舒服多了。所以在跟别人交流的时候尽量多说“我说明白了吗？”而非“你听懂了吗？”。</p>
<h1 id="0X03-如何升职加薪"><a href="#0X03-如何升职加薪" class="headerlink" title="0X03 如何升职加薪"></a>0X03 如何升职加薪</h1><p>老板手下有十个毕业生，工资都是5K，大家的能力分布在“4~8K”之间，老板现在要涨薪了会主要涨谁的呢？肯定是优先选择能力更强的嘛，假设要给其中一个涨薪到8K，肯定会选择实力本来就已经价值8K的。毕竟把工资给价值5K的员工具有赌博性质，不知道他未来什么时候会有或者根本会不会有8K的能力。其实一看就知道了，只是我们平时可能没有想到这里。</p>
<blockquote>
<p>“应该是薪资追能力，而不是能力追薪资”</p>
</blockquote>
<h1 id="0X04-事实与故事"><a href="#0X04-事实与故事" class="headerlink" title="0X04 事实与故事"></a>0X04 事实与故事</h1><p>几乎所有人都会有这么一个行为逻辑“看到/听到事实-&gt;讲故事-&gt;产生情绪-&gt;采取行动”。比如有一天你看到一个人躺在一辆奔驰面前，地上瓜果撒了一地，奔驰的司机站在车旁边指着躺在地上的人大吼大叫。一般会怎么想呢？“呀！奔驰把人撞倒了还不想赔钱！Woc这人真坏，气死老子了！这些有钱人仗势欺人没一个好东西！”</p>
<p>其实这样的思维模式完美的契合了上面的流程：</p>
<ul>
<li>看到/听到事实：地上躺着人，奔驰司机在吼叫</li>
<li>讲故事：司机撞了人还不想赔钱</li>
<li>产生情绪：开始变得愤怒</li>
<li>开始行动：内心下了“有钱人没一个好东西”的定论</li>
</ul>
<p>实际上事实可能完全不是这个样子，你看到的事实只有“某一时刻奔驰司机正在对躺在地上的人大吼大叫”。你不知道这个人是碰磁的还是真的车祸受害者，甚至不知道瓜果是不是他的，奔驰车是不是“司机”的也不好说。</p>
<p>我们很容易就被上面的思维逻辑干扰，动不动就根据自己看到听到的事实去揣测一个“故事”出来并且对自己揣测出来的故事深信不疑。所以当发生这种事情的时候要限制住自己创造故事的能力，最起码要阻止自己讲“故事”变成“事实”。</p>
]]></content>
      
        
        <tags>
            
            <tag> log </tag>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[作为实习生的一年]]></title>
      <url>/2018/09/18/practice-year/</url>
      <content type="html"><![CDATA[<h1 id="0X00-When-and-Why"><a href="#0X00-When-and-Why" class="headerlink" title="0X00 When and Why"></a>0X00 When and Why</h1><p>我是大三下学期即将结束的时候出来实习了，故事说来比较诡异。一天下午像往常一样背着包到教室准备上小学期的课程（小学期就是为期一个月的综合实践），一个朋友跑过来悄悄跟我说“hey 大家都在找实习了，你怎么还不着手找哇”。当时一听我就慌了，很慌的那种慌，然后那天下午把之前准备的简历投了出去。毕竟学期即将结束，其实我是想要回家过一个暑假的，所以我也就没打算真的找到实习，只是说尝试着面试一下赚一些面试经验。那既然目标是赚取面试经验就只投大厂呗，小公司面试经历的用处可能没有那么大。当天下午我就只投递了“知道创宇/知乎/陌陌”三家，结果还没下午课程还没结束呢就收到了创宇的面试通知。另外两家其中一家拒绝了我，另一家一直没有回馈信息。</p>
<p>后来面试还算比较顺利，拿到了offer后就咬牙放弃了最后一个暑假回家的机会，退掉了好不容易抢到的火车票，在2017-07-24就正式入职创宇的实习生岗了。所以说我几乎是被朋友忽悠出来实习的，再加上运气好拿到了创宇的offer，要不然我还要回家过暑假呢，哈哈</p>
<h1 id="0X01-面试-amp-笔试"><a href="#0X01-面试-amp-笔试" class="headerlink" title="0X01 面试&amp;笔试"></a>0X01 面试&amp;笔试</h1><p>面试当天到了公司，在前台登记后给了我一份笔试题，内容是真的记不起来了，不过都比较简单。多是关于Python语言的一些问题和Linux系统操作的一些问题还有一些基础的SQL，没有问到关于我应聘岗位使用的Django框架。笔试题答好后我现在的部门总监就来开始面试了，除了问我笔试题的答题思路以外还问了些我搞不懂为什么问的问题。比如问了我“栈溢出攻击”，然而我并不懂安全而且部门也不是安全产品部门，所以我并没有答出来，后来还是面试官给我科普了一下“栈溢出攻击”是什么。我记得后面问的最具技术性的问题就是我学过什么Web框架，我说了解过一点点Flask后面试官问了我为什么选择优先学习Flask。在此之后就是“会不会用梯子？梯子是买的还是哪里的？会不会用Linux？用的什么浏览器？”这类更偏向“程序员文化”的东西了。最后面试结束的时候问了我简历上的个人博客和Github有没有在更新，我说在更新后面试就差不多结束了。</p>
<p>因为互相加了QQ，在入职之前还给我说过感觉我Github上项目的代码比较整洁，挺合格的。其实当时我Github上就一个小项目，很小很小的那种，所以说Github在求职过程中还是非常非常有用的。</p>
<a id="more"></a>

<h1 id="0X02-入职时的水平"><a href="#0X02-入职时的水平" class="headerlink" title="0X02 入职时的水平"></a>0X02 入职时的水平</h1><p>当时刚刚入职的时候，部门的技术栈几乎是全不懂（全不而非全部，是真的不会）。只有了解过一点点docker/flask/操作系统/网络等知识，对Linux的使用和操作比较熟悉，Python只有在语言上比较熟悉，而项目中大量使用的框架Django和git工具是从来没有用过的。</p>
<p>现在想来，其实不管什么语言什么框架的公司，熟练掌握”操作系统、网络、Linux、git“等这种通用的理论和技能都是绝对没有错的。所以大家不知道学什么的时候就可以去学习这些通用知识，任何时候学习通用知识和技能都是绝对不会错误的。</p>
<h1 id="0X03-实习一年在干嘛"><a href="#0X03-实习一年在干嘛" class="headerlink" title="0X03 实习一年在干嘛"></a>0X03 实习一年在干嘛</h1><p>从最初入职的时候写单元测试开始，因为写单元测试可以比较快速的了解项目的业务逻辑，也会看大量的业务代码，是新手上手一个成熟项目的良好办法。之后就从单元测试-&gt;小功能-&gt;从0到1的小项目-&gt;几个小项目的主要维护人。现在就是在负责几个比较小的项目，感觉虽然没有扛起重担，但是起码能够独立担任一些小项目的各项适宜了。</p>
<p>这一年里也逐步的学习了更多的东西，目前来说工具上的git和docker已经和其他同事差不多同水平了，最重要的Django部分也是一直在变得更好。最近因为前端人手不够用，还开始接手一些前后端绑定的任务，着手写一些功能简单的Vue。</p>
<p>当然了，作为一个实习生中途肯定多少会有一些做零活的时候，比如搞一些Excel之类的。不过公司这点还是很棒，招实习生的目的就是未来成为正式员工，所以没有给安排很多零活，大多都是符合当前定位且对转正后工作又帮助的任务。</p>
<h1 id="0X04-创宇真的好？"><a href="#0X04-创宇真的好？" class="headerlink" title="0X04 创宇真的好？"></a>0X04 创宇真的好？</h1><p>最初面试的时候，我的面试官给我说”我们部门不加班的“。其实当时我是不信的，不过后来才发现是真的，实习整整一年后我提的加班都不到16小时（两个工作日）。这无疑是一个很大的诱惑吧，一家程序员不加班的公司谁不喜欢呢。</p>
<p>还有就是公司倡导的扁平化管理，虽然领导就在同一个办公室，或者就坐在你隔壁你对面，但是大家完全不会拘谨。互相之间只会喊X哥或者其他绰号，即使是上级叫下级也是直接叫X哥或者绰号，很少直接叫名字的。而且上级安排工作也是会真正的考虑到大家的感受，并不会强行安排工作到头上。</p>
<p>公司还会给提供培训的机会，比如参与各种相关交流会、分享会等，各种会议的入场费都是可以报销的。而且公司也会时不时举行内部的培训，很多时候都是针对技术的而非一味强调战略、管理、文化这些。上周才刚刚参与了公司专门针对应届毕业生的培训。整整两天的时间，公司的销售总监、人事行政总监等高管专程从北京飞到成都来给我们上课。</p>
<p>这还不是我对公司印象最好的地方，我觉得创宇最棒的地方在于你的同事会像学校里的老师一样给予指导。我的mentor曾多次站在我身后给我讲代码和业务逻辑超过半个小时，从来不会说因为自己没空就不提供指导，更不会因为自己没有好处拿就找借口不管。最近我在接触Vue的时候也是，前端同事多次站在我身后给我讲前端需要注意的东西，给我说需要看哪个教程，甚至会给我布置作业。这种细致入微的指导恐怕很多学校的老师都做不到吧。有着这么好的条件，不仅能够学到东西还能拿到不错的工资，能不喜欢才怪呢。</p>
<h1 id="0X05-谁都有挫折"><a href="#0X05-谁都有挫折" class="headerlink" title="0X05 谁都有挫折"></a>0X05 谁都有挫折</h1><p>当然了，工作不会是一帆风顺的。最初开始做一些功能性任务的时候，受到挫折最大的一次，自己提交的一个commit总共只有200行左右的代码，在Review的过程给打回了80多90个修改意见，也就意味着每两三行就会有一个问题。那段时间写完代码都不敢提PR上去，提了PR上去之后整个人都是提心吊胆的。</p>
<p>在对语言和框架熟悉一些后，代码Review上的问题越来越少了，写代码也就快了起来。不过这样一来Bug也就随之出现了，最多的时候一个月出现过两次轻微的线上bug和一次小的生产事故。所以后来每次发布带有我代码的版本时，整个人也都是虚的，总觉的马上就会爆发线上BUG甚至是生产事故。</p>
<p>不管是之前的Code Review恐慌还是后面的BUG恐慌，都曾经有过”要不离职吧“的想法。后来想了想，虽然被项目经理叫出去谈过话，但是也只是让我再多注意一些，并没有很暴躁或是有让我走人的意思。所以应该还没有到走人的程度，毕竟作为实习生公司是可以随便让我走人的。那段时间我就一直在调整状态，也一直在学习，更要随时注意细节，防止再次发生问题。在经过这些事情之后，现在感觉比以前好了一些了，起码不会觉得自己要离职了。谁的职业生涯会是一帆风顺的呢，幸好我坚持过了那段压力很大的时候，感谢自己吧。</p>
<h1 id="0X06-目前水平"><a href="#0X06-目前水平" class="headerlink" title="0X06 目前水平"></a>0X06 目前水平</h1><p>这一年实习下来，在Python的语言和Linux上没有明显的进步，毕竟Python常用到的地方也就这些，那些高级用法用到了再去查一查也无可厚非，而Linux的卓面版也整整用了一年了，虽然没有太多运维技术上的提升但是起码用的更加熟悉了，也找到了一些适合我使用习惯的软件来支持我。</p>
<p>一年来进步比较大的就是Django和两个工具：Docker和git了。Django从入职时候的0基础，到现在可以独立负责一些小项目，应该也算是入门了吧。Docker和git两个工具平时用的很多但是却用不到比较深入的功能，所以已经和其他同事的水平差不多齐平了。</p>
<p>最近两个月以来，自从接触了SpaceVim之后使用Vim的比例大幅度提高，Vim的技能比原来高了好多，哈哈哈</p>
<h1 id="0X07-未来的计划点"><a href="#0X07-未来的计划点" class="headerlink" title="0X07 未来的计划点"></a>0X07 未来的计划点</h1><p>目前技术上最重要的就是Django/DRF框架和前端的Vue。Django/DRF再多学多用一些，争取尽快达到其他同事的水平和大家追平吧；Vue就慢慢来，争取能够自己独立完成一些前后端数据对接和简单逻辑的工作。</p>
<p>还有比较重要的一点就是提升自己的软实力，其实好多时候去分析遇到的问题都不是直接的技术不足导致的，所以时刻注意提升自己的专注力、思维发散能力、产品思维也是非常重要的呢。</p>
]]></content>
      
        
        <tags>
            
            <tag> log </tag>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django中的一些非入门级用法]]></title>
      <url>/2018/09/06/django-queryset/</url>
      <content type="html"><![CDATA[<p>为什么这里说是”非入门级”用法呢，因为我个人觉得这是我接触Django之后一段时间才开始了解的用法，但是说是高级用法又太夸张了，所以用了这么一个诡异的”非入门级“的定位。</p>
<p>下面的示例中使用下面的model，简单描述一下并非真实代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    staff = models.ForeignKey(  <span class="comment"># 订单负责人</span></span><br><span class="line">        <span class="string">&#x27;Staff&#x27;</span>,</span><br><span class="line">        null=<span class="literal">True</span>,</span><br><span class="line">        on_delete=models.SET_NULL,</span><br><span class="line">    )</span><br><span class="line">    price = models.IntegerField()   <span class="comment"># 订单的价值</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h1 id="0X00-使用Avg-Sum-Count-Max-Min"><a href="#0X00-使用Avg-Sum-Count-Max-Min" class="headerlink" title="0X00 使用Avg()/Sum()/Count()/Max()/Min()"></a>0X00 使用Avg()/Sum()/Count()/Max()/Min()</h1><p>这些方法的用法很简单，顾名思义。不过需要配合下面介绍的<code>annotate()</code>或<code>aggregate()</code>使用。</p>
<p><code>from django.db.models import Avg, Sum, Count, Max, Min</code></p>
<table>
<thead>
<tr>
<th>name</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>Avg</td>
<td>求平均数</td>
</tr>
<tr>
<td>Sum</td>
<td>求和</td>
</tr>
<tr>
<td>Count</td>
<td>计数</td>
</tr>
<tr>
<td>Max</td>
<td>求最大</td>
</tr>
<tr>
<td>Min</td>
<td>求最小</td>
</tr>
</tbody></table>
<h1 id="0X01-使用annotate"><a href="#0X01-使用annotate" class="headerlink" title="0X01 使用annotate()"></a>0X01 使用annotate()</h1><p>最基础的查询就是从一张表中查询符合某条件的字段，而使用<code>annotate()</code>可以得到一些我们手动计算得到的值，并将其作为Queryset中Item的一个属性来调用。</p>
<p>如果我想要查询每个人(Staff)手下有多少个订单(Order)，那么该怎么查呢，使用初级的用法可以写出类似下面的代码。但是有一个比较严肃的问题：会产生<code>用户数量 + 1</code>次的查询。这里只有少数用户问题不大，如果有上千甚至上万个用户，那么就会产生几千几万次查询，那对数据库的压力是很恐怖的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">staff_list = Staff.objects.filter()</span><br><span class="line"><span class="keyword">for</span> staff <span class="keyword">in</span> staff_list:</span><br><span class="line">    order_count = Order.objects.filter(staff=staff).count()</span><br></pre></td></tr></table></figure>

<p>使用<code>annotate()</code>方法就可以有效解决这个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">staff_queryset = Staff.objects.filter().annotate(staff_order_count=Count(<span class="string">&#x27;order&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> staff <span class="keyword">in</span> staff_queryset:</span><br><span class="line">    print(staff.staff_order_count)</span><br></pre></td></tr></table></figure>
<p>这里的<code>staff_order_count</code>字段是表中并不存在的，是通过<code>annotate()</code>方法临时存储的一个字段。同样的，再一个<code>annotate()</code>方法中可以加入多个参数，使用同样的方法去统计和获取数据即可。</p>
<blockquote>
<p>在<code>annotate()</code>中使用<code>Count()</code>一定要是有外键关联才行。例如本例中，Order表中有一个外键字段staff与表Staff关联起来了，那么就可以在Django中通过Staff.order_set来获取关联到Staff的Order，所以也就可以使用<code>Count()</code>方法来进行统计了。</p>
</blockquote>
<p>生成查询的SQL语句也打出来方便理解。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&quot;Post_staff&quot;</span>.<span class="string">&quot;id&quot;</span>, <span class="string">&quot;Post_staff&quot;</span>.<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Post_staff&quot;</span>.<span class="string">&quot;age&quot;</span>, <span class="keyword">COUNT</span>(<span class="string">&quot;Post_order&quot;</span>.<span class="string">&quot;id&quot;</span>) <span class="keyword">AS</span> <span class="string">&quot;x&quot;</span> <span class="keyword">FROM</span> <span class="string">&quot;Post_staff&quot;</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="string">&quot;Post_order&quot;</span> <span class="keyword">ON</span> (<span class="string">&quot;Post_staff&quot;</span>.<span class="string">&quot;id&quot;</span> = <span class="string">&quot;Post_order&quot;</span>.<span class="string">&quot;staff_id&quot;</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">&quot;Post_staff&quot;</span>.<span class="string">&quot;id&quot;</span>, <span class="string">&quot;Post_staff&quot;</span>.<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Post_staff&quot;</span>.<span class="string">&quot;age&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="0X02-使用aggregate"><a href="#0X02-使用aggregate" class="headerlink" title="0X02 使用aggregate()"></a>0X02 使用aggregate()</h1><p>使用<code>aggregate()</code>可以使得查询的返回值由一个<code>Queryset</code>变成一个<code>dict</code>，每个key和对应的value由自己计算得到。</p>
<p>如果我需要计算出所有人中年龄最大、最小、平均值该怎么办？初级用法可能需要先用一个查询得出所有人的年龄，然后再单独去计算最大最小平均值。写出类似如下代码，虽然目前问题不大，不过当逻辑复杂起来之后就会难以理解并且代码量较大。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queryset = Staff.objects.filter()</span><br><span class="line">age_list = [staff.age <span class="keyword">for</span> staff <span class="keyword">in</span> queryset]</span><br><span class="line"></span><br><span class="line">age_sum = sum(age_list)</span><br><span class="line">age_max = max(age_list)</span><br><span class="line">age_min = min(age_list)</span><br><span class="line">age_avg = (sum(age_list) * <span class="number">1.0</span>) / len(age_list)</span><br></pre></td></tr></table></figure>

<p>但是如果使用<code>aggregate()</code>方法写出不仅逻辑清晰不易出错，而且代码量少了很多，更简单易读。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Staff.objects.filter().aggregate(</span><br><span class="line">    age_sum=Sum(<span class="string">&#x27;age&#x27;</span>),</span><br><span class="line">    age_max=Max(<span class="string">&#x27;age&#x27;</span>),</span><br><span class="line">    age_min=Min(<span class="string">&#x27;age&#x27;</span>),</span><br><span class="line">    age_avg=Avg(<span class="string">&#x27;age&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这段代码就会直接输出如下dict，需要的数据直接取即可。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;age_sum&quot;</span>: <span class="number">71</span>,</span><br><span class="line">    <span class="attr">&quot;age_max&quot;</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">&quot;age_min&quot;</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="attr">&quot;age_avg&quot;</span>: <span class="number">23.666666666666668</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0X03-使用Case-When"><a href="#0X03-使用Case-When" class="headerlink" title="0X03 使用Case/When"></a>0X03 使用Case/When</h1><p>Django中的<code>Case()/When()</code>是非常实用一对方法，恰当使用可以大幅度减小统计功能的代码量、逻辑复杂度等。</p>
<p>假设有如下需求”年龄小于18的为未成年(1)，年龄在19<del>30之间的为青年(2)，年龄在31</del>60的为中年(3)，其他为老年(0)“，那么使用<code>Case/When</code>方法再配合<code>annotate()</code>方法就可以优雅得实现功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Staff.objects.filter().annotate(</span><br><span class="line">    age_tag = Case(</span><br><span class="line">        When(</span><br><span class="line">            age__lt=<span class="number">18</span>,</span><br><span class="line">            then=<span class="number">1</span>，</span><br><span class="line">        )，</span><br><span class="line">        When(</span><br><span class="line">            age__lt=<span class="number">30</span>,</span><br><span class="line">            then=<span class="number">2</span>,</span><br><span class="line">        )</span><br><span class="line">        When(</span><br><span class="line">            age__lt=<span class="number">60</span>,</span><br><span class="line">            then=<span class="number">3</span>,</span><br><span class="line">        )</span><br><span class="line">        default=<span class="number">0</span>,</span><br><span class="line">        output_field=IntegerField(),</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的代码类似于这种</span></span><br><span class="line">age_tag = <span class="number">1</span> <span class="keyword">if</span> age &lt; <span class="number">18</span> <span class="keyword">else</span> <span class="number">2</span> <span class="keyword">if</span> age &lt; <span class="number">30</span> <span class="keyword">else</span> <span class="number">3</span> <span class="keyword">if</span> age &lt; <span class="number">60</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># emm...这种更形象一点</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    age_tag = <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">30</span>:</span><br><span class="line">    age_tag = <span class="number">2</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">60</span>:</span><br><span class="line">    age_tag = <span class="number">3</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    age_tag = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上面是计算一个QueyrSet中每一个item的情况，还有一种情况是统计一个model中所有数据，例如这个需求：”统计所有Order中，单价最高、最低和平均值“。使用<code>Case()/When()</code>也可以完成任务，并且比初级用法更好一些。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Order.objects.filter().aggregate(</span><br><span class="line">    max_price=Max(<span class="string">&#x27;price&#x27;</span>),</span><br><span class="line">    min_price=Min(<span class="string">&#x27;price&#x27;</span>),</span><br><span class="line">    avg_price=Avg(<span class="string">&#x27;price&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>内容整理的有点差，各位发现了什么疏漏和错误请及时联系我，防止误导别人。如果文章对大家带来了帮助，那我还是很开心的 嘿嘿</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Database </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你为什么需要一台NAS]]></title>
      <url>/2018/08/31/why-nas/</url>
      <content type="html"><![CDATA[<p>自从一咬牙购入了一台Synology之后感觉网络和存储的体验提升了很多。在这里总结一下购买理由，方便犹豫不决的朋友做个参考。</p>
<h1 id="0X00-来自百度云盘的惊悚事件"><a href="#0X00-来自百度云盘的惊悚事件" class="headerlink" title="0X00 来自百度云盘的惊悚事件"></a>0X00 来自百度云盘的惊悚事件</h1><p>国内云盘一波洗牌过后，常用的几家都已经GG了，仅有一家百度还存活着。不过百度云说起来是免费的，实际如果使用的比较多的话就会发现，如果不充值为会员的话，速度就会非常的慢。所以说百度云盘也几乎是一个收费的网盘，超级会员算下来要将近30元/月。</p>
<p>其实收费无可厚非，毕竟大家花钱享受服务嘛。不过直到一天，在网上看到了这样一件事：</p>
<blockquote>
<p>一个人在自己的百度云盘中上传了大量自己拍摄的照片（纯一手自己拍摄的），过段时间后因为一些原因从百度云盘手动删除了。<strong>又过了不短的一段时间</strong>，该用户再次将自己的这些照片上传至百度云盘，发现居然所有图片都是使用 <strong>急速秒传</strong> 的方式上传的。那么就发现了一个问题，急速秒传使用的是文件摘要值对比后选择性上传的一个技术。那问题就来了，该用户自己纯一手拍摄的照片，在没有分享给任何人的情况下删除了，而且是过了不短的一段时间再次上传，居然是秒传。那就意味着百度的服务器上存储了该用户的这些数据，但是用户已经删除了这些数据。意味着什么呢？百度根本没有删除用户的数据，在用户删除之后也只是不展示给用户看了而已。</p>
</blockquote>
<p>现在想想是不是不寒而栗？</p>
<a id="more"></a>
<h1 id="0X01-大家的带宽也没那么大"><a href="#0X01-大家的带宽也没那么大" class="headerlink" title="0X01 大家的带宽也没那么大"></a>0X01 大家的带宽也没那么大</h1><p>还有一个原因就是”此时此刻大家的带宽还没有那么大”。说是云时代已经到来了，可是我们的手机还是需要64G，128G乃至更大的存储，并不能完全将数据存储到云端；我们的PC也是动辄TB级，并不能在线观看真正的蓝光原盘；甚至你的PS4也需要更大的硬盘以存储更多的游戏，不能从服务器上加载游戏；这些问题的一个交汇点就在“带宽&amp;流量”上。所以对于有大量数据存储与分享需求的用户，还是可以在家里部署一台NAS，毕竟现在的电脑、手机都是1000M的网卡，理论可以达到100m/s的传输速度还是要远远高于我们的互联网带宽。而且当你要备份数据到云端的时候，由于我们大多数都是ADSL的网络，会导致上传速度远低于下载速度。</p>
<p>在我的网络环境下，如果我要备份一个5GB的文件到互联网的云上，没有一个半小时几乎是完成不了的，但是如果是使用内网的NAS的话，就可以在一分半以内完成。</p>
<h1 id="0X02-多设备同步目录"><a href="#0X02-多设备同步目录" class="headerlink" title="0X02 多设备同步目录"></a>0X02 多设备同步目录</h1><p>如果家中有多台设备需要共享一些文件，比如照片/文档等。在Synology中可以轻松实现多台设备同步目录，你在一台设备上进行的改动会瞬间同步至所有设备。虽然很多公网云存储提供了这项服务，但是毕竟这是内网环境的，硬盘就在你家里，资料的私密性会很高。</p>
<h1 id="0X03-无处不在的文件"><a href="#0X03-无处不在的文件" class="headerlink" title="0X03 无处不在的文件"></a>0X03 无处不在的文件</h1><p>现在的NAS都可以配置外部介入，以我用的Synology为例。如果自己家的宽带可以申请公网IP最好，如果不能也可以在Synology的控制面板中配置外部连接。不管你身在何处，只要能连接到网络就可以访问到自己的文件，而且不需要购买花生壳等服务，速度也还可以接受。</p>
<h1 id="0X04-NFS-SMB"><a href="#0X04-NFS-SMB" class="headerlink" title="0X04 NFS/SMB"></a>0X04 NFS/SMB</h1><p>Synology中提供了共享目录的多种协议，在Linux上我使用NFS来挂载我的目录，Windows环境下使用SMB也是可以的。使用NFS或SMB挂载目录后就可以将NAS中的共享目录当作自己的磁盘来访问了，非常方便。</p>
<h1 id="0X05-git-server"><a href="#0X05-git-server" class="headerlink" title="0X05 git server"></a>0X05 git server</h1><p>Synology的套件中心中提供了git server，可以在家中部署一个私有git server。安全可靠。</p>
<h1 id="0X06-docker"><a href="#0X06-docker" class="headerlink" title="0X06 docker"></a>0X06 docker</h1><p>高级的Synology版本提供docker服务，有了docker再加上远程访问和端口转发后，你的Synology就几乎成为了一台真正的服务器了。</p>
<h1 id="0X07-VideoStadion"><a href="#0X07-VideoStadion" class="headerlink" title="0X07 VideoStadion"></a>0X07 VideoStadion</h1><p>Synology中的VideoStadion套件可以分析你NAS中存储的电影，自动帮你整理、下载封面、下载影片介绍、下载字幕，简直就是一个家用的多媒体中心。虽然几乎每次看NAS中的电影都是使用本地播放器在播放，不过还是要承认Synology中的VideoStadion套件是很棒的,可能只是我不太喜欢用而已。</p>
<h1 id="0X08-DownloadStadion"><a href="#0X08-DownloadStadion" class="headerlink" title="0X08 DownloadStadion"></a>0X08 DownloadStadion</h1><p>这个是我眼中的大杀器。假设你只有一台笔记本，如果你想要下载几部高清电影空了看，那么就只能在晚上的时候挂机下载，白天了再暂停带走去工作。拥有了Synology后可以把十几个种子、磁力链接、http地址丢在DownloadStadion中，设定好下载时间就不用再管他了。我的DownloadStadion就是每周一至周五的2:00到19:00进行数据下载，其他时间空闲。</p>
<p>而且配合远程操作和搜索功能，可以实现在任何地方掏出手机命令家里的Synology下载文件，等你到家文件早就下载好了。</p>
<h1 id="0X09-其他优势"><a href="#0X09-其他优势" class="headerlink" title="0X09 其他优势"></a>0X09 其他优势</h1><p>理论上一台HTPC经过一番配置部署也可以达到Synology的效果，不过Synology最大的特点是一台HTPC所不能比拟的。Synology非常省电，通常情况下它只有10W左右的功率；而且Synology的服务很全面，基本上你需要的功能都在了，不需要你过多折腾；还有就是专业的NAS会很稳定，持续运行很久都没有问题。</p>
<h1 id="0X0A-劣势"><a href="#0X0A-劣势" class="headerlink" title="0X0A 劣势"></a>0X0A 劣势</h1><p>Synology最大的优势就是方便省事，但是最大的劣势却是“麻烦费事”。因为并不是所有人都有足够的计算机基础，对于大多数没有计算机基础的人来说这东西还是有点复杂，而且大多数人也并不会有购买一台NAS的需求。</p>
<h1 id="0X0B-一些替代方案"><a href="#0X0B-一些替代方案" class="headerlink" title="0X0B 一些替代方案"></a>0X0B 一些替代方案</h1><p>如果不想购买一台NAS的话也有一些替代品，据我所知不错的方案有这几个：</p>
<ol>
<li>自建“黑群晖”（据说很麻烦，坑很多）</li>
<li>OwnCloud/NextCloud等云存储程序</li>
<li>使用OpenNAS自建功能完善的NAS</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Synology </tag>
            
            <tag> NAS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django中的F()]]></title>
      <url>/2018/08/29/django-f-object/</url>
      <content type="html"><![CDATA[<h1 id="0X00-内容比较少，不分标题"><a href="#0X00-内容比较少，不分标题" class="headerlink" title="0X00 内容比较少，不分标题"></a>0X00 内容比较少，不分标题</h1><p>我们对Django中的model进行查询时通常是<strong>某个字段和一个常量</strong>对比，比如下面这种写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.filter(name=<span class="string">&#x27;shawn&#x27;</span>)</span><br><span class="line">Student.objects.filter(age=<span class="number">233</span>)</span><br><span class="line">Student.objects.filter(gender__in=(<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;M&#x27;</span>))</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>如果遇到高级的查询可能会使用<code>Q()</code>查询，不过也只是进行多个条件的查询</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.filter(</span><br><span class="line">    Q(name=<span class="string">&#x27;shawn&#x27;</span>) | Q(gender=<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">Student.objects.filter(</span><br><span class="line">    Q(gender=<span class="string">&#x27;F&#x27;</span>) | ~Q(age=<span class="number">233</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.just666.cn/2018/05/20/django-query-q/">这里是我的另一篇介绍Q()的博文。</a></p>
</blockquote>
<p>但是如果有这样一个需求：”查询订单中结束时间和开始时间的间隔大于45分钟的“。那应该怎么办的？因为订单的开始时间和结束时间都是一个字段，我们需要对比同一条数据中的两个字段。这时候可以使用<code>F()</code>来查询。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"><span class="keyword">from</span> my_project.models.Order</span><br><span class="line"></span><br><span class="line">forty_five_minutes = datetime.timedelta(minutes=<span class="number">45</span>)</span><br><span class="line">Order.objects.filter(end_time__gt=F(<span class="string">&#x27;start_time&#x27;</span>) + forty_five_minutes) <span class="comment"># 查询结束时间大于开始时间加上45分钟的订单</span></span><br><span class="line">Order.objects.filter(operator__age__lte=F(<span class="string">&#x27;client__age&#x27;</span>))   <span class="comment"># 查询订单操作员年龄小于等于客户的（我也不知道有啥用，例子而已）</span></span><br><span class="line"></span><br><span class="line">one_second = datetime.timedelta(seconds=<span class="number">1</span>)</span><br><span class="line">OldMan.objects.filter(age__gt=F(<span class="string">&#x27;age&#x27;</span>) + one_second)    <span class="comment"># 查询年龄比自己年龄多1S的大人？哈哈哈</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本段内容的官方文档：<a href="https://docs.djangoproject.com/en/2.1/ref/models/expressions/#f-expressions">https://docs.djangoproject.com/en/2.1/ref/models/expressions/#f-expressions</a><br>本段内容的另一篇博客：<a href="https://www.cnblogs.com/liuq/p/5946803.html">https://www.cnblogs.com/liuq/p/5946803.html</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Python函数默认值的小问题]]></title>
      <url>/2018/08/27/python-default-params/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Python一切皆对象</p>
</blockquote>
<h1 id="0X00-困扰我的一个问题"><a href="#0X00-困扰我的一个问题" class="headerlink" title="0X00 困扰我的一个问题"></a>0X00 困扰我的一个问题</h1><p>前两天在工作上遇到了个问题，说来很简单：我要在每天的固定时刻统计系统中当天产生的一些数据并且用邮件发送给指定的人，又考虑到了程序的可复用性(统计其他日期)我并没有把参数写死，而是将其默认为当天的日期并可以指定参数。很容易我就写出了类似下面的代码。Ps.伪代码，不要过分纠结。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">export_statistic</span>(<span class="params">export_date=datetime.date.today(<span class="params"></span>)</span>):</span></span><br><span class="line">    result = get_statistic_for_day(export_date)</span><br><span class="line">    sendmail(<span class="string">&#x27;今日数据统计结果&#x27;</span>, result, receiver_list)</span><br></pre></td></tr></table></figure>
<p>并且将其配置在Celery中，每晚执行，并且在得到了第一天的正确数据后默认程序正确了。第二晚虽然收到了统计数据的邮件，但是发现日期是前一天的。以为是Celery或是服务器时间同步问题或是缓存等导致的，但是在多次检查后没有发现这个问题的根本原因。故临时使用<code>crontab</code>去执行这个定时任务，但这并不是长久之计。</p>
<a id="more"></a>
<h1 id="0X01-到底发生了什么"><a href="#0X01-到底发生了什么" class="headerlink" title="0X01 到底发生了什么"></a>0X01 到底发生了什么</h1><p>纠结问题所在的时候突然想到“会不会函数的默认值在函数初次初始化的时候生成好就不再变了？”故而使用下面这段代码来检验自己的推断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">date=datetime.now(<span class="params"></span>)</span>):</span></span><br><span class="line">    <span class="keyword">print</span> date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        test()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>果然输出的结果和我以前的设想不同，按照我以前的想法应该是输出的几个时间间隔为1s，但是结果却是每一行都相同（果然我的1s不见了）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-08-27 23:04:53.008236</span><br><span class="line">2018-08-27 23:04:53.008236</span><br><span class="line">2018-08-27 23:04:53.008236</span><br><span class="line">2018-08-27 23:04:53.008236</span><br><span class="line">2018-08-27 23:04:53.008236</span><br><span class="line">2018-08-27 23:04:53.008236</span><br><span class="line">2018-08-27 23:04:53.008236</span><br><span class="line">2018-08-27 23:04:53.008236</span><br><span class="line">2018-08-27 23:04:53.008236</span><br><span class="line">2018-08-27 23:04:53.008236</span><br></pre></td></tr></table></figure>

<h1 id="0X02-那是为什么呢"><a href="#0X02-那是为什么呢" class="headerlink" title="0X02 那是为什么呢"></a>0X02 那是为什么呢</h1><p><strong>Python一切皆对象</strong>这句话看来真的不是说着玩儿的。其实Python中的一个函数也是一个对象，而对象就会有初始化的时候。Python的函数在作为对象进行初始化的时候就计算了“默认参数”。比如上面的例子，在函数<code>def test(date=datetime.now())</code>初始化的时候就已经计算了<code>date=datetime.now()</code>为<code>2018-08-27 23:04:53.008326</code>，所以以后每次调用的函数test默认参数都是这个值，有一个经典的案例可以参考。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a, b=[]</span>):</span></span><br><span class="line">    b.append(a)</span><br><span class="line">    <span class="keyword">print</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        test(i)</span><br></pre></td></tr></table></figure>
<p>按照我之前的想法，输出的应该是<code>[0], [1], [2]...</code>这种，每次列表中只有一个元素，然而事实上是这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0]</span><br><span class="line">[0, 1]</span><br><span class="line">[0, 1, 2]</span><br><span class="line">[0, 1, 2, 3]</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">[0, 1, 2, 3, 4, 5]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>
<p>我们来通过<code>id()</code>来检查一下原因。Python中的<code>id(foo)</code>会返回foo在内存中的唯一标识，稍作修改把代码改成如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a, b=[]</span>):</span></span><br><span class="line">    b.append(a)</span><br><span class="line">    <span class="keyword">print</span> id(b), b  <span class="comment"># 只是在这里新增了id(b)的输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        test(i)</span><br></pre></td></tr></table></figure>
<p>我们可以看到，其实<code>b=[]</code>只执行了一次，每次使用的b并不是我们臆想中重新初始化的，而是一个现有的。</p>
<h1 id="0X03-再次证实"><a href="#0X03-再次证实" class="headerlink" title="0X03 再次证实"></a>0X03 再次证实</h1><p>自己写了几行代码来简单证明这个事情，按照我之前的臆想这个程序应该是看不到print输出的，因为看起来<code>hello()</code>并没有被调用到，但是其实呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">a=<span class="string">&#x27;hello&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">print</span> a</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">world</span>(<span class="params">b=hello(<span class="params"></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>解释器在执行<code>def hello(a=&#39;hello&#39;)</code>的时候正常下去了，生成了一个<code>hello()</code>方法的函数对象，但是在执行到<code>def world(b=hello())</code>的时候也要将<code>world()</code>初始化为一个固定的对象，那么就势必执行了<code>b=hello()</code>。所以我们可以看到最终还是会有一个<code>hello</code>的输出。</p>
<blockquote>
<p>1s不见了当然不是因为时间被转移走了-_-</p>
</blockquote>
<blockquote>
<p>文章参考自<a href="https://www.cnblogs.com/crazyrunning/p/6867849.html">Python进阶-函数默认参数 珞樱缤纷-cnblogs</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[提升Git新手效率的小技巧]]></title>
      <url>/2018/08/22/git-skill/</url>
      <content type="html"><![CDATA[<p>内容比较少，只是今晚翻看教程的时候发现的几个可以替换调我以前一些诡异操作的方法，将其整理贴出。</p>
<h1 id="0X00-git-blame"><a href="#0X00-git-blame" class="headerlink" title="0X00 git blame"></a>0X00 git blame</h1><p>是谁在代码里下了毒？是谁用了一个超酷炫的方法解决了你解决不了的问题？当你想知道仓库中的某行代码是谁提交的，就可以使用这个方法。<code>git blame hello.py</code>可以看到hello.py这个文件所有行的提交人是谁，于何时提交的。而且这个命令最常用的是和<code>grep</code>合用，<code>git blame hello.py | grep prinft</code>(是谁写错了这个单词+_+)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200   1) &lt;p align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200   2)   &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;s3.amazonaws.com&#x2F;ohmyzsh&#x2F;oh-my-zsh-logo.png&quot; alt&#x3D;&quot;Oh My Zsh&quot;&gt;</span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200   3) &lt;&#x2F;p&gt;</span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200   4) </span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200   5) Oh My Zsh is an open source, community-driven framework for managing your [zsh](https:&#x2F;&#x2F;www.zsh.org&#x2F;) configuration.</span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200   6) </span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200   7) Sounds boring. Let&#39;s try again.</span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200   8) </span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200   9) _Oh My Zsh will not make you a 10x developer...but you might feel like one.__</span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200  10) </span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200  11) Once installed, your terminal shell will become the talk of the town _or your money back!_ With each keystroke in your command prompt, you&#39;ll take advantage of the hundreds of powerful plugins and beautiful themes. Strangers will come up to you in cafés and ask you, _&quot;that is amazing! are you some sort of genius?&quot;_</span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200  12) </span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200  13) Finally, you&#39;ll begin to get the sort of attention that you have always felt you deserved. ...or maybe you&#39;ll use the time that you&#39;re saving to start flossing more often. 😬</span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200  14) </span><br><span class="line">^9544316 (Lars Schneider 2018-07-24 22:55:48 +0200  15) To learn more, visit [ohmyz.sh](https:&#x2F;&#x2F;ohmyz.sh) and follow [@ohmyzsh](https:&#x2F;&#x2F;twitter.com&#x2F;ohmyzsh) on Twitter.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的例子是<code>oh-my-zsh</code>中README的部分输出</p>
</blockquote>
<a id="more"></a>
<h1 id="0X01-git-commit-–amend"><a href="#0X01-git-commit-–amend" class="headerlink" title="0X01 git commit –amend"></a>0X01 git commit –amend</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim xxx.py</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;naruto! sasuke!&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你不小心把刚刚的commit写错了，现在还来得及后悔。</p>
<p>如果你刚刚commit，还没有进行新的改动，那么可以使用<code>git commit --amend</code>来修改上一次的commit。输入命令回车之后会打开你的编辑器，最上面的就是本次提交的commit message，动手修改之后保存就可以了。如果commit之后改动了很多才想起来那也可以先<code>git add .</code>再<code>git stash</code>，将改动先临时存起来再执行<code>git commit --amend</code>，修改好了commit message之后再用<code>git stash pop</code>把刚刚的改动给pop出来。</p>
<blockquote>
<p>ps.在git里几乎一切都是来得及的，允许后悔药的存在。</p>
</blockquote>
<h1 id="0X02-git-checkout-–-filename"><a href="#0X02-git-checkout-–-filename" class="headerlink" title="0X02 git checkout – filename"></a>0X02 git checkout – filename</h1><p>不管出于什么原因，大家都有可能需要删除掉对某一个文件的改动。如果是所有的改动都需要删除，那么可以简单的<code>git add .; git stash; git stash drop</code>丢弃这些改动。如果改动是多个文件，但是只有一个文件需要回退，那就可以使用<code>git checkout -- hello.py</code>来删除hello.py的改动。</p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git中的bare Repository]]></title>
      <url>/2018/08/19/git-bare-responsitory/</url>
      <content type="html"><![CDATA[<h1 id="0X00-遇到了什么"><a href="#0X00-遇到了什么" class="headerlink" title="0X00 遇到了什么"></a>0X00 遇到了什么</h1><p>我们使用git，绝大多数情况下都是大于等于一个人进行代码编辑，然后将自己的改动提交到<code>github/gitlab/gogs</code>等仓库，然后再通过<code>pull request/merge request</code>的方式进行代码合并。所以我们一般都是先从<code>github</code>上创建一个新的项目，然后按照向导在自己的本地<code>git clone</code>下来一个空项目，再提交代码上去；或者<code>fork &amp; clone</code>的流程。</p>
<p>以前从来没有去想过<code>github</code>上的仓库是不是和我本地的相同，以至于今天第一次搭建自己的git服务时遇到了问题。我从服务器上一顿操作猛如虎<code>mkdir xxx; cd xxx; git init; touch README.md; git add .; git commit -m &quot;init the repository&quot;</code>，结果不小心成了二百五。因为这个仓库根本不能clone到我本地，经过一番搜索发现了git中仓库之间的关系没有这么简单。</p>
<a id="more"></a>
<h1 id="0X01-git中一般的repository"><a href="#0X01-git中一般的repository" class="headerlink" title="0X01 git中一般的repository"></a>0X01 git中一般的repository</h1><p>git中一般的repository通常有两个来源：<code>git clone</code>或者在<code>git init</code>。这种仓库通常是我们用来正常工作的仓库，我们的代码都在这里面。我们可以在仓库里尽情使用<code>git add/rm/status/log</code>等常见操作。也可以将代码push到<code>origin/upstream</code>等上游仓库，这类仓库是最常见的了。</p>
<p>仓库中不仅存有我们正在使用的代码，有两个文件<code>.gitignore</code>和<code>.git</code>。其中<code>.gitignore</code>自然不必多说，是用来判断哪些文件需要或不需要提交到repository中的；另一个<code>.git</code>就是git实现版本控制的重要文件了。我们对代码的改动、不同的分支、commit的变化都是在这个目录中存储的。</p>
<blockquote>
<p>不建议直接动手修改<code>.git</code>目录中的任何文件，有可能会造成奇怪的问题而无法解决。</p>
</blockquote>
<h1 id="0X02-git中的bare-repository"><a href="#0X02-git中的bare-repository" class="headerlink" title="0X02 git中的bare repository"></a>0X02 git中的bare repository</h1><p>其实git中还有一种<code>bare repository</code>，这种仓库中文可以称之为<code>裸仓库</code>。这种仓库中没有我们正常使用的代码，也没有<code>.gitignore</code>和<code>.git</code>文件。不过可以把这种仓库理解成将<code>.git</code>目录下所有文件都拿到<code>bare repository</code>仓库的根目录了。<code>bare repository</code>存储不同分支与各个commit等与版本控制相关的数据，但是不会保存整整一份代码。</p>
<p>但是这种仓库可以使用<code>git clone</code>来clone仓库到本地，所以通常被当作共享仓库。例如你的团队没有在使用github或是gitlab等工具，那就可以在一台服务器上创建一个<code>bare repository</code>，然后大家均从此仓库clone代码，然后再一起提交至此以实现git的工作流。</p>
<p>要生成一个空的<code>bare repository</code>很简单，只需要在一个空目录中<code>git init --bare</code>就可以了，生成好之后就可以从该仓库<code>clone</code>代码了。</p>
<h1 id="0X03-部署一个服务器上的repository"><a href="#0X03-部署一个服务器上的repository" class="headerlink" title="0X03 部署一个服务器上的repository"></a>0X03 部署一个服务器上的repository</h1><p>到这里部署一台合作用的服务器上的repository就变得容易多了。首先创建一个git使用的用户，再使用git用户创建对应的裸仓库，再从客户机clone到本地，接下来就可以正常使用<code>commit/push/pull</code>等操作了。</p>
<ol>
<li>在服务器上创建一个git用户<code>user add git</code></li>
<li>然后为其创建home目录<code>mkdir /home/git</code></li>
<li>再修改所属人为git<code>chown git.git /home/git</code></li>
<li>切换成git用户并返回home目录<code>su git;  cd</code></li>
<li>在目录下创建一个空目录<code>mkdir .ssh</code></li>
<li>在<code>.ssh</code>，目录中创建一个<code>authorized_keys</code>的文件，在里面填入自己的ssh公钥</li>
<li>在本地已经可以clone下来啦<code>git clone ssh://git@xxx.xxx.xxx.xxx/xxx/xxx.git</code></li>
<li>为了安全可以修改<code>git</code>用户的默认shell<code>usermod git -s /bin/git-shell</code></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下日常使用软件推荐]]></title>
      <url>/2018/08/12/why-linux/</url>
      <content type="html"><![CDATA[<p>本来准备总结一下Linux桌面系统使用一年以来的一些感受，以及为什么选择Linux作为桌面系统工作学习的，但是构思了半个小时也没能想到要写些什么。所以还是来推荐一下一年以来在Linux桌面平台下的软件体验和推荐吧。由于我这一年多以来一直使用的是Fedora Workstadion，所以并不能保证这些软件能在其他平台下的体验与我一致，不过一般来说都是没有问题的呢。</p>
<h1 id="0X00-vim-spacevim"><a href="#0X00-vim-spacevim" class="headerlink" title="0X00 vim + spacevim"></a>0X00 vim + spacevim</h1><p>首先说明我不认为Vim比IDE写代码更好用，但是我仍然在使用vim。一个原因是觉得使用盗版IDE有些不太道德，另一个也是想要提升一下自己的代码水平，毕竟vim给出的提示会更少一些。IDE用户可以在IDE上安装vim的操作插件，毕竟vim的操作方式还是能很大程度上提升效率的。</p>
<p><a href="https://github.com/SpaceVim/SpaceVim">SpaceVim</a> 呢是vim的一个插件打包配置集成之后的一个版本。由于它集成了大量精选插件和配置，所以用起来很舒服，就把他当成一个高级的文本编辑器来用就好的。spacevim还有官方的中文文档可以查阅，虽然学习成本相对高一些，但是带来效率和爽快感的提升可不是一点点的。</p>
<h1 id="0X01-ulaunch"><a href="#0X01-ulaunch" class="headerlink" title="0X01 ulaunch"></a>0X01 ulaunch</h1><p><a href="https://github.com/Ulauncher/Ulauncher">ulaunch</a>是一个快速启动器，按下快捷键后屏幕中间会出现一个搜索框，可以快捷打开软件和文件。配合一些插件可以实现在搜索框中翻译等工作，而且软件和插件都是Python写的可以轻松制作自己的插件。</p>
<a id="more"></a>
<h1 id="0X02-plank"><a href="#0X02-plank" class="headerlink" title="0X02 plank"></a>0X02 plank</h1><p>plank是一个简单轻便的dock栏，在Fedora的官方仓库里就有的，直接使用包管理器就能一键安装。</p>
<h1 id="0X03-audacity"><a href="#0X03-audacity" class="headerlink" title="0X03 audacity"></a>0X03 audacity</h1><p>audacity是一个linux下的本地音乐播放器，简单好用，没有多余的复杂功能，推荐一波。</p>
<h1 id="0X04-vlc"><a href="#0X04-vlc" class="headerlink" title="0X04 vlc"></a>0X04 vlc</h1><p>vlc应该是Linux下最好的视频播放器之一了，各种格式的视频音频都不是问题。</p>
<h1 id="0X04-filezilla"><a href="#0X04-filezilla" class="headerlink" title="0X04 filezilla"></a>0X04 filezilla</h1><p>这是一款老牌的FTP工具，虽然大多数时候文件管理器已经可以满足我们对FTP的一些基本需求了，但是偶尔还是会有一些满足不了的东西，这时候filezilla就能发挥作用了，留一个有备无患嘛。</p>
<h1 id="0X05-electronic-wechat"><a href="#0X05-electronic-wechat" class="headerlink" title="0X05 electronic wechat"></a>0X05 electronic wechat</h1><p>鹅厂没有Linux下的微信，不过幸好有人制作了这个基于网页版微信的微信客户端，使用体验良好，推荐！</p>
<h1 id="0X06-electronic-ssr"><a href="#0X06-electronic-ssr" class="headerlink" title="0X06 electronic ssr"></a>0X06 electronic ssr</h1><p>shadowsocksR没的解释。对应的还有一个Shadowsocks-QT5也很棒，不过不支持SSR罢了，看需求选择。</p>
<h1 id="0X07-zsh-ohmyzsh"><a href="#0X07-zsh-ohmyzsh" class="headerlink" title="0X07 zsh + ohmyzsh"></a>0X07 zsh + ohmyzsh</h1><p>命令行组合，再搭配上ohmyzsh的一些插件，不仅终端非常漂亮效率还非常高。说到zsh就不得不说fish，相对来说zsh是和bash高度兼容的，虽然比fish慢了一点，但我更喜欢与bash的高度兼容，根据喜好选择啦。</p>
<h1 id="0X08-jq"><a href="#0X08-jq" class="headerlink" title="0X08 jq"></a>0X08 jq</h1><p>jq命令是用来格式化json输出的。比如你的<code>curl -XGET xxxx</code>和<code>cat xxx.json</code>的输出结果，通常都是没有格式化的，如果你安装了jq的话就可以<code>cat xxx.json | jq</code>把输出变成格式化的，而且带有高亮。注意哦，这个包在fedora中就直接叫做<code>jq</code>所以只需要<code>dnf install jq</code>就可以了，其他的发行版本自己找一下哈。</p>
<h1 id="0X09-ag"><a href="#0X09-ag" class="headerlink" title="0X09 ag"></a>0X09 ag</h1><p>ag是又一个超短超好用的命令。有这样一个场景，你在代码库的根目录下，想要找几百几千个源码文件中的<code>pdb</code>该怎么办呢？熟悉linux的很容易写出<code>grep -Rn &quot;pdb&quot; .</code>，从而找到所有包含pdb的行。ag就是用来替换这条较长且经常使用的命令的，你只需要用<code>ag pdb</code>就可以实现同样的效果，而且输出结果还比grep的更美观更直接。</p>
<blockquote>
<p>在fedora中这个包名是<code>the_silver_searcher</code>。</p>
</blockquote>
<h1 id="0X0A-vnote"><a href="#0X0A-vnote" class="headerlink" title="0X0A vnote"></a>0X0A vnote</h1><p>在github中搜索可以找到一个名为Vnote的项目，这个是我用过Linux下最好用的离线笔记软件了。支持加密、markdown、公式渲染、流程图渲染、多笔记本、多层目录等等特性。而且只需要跟自己的同步云盘配合一下就直接变成了一个云笔记，完美。</p>
<h1 id="0X0B-结尾"><a href="#0X0B-结尾" class="headerlink" title="0X0B 结尾"></a>0X0B 结尾</h1><p>Linux下的好软件并非只有这些，这些只是我在日常使用中发现的好用的工具。其中人人皆知的就没有再重复写进来，只写了一些不是很知名的或是奇怪用法的软件。如果各位有什么推荐的工具可以留言哈。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Docker部署Sentry服务]]></title>
      <url>/2018/08/08/install-sentry-with-docker/</url>
      <content type="html"><![CDATA[<h1 id="0X00-Sentry是什么"><a href="#0X00-Sentry是什么" class="headerlink" title="0X00 Sentry是什么"></a>0X00 Sentry是什么</h1><p>Sentry是一个统一收集整理程序异常错误的服务。如果你有一个程序在跑，并且配置了日志，那么可以轻松的找到程序出错的地方；甚至可以在报错后发邮件通知自己以便抓紧处理。但是如果你的团队有10个项目和50个人，并且这50个人并不是每人只负责一个项目，此时此刻该怎么办呢？难道为每个项目都配置很多人，并且在人员变动和项目变动的时候都去再修改吗？这样就未免有点傻了，Sentry就是用来做这个的。</p>
<p>你可以在Sentry上为每个项目创建一个Project用于收集项目的错误，再为每位成员创建用户，由用户去关注项目，就可以实现上述复杂的功能了。</p>
<h1 id="0X01-如何部署"><a href="#0X01-如何部署" class="headerlink" title="0X01 如何部署"></a>0X01 如何部署</h1><p>为了流程简洁，默认安装了<code>docker</code>和<code>docker-compose</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将一个配置好的使用docker-compose部署Sentry给<span class="built_in">clone</span>下来</span></span><br><span class="line">git clone https://github.com/getsentry/onpremise.git</span><br><span class="line"></span><br><span class="line">cd onpremise</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建所需的目录</span></span><br><span class="line">mkdir -p data/&#123;sentry,postgres&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成一个secret-key</span></span><br><span class="line">docker-compose run --rm web config generate-secret-key</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>上述命令执行完成后，输出的最后一行类似乱码的东西是我们所需的secret-key，将其复制粘贴之<code>docker-compose.yml</code>文件的<code>SENTRY_SECRET_KEY</code>后面，形似</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SENTRY_SECRET_KEY: &#x27;*********************&#x27;</span><br><span class="line">SENTRY_MEMCACHED_HOST: memcached</span><br></pre></td></tr></table></figure>

<p>然后初始化数据库<code>docker-compose run --rm web upgrade</code>，执行过程中会要求创建一个管理员账户，根据流程的提示操作既可。操作完成后执行<code>docker-compose up -d</code>就可以将整套Sentry服务启动起来了。此时如果想要访问Sentry的web服务需要访问<code>ip:9000</code>，可以按照下面的方法为其配置nginx的反向代理。</p>
<h1 id="0X02-Nginx反向代理"><a href="#0X02-Nginx反向代理" class="headerlink" title="0X02 Nginx反向代理"></a>0X02 Nginx反向代理</h1><p>向nxing配置的<code>http</code>模块内部添加下面的配置，并重新载入/重启Nginx后就可以使用域名访问Sentry了。注意将其中的<code>xxxx.example.com</code>改为自己解析了的域名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name xxxx.example.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;127.0.0.1:9000;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header  X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-Host $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client_max_body_size 10m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止Sentry就算是配置完成了。</p>
<h1 id="0X03-集成到自己的程序中"><a href="#0X03-集成到自己的程序中" class="headerlink" title="0X03 集成到自己的程序中"></a>0X03 集成到自己的程序中</h1><p>在Sentry的web服务中创建一个新的Project，创建时需要选择自己程序的类型，比如是<code>Django</code>还是<code>Flask</code>或是其他，创建好后会有提示，按照提示就可以将Sentry集成到自己的程序中了。过程都非常简单，比如在纯Python程序中集成一个Sentry也就四五行的事情，而在Django中也不过10行代码。</p>
<h1 id="0X04-配置发送邮件"><a href="#0X04-配置发送邮件" class="headerlink" title="0X04 配置发送邮件"></a>0X04 配置发送邮件</h1><p>此时的Sentry还只能接收错误，如果想要使其能够发送邮件，需要修改<code>docker-compose.yml</code>文件，找到几个以<code>SENTRY_XXX</code>开头的地方，在这里配置好自己需要使用的发件配置，例如</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SENTRY_SERVER_EMAIL:</span> <span class="string">sender@example.com</span></span><br><span class="line"><span class="attr">SENTRY_EMAIL_HOST:</span> <span class="string">smtp.example.com</span></span><br><span class="line"><span class="attr">SENTRY_EMAIL_PASSWORD:</span> <span class="string">examplepassword</span></span><br><span class="line"><span class="attr">SENTRY_EMAIL_USER:</span> <span class="string">sender@example.com</span></span><br><span class="line"><span class="attr">SENTRY_EMAIL_PORT:</span> <span class="number">587</span>  <span class="comment"># 如果使用TLS加密且采用465端口失效时可以尝试将端口改为587试试</span></span><br><span class="line"><span class="attr">SENTRY_EMAIL_USE_TLS:</span> <span class="string">&#x27;True&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后把生成的容器停止删除并重建一下，就可以了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line">docker-compose rm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面两个操作在新版本的docker-compose中可以使用docker-compose down来替代</span></span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h1 id="0XFFFF-Done"><a href="#0XFFFF-Done" class="headerlink" title="0XFFFF Done!"></a>0XFFFF Done!</h1><p>整体的大方面的配置就是这样了，具体的可以慢慢在web界面摸索一下，就这样啦</p>
<p>\口-口/</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Docker </tag>
            
            <tag> Sentry </tag>
            
            <tag> Exception </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django中事务的三种简单用法]]></title>
      <url>/2018/07/10/django-transactions/</url>
      <content type="html"><![CDATA[<h1 id="0X00-什么是“事务”"><a href="#0X00-什么是“事务”" class="headerlink" title="0X00 什么是“事务”"></a>0X00 什么是“事务”</h1><p>“事务”简单的说就是把一些数据库操作打包起来，要么就全部执行要么就全部不执行。</p>
<p>假设有一个操作是新建一个学生信息，有多张表分别记录了“基本信息、家庭信息、学校信息等“，那么就需要分成多步来新增这个学生的信息。但是如果在添加了”基本信息和家庭信息“两张表的内容后在添加”学校信息“时出现了错误那么数据库中就会存在该学生部分信息，从而使得数据库中的数据出现错误。</p>
<p>如果将这些操作放到一个”事务“中执行就可以在中途出现错误的时候所有数据库操作都不生效，当顺利执行完成之后使所有数据库操作都生效。总的来说就是”事务中出现错误则所有数据库操作都不生效，否则所有数据库操作均生效“。</p>
<p>具体可参见下面几个链接<br><a href="https://en.wikipedia.org/wiki/Database_transaction">Database transaction - Wikipedia</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/commit.html">MySQL Document</a></p>
<a id="more"></a>
<h1 id="0X01-将事务绑定到http请求"><a href="#0X01-将事务绑定到http请求" class="headerlink" title="0X01 将事务绑定到http请求"></a>0X01 将事务绑定到http请求</h1><p>在Django中实现数据库事务最简单明了的方法就是在数据库的配置中添加一个<code>ATOMIC_REQUESTS=True</code>。添加这个操作后Django会把每一个请求到响应的过程视为一个”事务“，从而在请求获得正确响应时应用这些数据库操作。如果在处理请求的过程中抛出了异常那么Django就会回滚这次事务。</p>
<p>***** 注意： ** 此时的所有处理的所有请求都会被包装成事务！</p>
<p>如果需要声明某些view不需要使用事务，那么可以通过使用如下方法阻止view使用事务</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"></span><br><span class="line"><span class="meta">@transaction.non_atomic_requests</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    do_stuff()</span><br></pre></td></tr></table></figure>

<p>而且事务会对数据库和Django造成更大的压力，所以此种方式并不是最好的使用事务的方法。</p>
<h1 id="0X02-使用-transaction-atomic装饰器"><a href="#0X02-使用-transaction-atomic装饰器" class="headerlink" title="0X02 使用@transaction.atomic装饰器"></a>0X02 使用<code>@transaction.atomic</code>装饰器</h1><p>我们使用事务通常是明确知道哪些方法需要使用，而不是像上面那种直接给所有view添加事务再一一排除那些不需要的。</p>
<p>所以Django中也有一种直接给某个方法标记为使用事务的方法：使用<code>@transaction.atomic</code>装饰器。例如下面的代码，如果你只需要给某个view使用事务或者只是需要给某个其他的方法使用事务，那么就可以使用这种方法来装饰function，从而使其在一个事务中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"></span><br><span class="line"><span class="meta">@transaction.atomic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span>(<span class="params">request</span>):</span></span><br><span class="line">    do_stuff()</span><br><span class="line"></span><br><span class="line"><span class="meta">@transaction.atomic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_func</span>():</span></span><br><span class="line">    do_stuff()</span><br></pre></td></tr></table></figure>

<h1 id="0X03-使用with-transaction-atomic-语句"><a href="#0X03-使用with-transaction-atomic-语句" class="headerlink" title="0X03 使用with transaction.atomic:语句"></a>0X03 使用<code>with transaction.atomic:</code>语句</h1><p>使用<code>@transaction.atomic</code>装饰器是直接给某个function打包为一个事务，但是在某些情况下还会有更小粒度的事务需求，下面给出一个情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> my_project <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_func</span>():</span></span><br><span class="line">    models.AAAAA.objects.filter().update(aaa=<span class="string">&#x27;456&#x27;</span>)</span><br><span class="line">    models.BBBBB.objects.filter().update(bbb=<span class="string">&#x27;789&#x27;</span>)</span><br><span class="line">    models.CCCCC.objects.filter().update(ccc=<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;江XXX，亦XXX&#x27;</span></span><br><span class="line">    <span class="string">&#x27;........&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果这段代码在更新model：<code>BBBBB</code>的时候出现了错误，那么其实AAAAA是更新了的，且由于抛出了异常所以BBBBB和CCCCC都没有被更新。此时数据库中的数据就是不符合我们要求的。这个时候就可以使用<code>with transaction.atomic</code>的方法来将一个代码块打包为一个事务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> my_project <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_func</span>():</span></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic:</span><br><span class="line">        models.AAAAA.objects.filter().update(aaa=<span class="string">&#x27;456&#x27;</span>)</span><br><span class="line">        models.BBBBB.objects.filter().update(bbb=<span class="string">&#x27;789&#x27;</span>)</span><br><span class="line">        models.CCCCC.objects.filter().update(ccc=<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;江XXX，亦XXX&#x27;</span></span><br><span class="line">    <span class="string">&#x27;........&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此时AAAAA/BBBBB/CCCCC这三个model的操作已经”同生同死“了。</p>
<blockquote>
<p>参考自： <a href="https://yiyibooks.cn/xx/Django_1.11.6/topics/db/transactions.html">Django中文文档</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Database </tag>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Transaction </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django与Django REST Framework中的这些"空"]]></title>
      <url>/2018/05/23/django-some-blank/</url>
      <content type="html"><![CDATA[<h1 id="0X00-Django-Model中的空"><a href="#0X00-Django-Model中的空" class="headerlink" title="0X00 Django Model中的空"></a>0X00 Django Model中的空</h1><p>Django的Model常见两个与空有关的参数：<code>null</code>和<code>blank</code>。其中<code>null</code>是数据库层面的是否允许为Null，而<code>blank</code>则将空处理为空值。比如一个<code>CharField</code>的<code>blank=True</code>，那么这个字段在没有赋值的情况下入库，这个字段就会是空字符串而不是Null。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: s = Student()</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: s.age=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: s.save()</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: s.name</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">u&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果将<code>blank=False</code>再不赋值该字段进行保存则入库的就是<code>Null</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: s = Student()</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: s.age = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: s.save()</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: s.name</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: type(s.name)</span><br><span class="line">Out[<span class="number">7</span>]: NoneType</span><br></pre></td></tr></table></figure>
<p>所以换句话说，<code>null=True</code>是数据库层面允许存储Null，而<code>blank=True</code>则是允许存入”空字符串”等表示空的值。</p>
<h1 id="0X01-Django-REST-framework中的空"><a href="#0X01-Django-REST-framework中的空" class="headerlink" title="0X01 Django REST framework中的空"></a>0X01 Django REST framework中的空</h1><p>在Django REST framework的serializer中的字段，有三个与空有关的，都是在创建或更新中生效。分别是<code>allow_blank/allow_null/require</code>这三个。其中<code>allow_blank=True</code>表示着<code>CharField/ListField</code>等允许传入<code>&quot;&quot;/[]</code>等空值；<code>allow_null=True</code>表示着允许传入<code>&#123;&quot;name&quot;: null, &quot;age&quot;: null&#125;</code>这种<code>null</code>空；<code>require=True</code>则表示着字段必填，如果name字段被设定了<code>require=True</code>那么在<code>POST/PUT/PATCH</code>等创建或更新数据时这个字段是必须要填写的。</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Django REST framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django REST Framework中要注意的几个点]]></title>
      <url>/2018/05/23/django-rest-framework-tips/</url>
      <content type="html"><![CDATA[<h1 id="0X00-Model中要注意的几点"><a href="#0X00-Model中要注意的几点" class="headerlink" title="0X00 Model中要注意的几点"></a>0X00 Model中要注意的几点</h1><h2 id="verbose-name-和-help-text-属性"><a href="#verbose-name-和-help-text-属性" class="headerlink" title="verbose_name 和 help_text 属性"></a>verbose_name 和 help_text 属性</h2><p>Model中通常第一个参数指定的是<code>verbose_name</code>，还要手动指定一个<code>help_text</code>属性。其中<code>verbose_name</code>属性是用来我们自己读的，而<code>help_text</code>是用于提供字段描述类的功能，比如在DJango Admin中<code>verbose_name</code>会变成字段的中文名，而<code>help_text</code>则会变成改字段的描述。</p>
<a id="more"></a>
<h2 id="unicode-方法"><a href="#unicode-方法" class="headerlink" title="unicode 方法"></a><strong>unicode</strong> 方法</h2><p>每一个Model类我们最好都要重写一下这个<code>__unicode__</code>方法，使之返回一个有意义的数据。比如一个学生信息的Model，我们不去重写这个方法，最后在<code>ipython</code>中或是项目中直接调的话就是这个样子的<code>&lt;QuerySet &lt;Student: 1&gt;, &lt;Student: 2&gt;, &lt;Student: 3&gt;]&gt;</code>。如果我们重写了这个方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__unicode__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#123;gender&#125;)&#123;name&#125;&#x27;</span>.format(gender=self.gender, name=self.name)</span><br></pre></td></tr></table></figure>
<p>那么返回值就是``&lt;QuerySet &lt;Student: (男)小明&gt;, &lt;Student: (女)小红&gt;, &lt;Student: (女)小兰d&gt;]&gt;`。不仅是在调试过程中还是程序里都会有不错的效果。</p>
<h2 id="关于choices"><a href="#关于choices" class="headerlink" title="关于choices"></a>关于choices</h2><p>在设计Model中常会用到choices属性，比较好的用法是这样的。命名的时候使用在字段名后加<code>choice</code>的全大写，也就是：<code>GENDER_CHOICE</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GENDER_CHOICE = (</span><br><span class="line">    (<span class="string">&#x27;male&#x27;</span>, <span class="string">u&#x27;男&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;female&#x27;</span>, <span class="string">u&#x27;女&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;other&#x27;</span>, <span class="string">u&#x27;其他&#x27;</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">gender = models.Charfield(</span><br><span class="line">    <span class="string">u&#x27;性别&#x27;</span>,</span><br><span class="line">    help_text=<span class="string">u&#x27;性别&#x27;</span>,</span><br><span class="line">    max_length=<span class="number">100</span>,</span><br><span class="line">    choices=GENDER_CHOICE,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h1 id="0X01-Serializer中要注意的几点"><a href="#0X01-Serializer中要注意的几点" class="headerlink" title="0X01 Serializer中要注意的几点"></a>0X01 Serializer中要注意的几点</h1><h2 id="针对list方法的Serializer"><a href="#针对list方法的Serializer" class="headerlink" title="针对list方法的Serializer"></a>针对list方法的Serializer</h2><p>还是上面学生信息的这个例子，前端调用<code>GET</code>方法后想要得到的明显是<code>男、女、未知</code>这种，所以我们应该为所有类似的字段搭配返回一个对应的可读字段。例如在获取学生信息时可以这样写Serializer。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListStudentSerialzier</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line"></span><br><span class="line">    gender_cn = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gender_cn</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="keyword">return</span> obj.get_gender_display()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Student</span><br><span class="line">        fields = ( </span><br><span class="line">            <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;gender&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;gender_cn&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;birthday&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;hobbys&#x27;</span>,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>在针对<code>List</code>的Serializer中添加字段<code>gender_cn</code>，顾名思义就是性别的中文，定义为<code>serializers.SerializerMethodField()</code>，定且在下面跌一个名为<code>def get_gender_ch(self, obj)</code>的方法，组装好所需要的数据返回就可以了。参数中的<code>obj</code>就是都应的实例化对象，在此处也就是一个<code>Student</code>对象。<br>最后要在<code>Meta</code>中的<code>fields</code>里加上这个字段。</p>
<p>另外，如果将Model中一个字段定义为<code>CharField</code>且Serializer处使用<code>ListField</code>进行校验存储的话，数据库中就会是类似<code>&quot;[1, 2, 3, 4, 5]&quot;</code>的“列表样子的字符串”。如果想让这种类型的字符串以一个正确的列表方式返回，例如字段<code>hobbys</code>，那么应该像<code>gender_cn</code>一样编写一个get方法，使用<code>json.loads()</code>的方式将“列表样子的字符串”转换为真正的列表返回。</p>
<h2 id="针对Create和Update的Serializer"><a href="#针对Create和Update的Serializer" class="headerlink" title="针对Create和Update的Serializer"></a>针对Create和Update的Serializer</h2><p>针对Create和Update的Serializer是要向<code>Django</code>推数据的，所以需要注意字段的合法性校验。要注意<code>Serializer</code>与<code>Model</code>中字段类型的对应，例如Serializer中的<code>ListFIeld</code>其实就是Model中的<code>CharField</code>。</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> Django REST framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Django中的Q对象查询]]></title>
      <url>/2018/05/20/django-query-q/</url>
      <content type="html"><![CDATA[<h1 id="0X00-普通的查询"><a href="#0X00-普通的查询" class="headerlink" title="0X00 普通的查询"></a>0X00 普通的查询</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line">queryset.filter(Q(age=<span class="number">233</span>)) <span class="comment"># 找到233岁的人</span></span><br><span class="line">queryset.filter(Q(name=<span class="string">&#x27;shawn&#x27;</span>)) <span class="comment"># 找到名为shawn的人</span></span><br></pre></td></tr></table></figure>
<p>这种查询方式与普通的方式比起来没什么区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queryset.filter(age=<span class="number">233</span>)</span><br><span class="line">queryset.filter(name=<span class="string">&#x27;shawn&#x27;</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="0X01-AND"><a href="#0X01-AND" class="headerlink" title="0X01 AND"></a>0X01 AND</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line">queryset.filter(Q(age__range=(<span class="number">18</span>, <span class="number">25</span>), Q(gender=<span class="string">&#x27;F&#x27;</span>), Q(beautiful=<span class="literal">True</span>)) <span class="comment"># 找到18到25岁的漂亮女生</span></span><br></pre></td></tr></table></figure>
<p>把多个条件用逗号分割开就可以了，或者使用<code>&amp;</code>符分割开。</p>
<h1 id="0X02-OR"><a href="#0X02-OR" class="headerlink" title="0X02 OR"></a>0X02 OR</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line">queryset.filter(Q(gender=<span class="string">&#x27;F&#x27;</span>) | Q(province=<span class="string">u&#x27;四川&#x27;</span>) | Q(name=<span class="string">u&#x27;王铁蛋&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这里用<code>|</code>符号分割开筛选条件，最终筛选得到的是”所有女生、四川人和叫王铁蛋的人”，也就是说相当于分别筛选了这三个条件，最终取了并集。这种查询如果用普通方法进行查询就会很麻烦，可能要写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryset.filter(gender=<span class="string">&#x27;f&#x27;</span>) | queryset.filter(province=<span class="string">u&#x27;province=u&#x27;</span>四川<span class="string">&#x27;) | queryset.filter(name=u&#x27;</span>王铁蛋<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>

<h1 id="0X03-NOT"><a href="#0X03-NOT" class="headerlink" title="0X03 NOT"></a>0X03 NOT</h1><p>使用Not查询的方式就比较诡异了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line">queryset.filter(~Q(gender=<span class="string">&#x27;M&#x27;</span>)) <span class="comment"># 找到非男生</span></span><br></pre></td></tr></table></figure>

<h1 id="0X04-组合技"><a href="#0X04-组合技" class="headerlink" title="0X04 组合技"></a>0X04 组合技</h1><p>有的时候经常需要查询同样的条件多次，这种方法就可以一次编写查询条件多次执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"></span><br><span class="line">q1 = reduce(operator.and_, Q(gender=<span class="string">&#x27;F&#x27;</span>, age__range=(<span class="number">18</span>, <span class="number">25</span>)))</span><br><span class="line">q2 = reduce(operator.or_, Q(gender=<span class="string">&#x27;M&#x27;</span>, age__range(<span class="number">3</span>, <span class="number">5</span>)))</span><br><span class="line"></span><br><span class="line">queryset.filter(q1)</span><br><span class="line">queryset.filter(q2)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fedora中dnf命令使用Socks5代理]]></title>
      <url>/2018/03/14/dnf-proxy/</url>
      <content type="html"><![CDATA[<p>在Linux下安装软件通常会使用包管理工具自动处理依赖问题，在Fedora下一般使用<code>dnf</code>包管理工具。一般我们会给自己的源设置为国内的镜像源，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn</span><br><span class="line">https:&#x2F;&#x2F;mirrors.ustc.edu.cn</span><br><span class="line">https:&#x2F;&#x2F;mirrors.163.com</span><br></pre></td></tr></table></figure>

<p>但是有的时候还是避免不了从国外源下载数据，这种情况下经常出现速度巨慢无比甚至会断开的情况。这种时候我们可以给<code>dnf</code>设置通过代理连接网络，这样一来下载速度就会快得多了。</p>
<p><code>sudo vim /etc/dnf/dnf.conf</code>编辑<code>dnf</code>的配置文件，添加如下配置，保存后再执行<code>dnf</code>命令就可以使用代理的方式连接了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">proxy_username&#x3D;shawn</span><br><span class="line">proxy_password&#x3D;shawn</span><br></pre></td></tr></table></figure>

<p>需要注意的几点：</p>
<ol>
<li>本示例只是针对我自己的电脑，如果你自己的Shadowsocks配置跟我的不同，请根据自己的配置自行修改（没有密码的可以不写后两项）</li>
<li>示例中使用了<code>socks4://</code>的协议，如果自己有其他方式的代理也可以使用，比如<code>http://</code>等</li>
<li>当不再使用的时候记得将配置注释掉，以防连接国内源也使用代理</li>
</ol>
<a id="more"></a>]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Fedora </tag>
            
            <tag> Proxy </tag>
            
            <tag> Shadowsocks </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Git Stash Save将暂存区命名]]></title>
      <url>/2018/03/05/git-stash/</url>
      <content type="html"><![CDATA[<h1 id="git-stash-save-apply-pop"><a href="#git-stash-save-apply-pop" class="headerlink" title="git stash save/apply/pop"></a>git stash save/apply/pop</h1><p>在用git的时候经常会有需要临时切分支等操作，但是如果当前工作区进行了修改就不能直接切分支。这时候呢就得把当前的代码暂存起来，可以这么操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>这样就吧上次commit到现在的修改都暂存起来了，可以使用<code>git stash show</code>来查看暂存区。我以前就是这样的，每次由两个或是两个以上的stash之后就蒙圈了，不知道那个stash做了哪些改变。虽然<code>git stash show</code>可以看到每个stash修改了哪些文件，但是还是不能准确的定位到自己需要的stash。</p>
<p>后来发现<code>git stash</code>后面还能继续接参数，这里得感谢<code>git plugin for oh-my-zsh</code>。当临时保存一些修改的时候可以这样：<code>git stash save &quot;fix:xxxxx&quot;</code>，有多个stash的时候也可以用<code>git stash show</code>来看到每个stash的备注，就方便多了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git on  new_branch [$?] via simple took 2s</span><br><span class="line">➜ git stash show stash@\&#123;0\&#125;</span><br><span class="line">stash@&#123;0&#125;: On new_branch: feature:xxxxx (38 seconds ago)               stash@&#123;3&#125;: On new_branch: create new file named hello.py (4 days ago)</span><br><span class="line">stash@&#123;1&#125;: On new_branch: fix:xxxxx (53 seconds ago)                   stash@&#123;4&#125;: WIP on master: 75e1918 add a (7 weeks ago)                </span><br><span class="line">stash@&#123;2&#125;: On new_branch: create file zzz (4 days ago)</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>其中<code>git stash pop</code>是应用一个stash，并删除这个stash。<code>git stash apply</code>是只应用不删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git on  new_branch [$] via simple</span><br><span class="line">➜ git stash pop stash@\&#123;0\&#125;</span><br><span class="line">On branch new_branch</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   a</span><br><span class="line"></span><br><span class="line">Dropped stash@&#123;0&#125; (163b1e2391b4c8bd792701ac4318d928e0e12556)</span><br><span class="line"></span><br><span class="line">git on  new_branch [$] via simple</span><br><span class="line">➜ git stash apply stash@\&#123;1\&#125;</span><br><span class="line">On branch new_branch</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>善用git可以大幅提升效率哦</p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker中备份与恢复镜像]]></title>
      <url>/2018/02/15/docker-load-save/</url>
      <content type="html"><![CDATA[<h1 id="0X00-遇到了一个问题"><a href="#0X00-遇到了一个问题" class="headerlink" title="0X00 遇到了一个问题"></a>0X00 遇到了一个问题</h1><p>前段时间自己的电脑重装了系统，然后公司内网的Docker hub出了点问题，没办法继续开发。后来经过一波Google找到了一个可以备份与恢复Image的方法，使用<code>docker save / docker load</code>命令。</p>
<h1 id="0X01-备份与导入镜像"><a href="#0X01-备份与导入镜像" class="headerlink" title="0X01 备份与导入镜像"></a>0X01 备份与导入镜像</h1><p>首先查看自己的镜像，然后找一个准备备份的镜像，找到他的<code>IMAGE ID</code>，假设选中的是<code>ubuntu</code>的镜像，那就使用<code>dokcer save 0458a4468cbc --output ubuntu.tar</code>就可以把ubuntu.tar文件拷贝到其他电脑上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nextcloud                      latest              9d7d01184cbf        9 days ago          593MB</span><br><span class="line">rabbitmq                       latest              72cee1616e73        2 weeks ago         127MB</span><br><span class="line">ubuntu                         latest              0458a4468cbc        2 weeks ago         112MB</span><br><span class="line">redis                          latest              861cc310cd91        3 weeks ago         107MB</span><br><span class="line">mysql                          5.7.17              9546ca122d3a        10 months ago       407MB</span><br><span class="line">mongo                          3.4.2               5bc602c0b7fe        10 months ago       360MB</span><br></pre></td></tr></table></figure>

<p>到另外一台电脑上执行<code>docker load --input ubuntu.tar</code>就可以把这个镜像导入进去。</p>
]]></content>
      
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中的enumerate()方法]]></title>
      <url>/2017/12/24/python-enumerate/</url>
      <content type="html"><![CDATA[<h1 id="0X00-enumerate是什么"><a href="#0X00-enumerate是什么" class="headerlink" title="0X00 enumerate是什么"></a>0X00 enumerate是什么</h1><p><code>enumerate()</code>是一个Python自带的函数，用来同时遍历刻碟带对象和索引值．</p>
<h1 id="0X01-enumerate怎么用"><a href="#0X01-enumerate怎么用" class="headerlink" title="0X01 enumerate怎么用"></a>0X01 enumerate怎么用</h1><p>如果不在不使用<code>enumerate()</code>的情况下去除一个字符串列表中的字符串中的空格，那么通常会写出下面这种程序．</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">my_list = [<span class="string">&quot;   搞个大  新闻&quot;</span>, <span class="string">&quot;我作  为一 个长者&quot;</span>, <span class="string">&quot;比 谁跑 的都快&quot;</span>,</span><br><span class="line">           <span class="string">&quot;哪 个国家 我没 去过&quot;</span>, <span class="string">&quot;比你们不  知道     高到 哪里去了&quot;</span>,</span><br><span class="line">           <span class="string">&quot;谈 笑风生  &quot;</span>, <span class="string">&quot;当然 支持    啊&quot;</span>, <span class="string">&quot;遵循  基本法  的   &quot;</span>]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">    my_list[index] = item.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    index = index + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到光是处理空格都用了四行，而且还并不怎么优雅．那么可以使用<code>enumerate()</code>来修改一下这个程序．</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">my_list = [<span class="string">&quot;   搞个大  新闻&quot;</span>, <span class="string">&quot;我作  为一 个长者&quot;</span>, <span class="string">&quot;比 谁跑 的都快&quot;</span>,</span><br><span class="line">           <span class="string">&quot;哪 个国家 我没 去过&quot;</span>, <span class="string">&quot;比你们不  知道     高到 哪里去了&quot;</span>,</span><br><span class="line">           <span class="string">&quot;谈 笑风生  &quot;</span>, <span class="string">&quot;当然 支持    啊&quot;</span>, <span class="string">&quot;遵循  基本法  的   &quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(my_list):</span><br><span class="line">    my_list[index] = item.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>语法大概就是这<code>for 索引, 对象 in enumerate(可迭代对象)</code>．用起来不仅干净优雅而且可读性也更强了．</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> enumerate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中的pyc文件]]></title>
      <url>/2017/12/23/python-pyc/</url>
      <content type="html"><![CDATA[<p>我们在编写Python程序的时候会发现在我们的目录中可能会出现与源代码同名的pyc文件生成，比如有一个源码文件是<code>hello.py</code>那么可能会生成一个<code>hello.pyc</code>文件出来．这个pyc文件是Python的字节码文件，就类似于Java中的<code>hello.class</code>一样．</p>
<p>Python虽然是解释性语言，但还是可以有一个编译的过程，只不过是编译成字节码文件罢了．如果我们的源码带有包含关系，比如源码<code>a.py</code>里面<code>import</code>了源码文件<code>b.py</code>，那么在执行<code>python a.py</code>的时候就会将<code>b.py</code>编译成<code>b.pyc</code>．</p>
<p>下次再运行<code>python a.py</code>的时候解释器会检查<code>b.py</code>与<code>b.pyc</code>的修改时间，如果一致就代表源码没有修改过，那么就可以直接调用<code>b.pyc</code>来更快的执行程序，如果时间不同那就证明<code>b.py</code>被修改过，则会重新编译<code>b.py</code>．</p>
<p>其中<code>pyc</code>文件的主要作用是用来加快程序执行速度的，虽然编译出来的<code>pyc</code>是二进制文件，不能看到内部的内容，但是还是不要把这种方式作为保护源码的方法．因为这种<code>pyc</code>文件是可以轻易被反编译的，有很多开源库可以轻松的反编译<code>pyc</code>文件，甚至都有web程序来反编译<code>pyc</code>文件，比如这个<a href="https://tool.lu/pyc/">tool.lu</a>就可以通过上传文件<code>pyc</code>文件的方式反编译．</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> pyc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用uwsgi和supervisor部署Django程序]]></title>
      <url>/2017/12/23/django-uwsgi-supervisor/</url>
      <content type="html"><![CDATA[<h1 id="0X00-使用uwsgi启动Django"><a href="#0X00-使用uwsgi启动Django" class="headerlink" title="0X00 使用uwsgi启动Django"></a>0X00 使用uwsgi启动Django</h1><p>首先安装uwsgi，<code>pip install uwsgi</code>就可以装好．然后找到Django生成的<code>wsgi.py</code>文件，这文件通常实在与项目名同名的app目录下的，比如我的项目名为<code>django_test</code>那么这个文件应该就在<code>django_test/wsgi.py</code>．然后执行<code>uwsgi --http 0.0.0.0:8080 --wsgi-file django_test/wssgi.py</code>就可以用uwsgi启动你的Django项目了.<br>Django自带的<code>python manage.py runserver</code>用于调试还是可以的，不过如果用于生产环境的不论是安全性还是性能都不足以满足生产环境的需要.</p>
<h1 id="0X01-使用supervisor维持服务在线"><a href="#0X01-使用supervisor维持服务在线" class="headerlink" title="0X01 使用supervisor维持服务在线"></a>0X01 使用supervisor维持服务在线</h1><p>我们知道由于Linux系统的进程管理机制，导致在bash里启动的程序如果退出bash就会自动被kill掉．所以我们需要一个能让进程一直活下去的方法，其中<code>nohup</code>是我们常用的方法，不过这种方法也只是能让进程活在后台罢了，平时跑个脚本或是其他小程序还可以，如果是部署一个服务的话就不合适了．这里我们选用<code>supervisor</code>来维持服务．</p>
<a id="more"></a>
<p>这个工具也是Python写的，所以可以使用pip安装<code>pip install supervisor</code>．然后我们可以在任意位置创建一个<code>supervisor</code>的配置文件<code>django_test_supervisor.conf</code>，启动supervissor的时候会指定这个文件，所以这个配置文件不像是其他配置那样全局使用．配置文件简单中的命令和日志需要自行修改，其中命令要修改成自己使用uwsgi启动Django的命令，日志位置要存在，不要没有那个目录．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file&#x3D;&#x2F;tmp&#x2F;supervisor.sock   ; (the path to the socket file)</span><br><span class="line"></span><br><span class="line">[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">port&#x3D;127.0.0.1:9001        ; (ip_address:port specifier, *:port for all iface)</span><br><span class="line"></span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL  for a unix socket</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">nodaemon&#x3D;false  # 值为false时supervisor在后台运行</span><br><span class="line">logfile&#x3D;&#x2F;data&#x2F;log&#x2F;supervisord.log   # supervisor　的日志</span><br><span class="line">pidfile&#x3D;&#x2F;data&#x2F;supervisord.pid       # supervisor　的日志</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[program:django_test]</span><br><span class="line">command&#x3D;uwsgi --http 0.0.0.0:8080 --chdir &#x2F;home&#x2F;shawn&#x2F;django_test --wsgi-file django_test&#x2F;wsgi.py  ＃　要执行的命令，其中chdir指定的是项目的目录</span><br><span class="line">stopsignal&#x3D;HUP</span><br><span class="line">stopasgroup&#x3D;true</span><br><span class="line">killasgroup&#x3D;true</span><br><span class="line">autorestart&#x3D;true</span><br><span class="line">stdout_logfile&#x3D;&#x2F;data&#x2F;log&#x2F;uwsgi.log  # uwsgi　的日志</span><br><span class="line">stderr_logfile&#x3D;&#x2F;data&#x2F;log&#x2F;uwsgi.log  # uwsgi　的日志</span><br><span class="line">stdout_logfile_maxbytes &#x3D; 20MB</span><br><span class="line">stderr_logfile_maxbytes &#x3D; 20MB</span><br><span class="line"></span><br><span class="line">[group:django_test]</span><br><span class="line">programs&#x3D;django_test</span><br></pre></td></tr></table></figure>
<p>写好配置文件之后启动supervisor，<code>supervisord -c django_test_supervisor.conf</code>就可以把服务启动起来了．</p>
<p>启动起来之后可以进入控制台去管理任务．<code>supervisorctl -c django_test_supervisor.conf</code>可以进入到supervisor的命令行，并且可以看到管理的进程．可以通过<code>start django_test/stop django_test/restart django_test</code>等命令去操作进程．</p>
<h1 id="0X02-后记"><a href="#0X02-后记" class="headerlink" title="0X02 后记"></a>0X02 后记</h1><p>现在服务已经可以直接上线了，但是通常情况下我们会让Nginx代理一下到uwsgi，这样静态文件什么的就不会再走一次Python程序了．</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
            <tag> uWSGI </tag>
            
            <tag> Supervisor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python自动化运维与远程部署：fabric]]></title>
      <url>/2017/12/10/python-fabric/</url>
      <content type="html"><![CDATA[<h1 id="0X00-安装fabric"><a href="#0X00-安装fabric" class="headerlink" title="0X00 安装fabric"></a>0X00 安装fabric</h1><p>使用pip可以轻松地安装fabric</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fabric</span><br></pre></td></tr></table></figure>

<h1 id="0X01-初次调用"><a href="#0X01-初次调用" class="headerlink" title="0X01 初次调用"></a>0X01 初次调用</h1><p>在当前目录下创建一个名为<code>fabfile.py</code>的文件，填写文件内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> fabric</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;hello,world&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后在当前目录下执行命令<code>fab test</code>就可以看到一条<code>hello,world</code>输出了。</p>
<h1 id="0X02-浅显的道理"><a href="#0X02-浅显的道理" class="headerlink" title="0X02 浅显的道理"></a>0X02 浅显的道理</h1><p>根据上面简单的例子可以看出来fab命令执行的时候会默认找到当前目录下的<code>fabfile.py</code>文件，找到后会用fab命令的参数去匹配<code>fabfile.py</code>中的函数名，执行相应的功能。</p>
<blockquote>
<p>实际上当前目录可以没有<code>fabfile.py</code>，如果当前目录的上级目录中有<code>fabfile.py</code>是会采用上级目录中的<code>fabfile.py</code>的。而且文件名也不一定用<code>fabfile.py</code>，假设取了一个名为<code>asdf.py</code>的文件，那么只需要执行<code>fab -f asdf.py</code>就可以采用这个<code>fabfile</code>了。</p>
</blockquote>
<a id="more"></a>
<h1 id="0X03-执行本地命令"><a href="#0X03-执行本地命令" class="headerlink" title="0X03 执行本地命令"></a>0X03 执行本地命令</h1><p>作为一个可以用来自动化运维和远程部署的库，运行本地命令是一个必不可少的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_home_dir</span>():</span></span><br><span class="line">    local(<span class="string">&#x27;ls ~/.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里的<code>local</code>方法就是执行本地命令，并将输出打印出来。然后运行<code>fab list_home_dir</code>就可以看到自己<code>~</code>目录下的文件们了。当然，也可以带参数的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cp_file</span>(<span class="params">file_a, file_b</span>):</span></span><br><span class="line">    local(<span class="string">&#x27;cp %s %s&#x27;</span> % (file_a, file_b))</span><br></pre></td></tr></table></figure>
<p>调用这个方法的时候可以通过<code>fab cp_file:&quot;file_a=~/hello.py,file_b=~/hello_b.py&quot;</code>这个命令将<code>~/hello.py复制到hello_b.py</code>。</p>
<h1 id="0X04-执行远程命令"><a href="#0X04-执行远程命令" class="headerlink" title="0X04 执行远程命令"></a>0X04 执行远程命令</h1><p>fabric用处最大的一点就是远程执行命令了。使用下面这段代码，运行<code>fab list_home</code>后<code>fabric</code>会使用你提供的登录信息通过<code>SSH</code>登录到远程机器上执行<code>ls ~/.</code>的命令。其中<code>run()</code>就是在远程机器上执行命令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> run, env</span><br><span class="line"></span><br><span class="line">env.hosts = [<span class="string">&#x27;qcloud.just666.cn&#x27;</span>, ]</span><br><span class="line">env.user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">env.password = <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_home</span>():</span></span><br><span class="line">    run(<span class="string">&#x27;ls ~/.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="0X05-多台机器执行相同的命令"><a href="#0X05-多台机器执行相同的命令" class="headerlink" title="0X05 多台机器执行相同的命令"></a>0X05 多台机器执行相同的命令</h1><p>有的时候我们有多台机器，需要执行相同的命令，这种时候就可以用<code>env.passwords</code>来解决问题。通过<code>hosts</code>指定用户名和主机，用<code>passwords</code>指定密码，就可以同时登录到多台机器上了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> env, run</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定主机</span></span><br><span class="line">env.hosts = [</span><br><span class="line">    <span class="string">&#x27;root@qcloud.just666.cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;root@aliyun.just666.cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;root@aws.just666.cn&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定密码</span></span><br><span class="line">env.passwords = &#123;</span><br><span class="line">    <span class="string">&#x27;root@qcloud.just666.cn&#x27;</span>: <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;root@aliyun.just666.cn&#x27;</span>: <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;root@aws.just666.cn&#x27;</span>: <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    run(<span class="string">&#x27;ls ~/.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>其实我也不是很懂，既然<code>env.passwords</code>都已经制定了用户名，主机和密码为什么还要用hosts再指定一次呢？不是很懂，注释过<code>hosts</code>，就不能用了。</p>
<h1 id="0X06-多台机器执行不同命令"><a href="#0X06-多台机器执行不同命令" class="headerlink" title="0X06 多台机器执行不同命令"></a>0X06 多台机器执行不同命令</h1><p>不过通常情况下我们是有不止一台远程机器的，要不然也不会需要什么自动化了。那么假设我们有三台机器，分别是<code>mysql/apache/nginx</code>这三个服务，那么我们可以这么写脚本。这样我们可以通过<code>fab start_firewalld</code>启动三台机器的防火墙，使用<code>fab start_mysql/start_httpd/start_nginx</code>分别启动在这三台机器上的三个服务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> env, run, roles</span><br><span class="line"></span><br><span class="line">env.hosts = [</span><br><span class="line">    <span class="string">&#x27;root@mysql.just666.cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;root@apache.just666.cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;root@nginx.just666.cn&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">env.passwords = &#123;</span><br><span class="line">    <span class="string">&#x27;root@mysql.just666.cn&#x27;</span>: <span class="string">&#x27;zhangHAO8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;root@apache.just666.cn&#x27;</span>: <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;root@nginx.just666.cn&#x27;</span>: <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">env.roledefs = &#123;</span><br><span class="line">    <span class="string">&#x27;all&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;root@mysql.just666.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;root@apache.just666.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;root@nginx.just666.cn&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;mysql&#x27;</span>: [<span class="string">&#x27;root@mysql.just666.cn&#x27;</span>, ],</span><br><span class="line">    <span class="string">&#x27;apache&#x27;</span>: [<span class="string">&#x27;root@apache.just666.cn&#x27;</span>, ],</span><br><span class="line">    <span class="string">&#x27;nginx&#x27;</span>: [<span class="string">&#x27;root@nginx.just666.cn&#x27;</span>, ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@roles(&#x27;all&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_firewalld</span>():</span></span><br><span class="line">    run(<span class="string">&#x27;systemctl start firewalld&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@roles(&#x27;mysql&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_mysql</span>():</span></span><br><span class="line">    run(<span class="string">&#x27;systemctl start mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@roles(&#x27;apache&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_httpd</span>():</span></span><br><span class="line">    run(<span class="string">&#x27;systemctl start httpd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@roles(&#x27;nginx&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_nginx</span>():</span></span><br><span class="line">    run(<span class="string">&#x27;systemctl start nginx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="0X07-并发任务"><a href="#0X07-并发任务" class="headerlink" title="0X07 并发任务"></a>0X07 并发任务</h1><p>通常情况下<code>fabric</code>是穿行执行任务的，假设有100台机器要执行相同的命令，虽然我们批量化了，但是他们依旧是串行的，导致效率比较低。这种时候我们可以采用<code>@parallel</code>装饰器来使方法变成并行的。比如有一个方法<code>def test_speed</code>用来测试机器的网速，需要持续一分钟才行，并且有很多台机器，那么这个<code>@parallel</code>就可以发挥作用了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> parallel</span><br><span class="line"></span><br><span class="line"><span class="meta">@parallel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_speed</span>():</span></span><br><span class="line">    run(<span class="string">&#x27;test_speed&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时这些任务就是并行的了，会快很多。不过如果真的有非常多的机器要并行，那么fabric可能扛不住，可以给并行数量设置一个上限<code>@parallel(pool_size=10)</code>，这样就是最高10个并行任务了。</p>
<h1 id="0X08-传文件"><a href="#0X08-传文件" class="headerlink" title="0X08 传文件"></a>0X08 传文件</h1><p>文件传输用的是<code>scp</code>的原理，分成两个方法，分别是<code>get/put</code>，用法也非常简单就像普通的<code>cp</code>一样。<code>get(&#39;remote_file&#39;, &#39;local_file&#39;)</code>和<code>put(&#39;local_file&#39;, &#39;remote_file&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> env, get, put</span><br><span class="line"></span><br><span class="line">env.hosts = [<span class="string">&#x27;qcloud.just666.cn&#x27;</span>, ]</span><br><span class="line">env.user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">env.password = <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_vimrc</span>():</span></span><br><span class="line">    get(<span class="string">&#x27;~/.vimrc&#x27;</span>, <span class="string">&#x27;~/.vimrc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put_vimrc</span>():</span></span><br><span class="line">    put(<span class="string">&#x27;~/.vimrc&#x27;</span>, <span class="string">&#x27;~/.vimrc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="0X09-切目录"><a href="#0X09-切目录" class="headerlink" title="0X09 切目录"></a>0X09 切目录</h1><p>在<code>fabric</code>中切目录要配合Python的<code>with</code>语法使用。共有<code>cd/lcd</code>这两种切目录方法，对应的是远程目录和本地目录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> env, cd, lcd</span><br><span class="line"></span><br><span class="line">env.hosts = [<span class="string">&#x27;qcloud.just666.cn&#x27;</span>, ]</span><br><span class="line">env.user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">env.password = <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_local_dir</span>():</span></span><br><span class="line">    <span class="keyword">with</span> lcd(<span class="string">&#x27;/&#x27;</span>):  <span class="comment"># 切到本地根目录</span></span><br><span class="line">      local(<span class="string">&#x27;ls&#x27;</span>) <span class="comment"># 在目录下执行命令</span></span><br><span class="line">    <span class="keyword">with</span> lcd(<span class="string">&#x27;~&#x27;</span>):  <span class="comment"># 切到本地主目录</span></span><br><span class="line">      local(<span class="string">&#x27;ls&#x27;</span>) <span class="comment"># 在目录下执行命令</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_remote_dir</span>():</span></span><br><span class="line">    <span class="keyword">with</span> cd(<span class="string">&#x27;/&#x27;</span>):   <span class="comment"># 切到远程根目录</span></span><br><span class="line">      run(<span class="string">&#x27;ls&#x27;</span>) <span class="comment"># 在目录下执行命令</span></span><br><span class="line">    <span class="keyword">with</span> cd(<span class="string">&#x27;~&#x27;</span>):   <span class="comment"># 切到远程主目录</span></span><br><span class="line">      run(<span class="string">&#x27;ls&#x27;</span>) <span class="comment"># 在目录下执行命令</span></span><br></pre></td></tr></table></figure>

<h1 id="0X0A-PATH"><a href="#0X0A-PATH" class="headerlink" title="0X0A PATH"></a>0X0A PATH</h1><p>有的时候我们需要临时添加PATH，可以通过这种方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> env, run, path</span><br><span class="line"></span><br><span class="line">env.hosts = [<span class="string">&#x27;qcloud.just666.cn&#x27;</span>, ]</span><br><span class="line">env.user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">env.password = <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">with</span> path(<span class="string">&#x27;/home/shawn/.envs/study_django/bin/&#x27;</span>): <span class="comment"># 添加目录到PATH中</span></span><br><span class="line">        run(<span class="string">&#x27;echo $PATH&#x27;</span>) <span class="comment"># 查看新的PATH</span></span><br><span class="line">    run(<span class="string">&#x27;echo $PATH&#x27;</span>) <span class="comment"># 退出去后PATH也被删除了</span></span><br></pre></td></tr></table></figure>

<h1 id="0X0B-环境变量"><a href="#0X0B-环境变量" class="headerlink" title="0X0B 环境变量"></a>0X0B 环境变量</h1><p>如果要临时修改环境变量的话可以这样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.api <span class="keyword">import</span> env, run, local, shell_env</span><br><span class="line"></span><br><span class="line">env.hosts = [<span class="string">&#x27;qcloud.just666.cn&#x27;</span>, ]</span><br><span class="line">env.user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">env.password = <span class="string">&#x27;5L2g5b2T5oiR5YK75ZWK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="keyword">with</span> shell_env(JAVA_HOME=<span class="string">&#x27;/opt/oracle/java&#x27;</span>):</span><br><span class="line">        run(<span class="string">&#x27;echo $JAVA_HOME&#x27;</span>)  <span class="comment"># 远程机器的环境变量被修改了</span></span><br><span class="line">        local(<span class="string">&#x27;echo $JAVA_HOME&#x27;</span>)  <span class="comment"># 本地的环境变量也被临时修改了。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改只是暂时的，退出<code>with</code>之后就会恢复原状的。</p>
</blockquote>
<h1 id="0X0C-带颜色输出"><a href="#0X0C-带颜色输出" class="headerlink" title="0X0C 带颜色输出"></a>0X0C 带颜色输出</h1><p>有的时候为了便与查看输出结果，我们可能会需要用不同颜色的字标示不同的内容。比如用红色标示失败，黄色标示警告，绿色标示成功等。<code>fabric</code>也可以轻松实现这个功能的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fabric.colors <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_color</span>():</span></span><br><span class="line">    <span class="keyword">print</span> green(<span class="string">&quot;OK.&quot;</span>)</span><br><span class="line">    <span class="keyword">print</span> yellow(<span class="string">&quot;Warning&quot;</span>)</span><br><span class="line">    <span class="keyword">print</span> red(<span class="string">&quot;Error&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> fabric </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中的迭代、生成和yield关键字]]></title>
      <url>/2017/11/12/python-iteration-yield/</url>
      <content type="html"><![CDATA[<h1 id="0X00-可迭代对象"><a href="#0X00-可迭代对象" class="headerlink" title="0X00 可迭代对象"></a>0X00 可迭代对象</h1><p>Python中的列表，元组，字典，文件都是可迭代对。可迭代对象简单地说就是可以用<code>for i in xxx:</code>来遍历的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_llist:</span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line">my_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="string">u&#x27;苟利国家生死以&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="string">u&#x27;岂因祸福避趋之&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_dict:</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>

<p>不过如果数据量非常非常庞大的时候，会很影响程序的性能。这种时候就可以使用生成器来解决这个问题。</p>
<h1 id="0X01-生成器"><a href="#0X01-生成器" class="headerlink" title="0X01 生成器"></a>0X01 生成器</h1><p>生成器的用法和普通的可迭代对象差不多，最大的特点就是：“用的时候才去计算”。这里写一个简单的例子，演示一下情况。第一种生成超大列表的方式要逐项计算完才算弄出来了这个10000长的列表，而后者是生成器，只是声明了怎么算，并没有真的去算，所以在速度上才是完全不能比的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    [x**x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000</span>)]    <span class="comment"># 这里生成的是一个超大的列表</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">print</span> end - start</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    (x**x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000</span>))    <span class="comment"># 这里生成一个超大的生成器（注意看，括号不一样）</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">print</span> end - start</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shawn in ~ λ python hello.py</span><br><span class="line">6.76475715637</span><br><span class="line">0.000135898590088</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="0X02-yield关键字"><a href="#0X02-yield关键字" class="headerlink" title="0X02 yield关键字"></a>0X02 yield关键字</h1><p>那是时候自己生成弄一个生成器出来了，Python中提供的yield关键字就是用来干这个的，通过这个关键字可以创造自己的生成器。<br>还是上面同样的例子，稍加改动</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_list</span>():</span></span><br><span class="line">    <span class="comment"># 创建一个普通的列表</span></span><br><span class="line">    my_list = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        my_list.append(x**x)</span><br><span class="line">    <span class="keyword">return</span> my_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_yield</span>():</span></span><br><span class="line">    <span class="comment"># 使用yield</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">yield</span> x**x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    a = create_list()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">print</span> end - start</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    a = test_yield()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">print</span> end - start</span><br></pre></td></tr></table></figure>
<p>运行起来看到的时间差距和刚刚演示的也差不多</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shawn in ~ λ python hello.py</span><br><span class="line">6.45007514954</span><br><span class="line">0.0080668926239</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Iteration </tag>
            
            <tag> yield </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git初步使用经验]]></title>
      <url>/2017/11/12/git-experience/</url>
      <content type="html"><![CDATA[<h1 id="0X00-怎样正确使用分支"><a href="#0X00-怎样正确使用分支" class="headerlink" title="0X00 怎样正确使用分支"></a>0X00 怎样正确使用分支</h1><p>通常情况下一个git仓库要保持三个及以上的分支，基本的分支明明如下：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>正常运行的稳定版本</td>
</tr>
<tr>
<td>develop</td>
<td>正常运行的开发版</td>
</tr>
<tr>
<td>feature</td>
<td>添加新功能的分支</td>
</tr>
<tr>
<td>hotfix</td>
<td>紧急修复bug的分支</td>
</tr>
</tbody></table>
<p>如果你已经fork了一份代码到自己本地，当你想添加一个新功能比如「用户管理」的时候，就应该先换到<code>develop</code>分支，然后由这个分支创建一个新的名为<code>feture_add_usermanager</code>的分支。在新分支里编写代码后将代码提交一个PullRequest到自己的<code>develop</code>分支，合并起来后再提交一个PullRequest到团队的仓库中，等待团队其他成员review后就可以正式将代码合并到团队的<code>develop</code>中了。等下一次发布新版本的时候就可以将团队的<code>develop</code>分支合并到团队的<code>master</code>分支中了了。</p>
<p>如果中途项目出现了严重bug(不能登录)需要即使修改上线，那就从自己的<code>master</code>分支上新建一个名为<code>hotfix_cantlogin</code>的分支，修改完后直接提交PullRequest到团队的<code>master</code>分支，review且合并后就可以将该分支删除了。</p>
<a id="more"></a>
<h1 id="0X01-合并多次commit"><a href="#0X01-合并多次commit" class="headerlink" title="0X01 合并多次commit"></a>0X01 合并多次commit</h1><p>有的时候会出现这么一种情况：连续的n次commit解决的都是同一个问题，为了让最终的提交记录清晰明了，可以将这几次的commit合并为一次。看下面的实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">commit bc83e15e3245ad4064fdd9fe2bf105252d0c51fc (HEAD -&gt; develop)</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Mon Nov 6 00:52:43 2017 +0800</span><br><span class="line"></span><br><span class="line">    fix usermanager</span><br><span class="line"></span><br><span class="line">commit affc0acb9a3de30288f144ae2d0b28a9fd60af4b</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Mon Nov 6 00:52:33 2017 +0800</span><br><span class="line"></span><br><span class="line">    fix usermanager</span><br><span class="line"></span><br><span class="line">commit fcf13d712bd3dbd483442ffd316741e04acaaa3e</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Mon Nov 6 00:52:23 2017 +0800</span><br><span class="line"></span><br><span class="line">    fix usermanager</span><br><span class="line"></span><br><span class="line">commit 2812e2928913e9b3a7650e389602b8bb10ca388b</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Mon Nov 6 00:52:08 2017 +0800</span><br><span class="line"></span><br><span class="line">    fix usermanager</span><br><span class="line"></span><br><span class="line">commit f7f273d9c36d748183ac3e6a90f06ff14ed42f95</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Mon Nov 6 00:51:52 2017 +0800</span><br><span class="line"></span><br><span class="line">    add user_manager</span><br></pre></td></tr></table></figure>
<p>最近的四次提交内容都是一样的，修改了四次bug最终才解决了问题，因为最近四次的commit是相同含义的修改，所以最好合并在一起，可以使用这个方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 最后接的id是你合并的这些commit之前的一个</span></span><br><span class="line">git rebase -i f7f273d9c36d748183ac3e6a90f06ff14ed42f95</span><br><span class="line"></span><br><span class="line">＃ 输入命令之后到vi环境的界面</span><br><span class="line">pick 2812e29 fix usermanager</span><br><span class="line">pick fcf13d7 fix usermanager</span><br><span class="line">pick affc0ac fix usermanager</span><br><span class="line">pick bc83e15 fix usermanager</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们将其修改为</span></span><br><span class="line">pick 2812e29 fix usermanager</span><br><span class="line">squash fcf13d7 fix usermanager</span><br><span class="line">squash affc0ac fix usermanager</span><br><span class="line">squash bc83e15 fix usermanager</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存退出，进入commit message修改的界面</span></span><br><span class="line">这里会展示出合并的这几次commit的message，我们选择性的修改一下将这几次的commit message整合一下，继续保存。这次保存之后就相当把这几次的commit合并成一次了。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果你是从仓库中clone下来的项目，那么有可能在你合并完几个commit后再<code>git push</code>会提示错误。假设以前是有100次commit的，现在你合并了最后的三次，再push，就会和远端的仓库出现分歧。一般情况下都是在确认自己的代码没问题之后，使用<code>git push -f</code>的方式强行把代码推上去，这样就会覆盖掉最后的几次commit，以你新push的代码为基准了。</p>
</blockquote>
<h1 id="0X02-迁移一次commit"><a href="#0X02-迁移一次commit" class="headerlink" title="0X02 迁移一次commit"></a>0X02 迁移一次commit</h1><p>有的时候我们需要将某个分支中的某次提交复制到另一个分支，具体使用情景有很多。这里展示一个使用样例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">git log 查看master分支的commit，只有这一次</span><br><span class="line"></span><br><span class="line">commit 2959f92753d84bff5b125b15cd9497c4d8dff637 (HEAD -&gt; master)</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Sun Nov 12 16:09:07 2017 +0800</span><br><span class="line"></span><br><span class="line">    完成XXX功能</span><br><span class="line"></span><br><span class="line">切换到dev分支查看commit，有四次</span><br><span class="line">commit bba77c7faf7821802b108688a17d8e6655975b7e (HEAD -&gt; dev)</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Sun Nov 12 16:11:47 2017 +0800</span><br><span class="line"></span><br><span class="line">    整理XXX</span><br><span class="line"></span><br><span class="line">commit 9001f8250ce47a067c9af50bf62af025b872c3bc</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Sun Nov 12 16:11:37 2017 +0800</span><br><span class="line"></span><br><span class="line">    添加XXX</span><br><span class="line"></span><br><span class="line">commit 6e4171ad632a7627be08ec7c9afaf64f55ccc98d</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Sun Nov 12 16:11:21 2017 +0800</span><br><span class="line"></span><br><span class="line">    修复XXX</span><br><span class="line"></span><br><span class="line">commit 2959f92753d84bff5b125b15cd9497c4d8dff637 (master)</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Sun Nov 12 16:09:07 2017 +0800</span><br><span class="line"></span><br><span class="line">    完成XXX功能</span><br><span class="line"></span><br><span class="line">如果此时我想将那个“添加XXX”的commit移到master分支，可以使用`git cherry-pick`</span><br><span class="line">可以看到“添加XXX”的那次commit的ID为`6e4171ad632a7627be08ec7c9afaf64f55ccc98d`</span><br><span class="line">我们复制这个ID，切到master分支，使用`git cherry-pick commit_id`</span><br><span class="line">shawn in ~/test on master λ git cherry-pick 6e4171ad632a7627be08ec7c9afaf64f55ccc98d</span><br><span class="line">[master f77b496] 修复XXX</span><br><span class="line"> Date: Sun Nov 12 16:11:21 2017 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 b</span><br><span class="line">shawn in ~/test on master λ git log</span><br><span class="line">commit f77b49677efb1ba967dbc323332e2f8495fdbca1 (HEAD -&gt; master)</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Sun Nov 12 16:11:21 2017 +0800</span><br><span class="line"></span><br><span class="line">    修复XXX</span><br><span class="line"></span><br><span class="line">commit 2959f92753d84bff5b125b15cd9497c4d8dff637</span><br><span class="line">Author: shawn &lt;shawnbluce@gmail.com&gt;</span><br><span class="line">Date:   Sun Nov 12 16:09:07 2017 +0800</span><br><span class="line"></span><br><span class="line">    完成XXX功能</span><br><span class="line"></span><br><span class="line">这样一个commit就复制过来了。如果有冲突的话需要将冲突解决完才能合并。</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
            <tag> Shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用好Linux之：软件推荐]]></title>
      <url>/2017/09/29/use-linux-better/</url>
      <content type="html"><![CDATA[<h1 id="0X00-推荐一波Linux下的软件"><a href="#0X00-推荐一波Linux下的软件" class="headerlink" title="0X00 推荐一波Linux下的软件"></a>0X00 推荐一波Linux下的软件</h1><p>Linux对于普通用户可能确实没有那么友好，但是对于计算机“专业”人士来说就好多了。我从接触Linux到现在也有个三两年了，而且用Linux桌面也有一段时间了。这段时间里也发现了不少好用的软件和工具，在这里整理一下也向大家推荐一波。这些工具有些是用来提升工作效率的，有些是用来娱乐的等等。。不过每一个都是我离不开的好工具。<br>非常重要的一点是，我推荐的这些软件除了为知笔记以外都是 <strong>免费的</strong> ，而且还有一大半是 <strong>开源的</strong>。</p>
<h1 id="0X01-zsh"><a href="#0X01-zsh" class="headerlink" title="0X01 zsh"></a>0X01 zsh</h1><p>Linux真正效率高的地方就在于Terminal，那我们就需要选一个好用的SHELL。目前绝大多数Linux发行版本都默认使用Bash，这是一个非常好用非常成熟的SHELL。但是有一个更好用的Shell叫做zsh，可以从官网安装也可以直接<code>apt install zsh</code>就装上了。这个shell一定要配合着<code>oh-my-zsh</code>来使用。<a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a>可以让你的SHELL发挥最大的效率。</p>
<a id="more"></a>

<h1 id="0X02-vim"><a href="#0X02-vim" class="headerlink" title="0X02 vim"></a>0X02 vim</h1><p>vim 的好处就不多说了。在这里推荐一套开源的配置，在自己没有配置vim的情况下直接安装就好了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/vince67/v7_config/master/vim.sh</span><br><span class="line">bash vim.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个脚本官方只支持Mac和Debian系，如果是其他系需要自行修改一下这个脚本里的内容。<br>例如：如果是CentOS的话就将里面安装软件的<code>apt-get</code>修改成<code>yum</code>，安装就能顺利进行了。</p>
</blockquote>
<p>这个安装好了之后vim常用的插件和配置就都搞定了，默认情况下写Python就可以拥有非常好的用户体验。具体用法简单看一下<code>~/.vimrc</code>就可以了解到了。</p>
<h1 id="0X03-htop"><a href="#0X03-htop" class="headerlink" title="0X03 htop"></a>0X03 htop</h1><p>在Linux命令行中查看系统资源比如CPU、内存、进程等要用到<code>top、free</code>等命令，现在一个<code>htop</code>就解决了问题，而且是彩色输出还支持鼠标点击排序。<br><img src="https://raw.githubusercontent.com/shawn-bluce/shawn-bluce.github.io/enclosure/image/htop.png" alt="htop截图"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install htop</span><br><span class="line">sudo yum install htop</span><br></pre></td></tr></table></figure>


<h1 id="0X04-mycli"><a href="#0X04-mycli" class="headerlink" title="0X04 mycli"></a>0X04 mycli</h1><p>MySQL是我们常用的一款数据库了，有的时候需要连到数据库里查一些东西或是一些什么操作。通常我们会选用<code>mysql</code>命令来连接数据库，但是这个工具挺不好用的，所以才会出现了这么一款神器<code>mycli</code>。由于是用Python写的，还封装了pip，所以安装起来很简单，一条命令<code>pip install mycli</code>就搞定了。这个工具和<code>mysql</code>命令用法是完全一样的，他的特点就是支持自动补全和SQL高亮，而且输出默认是使用<code>less</code>展示的，可以直接用键盘上下滚动，不需要鼠标键盘乱换着用。<br><img src="https://raw.githubusercontent.com/shawn-bluce/shawn-bluce.github.io/enclosure/image/mycli.png" alt="mycli截图"></p>
<h1 id="0X05-WPS"><a href="#0X05-WPS" class="headerlink" title="0X05 WPS"></a>0X05 WPS</h1><p><a href="http://linux.wps.cn/">WPS</a>是在Linux下MS Office的最佳替代品了。虽然功能和易用性上不如MS Office，但是他免费，在Linux下没有广告，而且对MS Office的支持率还是很高的。通常只是写个简单的文档或者展示PPT什么的是没有问题的。不过WPS暂时还没有开源，倒是有一个开源的替代品LibreOffice，但是实在是不好用，有兴趣的同学可以加入LibreOffice的社区，帮助LibreOffice变得更好。<br>对了，WPS在Linux下的启动速度奇快，在我PCI-E Nvme的硬盘下每次都是秒开，比Office 2016要更快一筹。</p>
<h1 id="0X06-Chrome-Firefox"><a href="#0X06-Chrome-Firefox" class="headerlink" title="0X06 Chrome/Firefox"></a>0X06 Chrome/Firefox</h1><p>这俩就没的说了，我就介绍一下我正在用的几个Chrom扩展吧</p>
<ol>
<li>Adblock Plus 去广告神器</li>
<li>crxMouse Chrome Gestures  鼠标手势神器</li>
<li>Draw.io Desktop  一个在线画流程图的ChromAPP</li>
<li>Google翻译 可以设置为选中翻译，因为Google翻译没有被墙，所以很好用</li>
<li>LastPass 一款免费的密码管理扩展，安全可靠方便易用</li>
<li>Postman 一个用于快速模拟http请求的ChromeAPP</li>
<li>Proxy SwitchOmega  一个用于设置浏览器代理的扩展，配合SS使用感觉良好</li>
<li>Search by Image 以图搜图，开启后网页每张图右下角都会出现一个小Logo，点击Logo就可以用Google搜索这张图</li>
<li>Tamepermonkey 一个JS脚本管理器，神器</li>
<li><ol>
<li>AC-baidu  去百度广告</li>
</ol>
</li>
<li><ol start="2">
<li>百度广告清理 去百度广告可能需要两个才行</li>
</ol>
</li>
<li>Wappalyzer 开发者必备，可以显示出当前网页/网站所使用的技术和框架</li>
<li>Vimium 用vim快捷键来操作浏览器，神器</li>
</ol>
<h1 id="0X07-为知笔记-蚂蚁笔记"><a href="#0X07-为知笔记-蚂蚁笔记" class="headerlink" title="0X07 为知笔记/蚂蚁笔记"></a>0X07 为知笔记/蚂蚁笔记</h1><p>在我所知道的范围内，Linux环境下体验还不错的笔记软件就这两款。给大家列个表对比一下 <a href="http://www.wiz.cn/">为知笔记</a> 和 <a href="https://leanote.com/">蚂蚁笔记</a></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>为知笔记</th>
<th>蚂蚁笔记</th>
</tr>
</thead>
<tbody><tr>
<td>客户端开源</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>服务端开源</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>收费情况</td>
<td>免费体验100天，过后60一年</td>
<td>免费（不能同步）、50/年（支持同步，流量较少）、150/年（流量中等</td>
</tr>
<tr>
<td>一键变博客</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>移动端体验</td>
<td>好</td>
<td>较差</td>
</tr>
</tbody></table>
<p>总的来说，为知笔记每年要花60块钱，可以获得不错的使用体验；蚂蚁笔记每年要花150块钱才能获得不错的体验。不过由于蚂蚁笔记的服务端开源，所以可以将服务端部署在自己的服务器上以免费获得最完整的功能。主要就是看大家对哪点的需求更多了。</p>
<h1 id="0X08-网易云音乐"><a href="#0X08-网易云音乐" class="headerlink" title="0X08 网易云音乐"></a>0X08 网易云音乐</h1><p>网易云音乐就没必要过多介绍了。官方推出了deb包，几乎所有基于Debian的Linux都能一键安装。也有民间玩家制作了rpm包，没有用过不知道体验怎么样。还有民间高手在做的命令行版本的网易云音乐，功能已经相当完善了。目前有<a href="https://github.com/darknessomi/musicbox">Python版本</a>的和<a href="https://github.com/Binaryify/NeteaseCloudMusicApi">NodeJS版本</a>的，有兴趣的同学可以参与到开发过程中来。</p>
<h1 id="0X09-Atom-vscode"><a href="#0X09-Atom-vscode" class="headerlink" title="0X09 Atom/vscode"></a>0X09 Atom/vscode</h1><p>这两个应该是目前为止图形界面下最好用的两款开源编辑器了。<a href="https://atom.io/">Atom</a>是由Github制作的，<a href="https://code.visualstudio.com/">vscode</a>是由Microsoft制作的。一个是拥有全世界最厉害程序员的平台，一个是全世界最厉害的软件公司之一。自然软件的质量没的说了，我个人也只是轻度使用，所以主要是看外观和心里偏向而已。比如我就比较喜欢用Atom。</p>
<h1 id="0X0A-Nylas"><a href="#0X0A-Nylas" class="headerlink" title="0X0A Nylas"></a>0X0A Nylas</h1><p>目前为止Linux下最有名的两款邮件客户端应该是雷鸟和EVO了，不过前段时间出来的这款<a href="https://www.nylas.com/nylas-mail/">Nylas</a>特好用，我一直在用。最重要的一点是可以不用梯子就访问Gmail。不过目前遇到的唯一一个坑就是连接QQ企业邮箱的时候有问题，每次都会报错，但是又能收到信，很奇怪。给社区反馈过，也没得到答复。然而我还是强烈推荐这款软件，真的是好用。</p>
<h1 id="0X0B-Guake"><a href="#0X0B-Guake" class="headerlink" title="0X0B Guake"></a>0X0B Guake</h1><p>这个名字对于大学生来说非常不友好，也不知道怎么这么好的软件怎么就取了个”挂科”的名字呢，哈哈。我们在用Linux的时候偶尔会需要输入一两行命令，或者是需要用htop长期看着自己的性能指标。那这时候每次都打开一个终端再输命令吗？当然不用。装一个<code>Guake</code>，给他设定一个快捷键，每次需要临时调出终端的时候只需要按一下快捷键，终端就会从屏幕顶部弹下来，还能设置失去焦点自动隐藏。这样用起来就很舒服了。</p>
<h1 id="0X0C-Virtualbox"><a href="#0X0C-Virtualbox" class="headerlink" title="0X0C Virtualbox"></a>0X0C Virtualbox</h1><p>这款软件想必也不需要介绍，是目前免费桌面虚拟机软件中最好的一款了。大量人在用破解的VMwareWorkstadion，虽然比VirtualBox好用一点，但是我们还是应该按版权来，不想花钱就用VirtualBox吧，况且也挺好用的。比如你在长期用Linux的环境下偶尔也需要用一下Windows，比如你长期用Fedora偶尔也要用一下Ubuntu，这就是<a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>出场的时候了。</p>
<h1 id="0X0D-TeamViewer"><a href="#0X0D-TeamViewer" class="headerlink" title="0X0D TeamViewer"></a>0X0D TeamViewer</h1><p>平时在Windows下大家都用习惯了QQ的远程协助，那么到了Linux下应该怎么办呢？<a href="https://www.teamviewer.com/zh/">Teamviewer</a>应该就是最好的选择了。其实Teamviewer在性能上是要比QQ的远程协助更强的。注意一点：这款软件对个人免费，但是要在公司里用的话是要花钱买的。</p>
<h1 id="0X0E-深度终端"><a href="#0X0E-深度终端" class="headerlink" title="0X0E 深度终端"></a>0X0E 深度终端</h1><p><a href="https://www.deepin.org/2016/09/22/deepin-terminal-v2-0-released-all-can-be-done-in-terminal/">深度终端</a>是我目前在Linux里用过最好用的终端模拟器了。自带的主题很漂亮，对中文支持完美，而且还集成了SSH管理功能。</p>
<h1 id="0X0F-Shadowsocks-QT"><a href="#0X0F-Shadowsocks-QT" class="headerlink" title="0X0F Shadowsocks-QT"></a>0X0F Shadowsocks-QT</h1><p>翻越长城必备神器 <a href="https://github.com/shadowsocks/shadowsocks-qt5">Shadowsocks-QT</a>。目前为止这东西是最好用的，但是不能像Windows和Mac中的那样直接支持PAC，需要浏览器的扩展来配合实现PAC功能。</p>
<h1 id="0X10-Jetbrains"><a href="#0X10-Jetbrains" class="headerlink" title="0X10 Jetbrains"></a>0X10 Jetbrains</h1><p><a href="https://www.jetbrains.com/">Jetbrains</a>他们的产品简直是厉害，如果是学生的话可以去申请全部软件的专业版。我用过的有WebStorm/PyCharm/IntellJ IDEA/DataGrip/Android Studio这五款，其中AndroidStudio免费，PyCharm和IDEA提供社区版。他们的软件最大的特点就是统一性强，你用过其中一款之后再去用其他的很快就能上手。而且都非常智能，这才是IDE应该有的样子。</p>
<h1 id="0X11-Audacious"><a href="#0X11-Audacious" class="headerlink" title="0X11 Audacious"></a>0X11 Audacious</h1><p>如果你有把音乐下载到本地再听的习惯，那么这款软件就特别适合。这款软件特别小，界面简洁，使用简单。是我用过Linux下最好用的离线播放器了。</p>
<h1 id="0X12-Wireshark"><a href="#0X12-Wireshark" class="headerlink" title="0X12 Wireshark"></a>0X12 Wireshark</h1><p>一款可以用来分析网络流量包的软件，可以在官网下载最新的也可以在包管理中安装使用。这应该是开发者必备的工具之一了吧，有的时候为了分析一波流量或者看看自己的请求到底是不是有问题等等。。。当然，如果是大黑客的话还能有更炫酷的应用场景。</p>
<h1 id="0X13-Dia"><a href="#0X13-Dia" class="headerlink" title="0X13 Dia"></a>0X13 Dia</h1><p>一款用来画图的开源软件，可以简单的画出流程图，数据库模型等等。。使用体验还是不错，如果只是轻度使用的话足够了。</p>
<h1 id="0X14-Stellarium"><a href="#0X14-Stellarium" class="headerlink" title="0X14 Stellarium"></a>0X14 Stellarium</h1><p>如果你是一个理科生甚至以为天文爱好者，那你一定对宇宙的浩瀚很痴迷。这款软件能实时模拟星空的运动轨迹，还有各种行星、恒星的数据，官方中文。很值得一玩</p>
<h1 id="0X015-VLC"><a href="#0X015-VLC" class="headerlink" title="0X015 VLC"></a>0X015 VLC</h1><p>应该是世界上最厉害的视频播放器之一了，毕竟是开源软件所以自定义程度非常强悍。是我在Linux中用过最好的视频播放器。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
            <tag> MySQL </tag>
            
            <tag> Shadowsocks </tag>
            
            <tag> Software </tag>
            
            <tag> Tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python使用virtualenvwapper管理虚拟环境]]></title>
      <url>/2017/09/20/python-virtualenvwapper/</url>
      <content type="html"><![CDATA[<h1 id="0X00-virtualenv好用但有瓶颈"><a href="#0X00-virtualenv好用但有瓶颈" class="headerlink" title="0X00 virtualenv好用但有瓶颈"></a>0X00 virtualenv好用但有瓶颈</h1><p>virtualenv固然好用，可以给你每一个Python项目创建一个独立的Python环境互不干扰。有三五个Python项目的时候用的很开心，有十几个项目的时候还凑合，如果有更多的项目virtualenv就会出现瓶颈。因为virtualenv会给每一个Python虚拟环境创建一个目录来保存相关文件，项目一多这个虚拟环境的目录也就多了起来，每次在多个环境之间<code>source ../../../xxx/bin/active</code> 和 <code>deactive</code> 也挺烦的，并且很容易把某些环境搞丢。不过开源世界最不缺的就是解决问题的方法了，既然有人遇到了这个问题，那么八成就已经有了解决这个问题的好办法。</p>
<h1 id="0X01-virtualenvwrapper"><a href="#0X01-virtualenvwrapper" class="headerlink" title="0X01 virtualenvwrapper"></a>0X01 virtualenvwrapper</h1><p>这个东西名字确实有点长，顾名思义就是把virtualenv包装起来。首先来安装一波这个东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install virtualenvwrapper  # Debian系</span><br><span class="line"></span><br><span class="line">sudo yum install virtualenvwrapper  # RHEL系</span><br></pre></td></tr></table></figure>
<p>安装好后要进行简单的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bashrc # 添加一条环境变量，可以根据自己用的shell来修改</span><br></pre></td></tr></table></figure>
<p>向文件中添加 <code>WORKON_HOME=~/Envs</code> 表示将未来所有的虚拟环境都放在 <code>~/Envs</code> 中。然后创建这个目录 <code>mkdir -p $WORKON_HOME</code> 。最后<code>source</code>一下安装文件，<code>source /usr/bin/virtualenvwrapper.sh</code> 会显示创建了很多文件，到这里就安装完成了。<br>如果<code>source</code>的时候没有这个<code>virtualenvwrapper.sh</code>文件，那就用<code>which virtualenvwrapper.sh</code>找一下，不过八成都是在<code>/usr/bin/virtualenvwrapper.sh</code></p>
<a id="more"></a>

<h1 id="0X02-把它用起来"><a href="#0X02-把它用起来" class="headerlink" title="0X02 把它用起来"></a>0X02 把它用起来</h1><p>以前用<code>virtualenv</code>的时候要每次<code>source xxx/bin/active</code>，用完了再<code>deactive</code>，这次就方便多了。下面列出几个常用命令。</p>
<p>| 命令 | 功能 |<br>| – |<br>| mkvirtualenv blog | 创建一个名为blog的虚拟环境，并切换过去 |<br>| workon blog | 切换到名为blog的虚拟环境中 |<br>| workon | 列出当前所有的虚拟环境 |<br>| rmvirtualenv blog | 删除名为blog的虚拟环境 |<br>| deactive | 退出当前所处的虚拟环境 |</p>
<p>下面演示一下这个用法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的虚拟环境，名为blog</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkvirtualenv blog</span></span><br><span class="line">New python executable <span class="keyword">in</span> blog/bin/python</span><br><span class="line">Installing Setuptools..............................................................................................................................................................................................................................done.</span><br><span class="line">Installing Pip.....................................................................................................................................................................................................................................................................................................................................done.</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/blog/bin/predeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/blog/bin/postdeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/blog/bin/preactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/blog/bin/postactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/blog/bin/get_env_details</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的虚拟环境，名为student_admin</span></span><br><span class="line">(blog)[root@localhost ~]<span class="comment"># mkvirtualenv student_admin</span></span><br><span class="line">New python executable <span class="keyword">in</span> student_admin/bin/python</span><br><span class="line">Installing Setuptools..............................................................................................................................................................................................................................done.</span><br><span class="line">Installing Pip.....................................................................................................................................................................................................................................................................................................................................done.</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/student_admin/bin/predeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/student_admin/bin/postdeactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/student_admin/bin/preactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/student_admin/bin/postactivate</span><br><span class="line">virtualenvwrapper.user_scripts creating /root/Envs/student_admin/bin/get_env_details</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有的虚拟环境</span></span><br><span class="line">(student_admin)[root@localhost ~]<span class="comment"># workon</span></span><br><span class="line">blog</span><br><span class="line">student_admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到blog环境</span></span><br><span class="line">(student_admin)[root@localhost ~]<span class="comment"># workon blog</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除student_admin环境</span></span><br><span class="line">(blog)[root@localhost ~]<span class="comment"># rmvirtualenv student_admin</span></span><br><span class="line">Removing student_admin...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再看一下所有环境，student_admin已经不在了</span></span><br><span class="line">(blog)[root@localhost ~]<span class="comment"># workon</span></span><br><span class="line">blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出当前环境</span></span><br><span class="line">(blog)[root@localhost ~]<span class="comment"># deactivate</span></span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>`` ````</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Virtualenvwapper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中的*args和**kwargs]]></title>
      <url>/2017/09/05/python-args-kwargs/</url>
      <content type="html"><![CDATA[<h1 id="0X00-args是什么"><a href="#0X00-args是什么" class="headerlink" title="0X00 *args是什么"></a>0X00 *args是什么</h1><p>我们知道Python3中的print从一个关键字变成了一个函数，那么调用的时候我们可以这样调用这个函数，可以随便接受几个参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">6.66</span>)</span><br><span class="line"><span class="number">1</span> hello <span class="number">6.66</span></span><br></pre></td></tr></table></figure>
<p>那么如果我们想自己实现类似这样‘变态’的函数该怎么实现呢？这就需要用到*args了，可以将一个非键值对的可变数量的参数列表传给一个函数（换个书佛啊：可以传n个参数给函数，而且n不是固定的），举个例子就容易理解多了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_something</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">print</span> i</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;--------&#x27;</span></span><br><span class="line"></span><br><span class="line">say_something(<span class="number">1</span>)</span><br><span class="line">say_something(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">say_something(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">say_something(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行这个例子的输出就是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">--------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">--------</span><br><span class="line">hello</span><br><span class="line">--------</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">--------</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>还有一个更棒的例子<a href="https://eastlakeside.gitbooks.io/interpy-zh/content/args_kwargs/Usage_args.html">来自Gitbook</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_var_args</span>(<span class="params">f_arg, *args</span>):</span></span><br><span class="line">    print(<span class="string">&quot;first normal arg:&quot;</span>, f_arg)</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        print(<span class="string">&quot;another arg through *args:&quot;</span>, arg)</span><br><span class="line"></span><br><span class="line">test_var_args(<span class="string">&#x27;yasoob&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;first normal arg:&#x27;</span>, <span class="string">&#x27;yasoob&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;another arg through *args:&#x27;</span>, <span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;another arg through *args:&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;another arg through *args:&#x27;</span>, <span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子完整的说明了<code>\*args</code>的用法，我们传入的第一个参数被函数指定的<code>f_arg</code>接收到了，其余的都被<code>*args</code>接收到了。</p>
<h1 id="0X01-kwargs是什么"><a href="#0X01-kwargs是什么" class="headerlink" title="0X01 **kwargs是什么"></a>0X01 **kwargs是什么</h1><p>写代码的时候还会有一种函数调用，大概是这个样子<code>json.dumps(dict_data)</code>和<code>json.dumps(dict_data, indent=4)</code>。当然，实现这种的方式有一个最简单的方案就是<code>def dumps(input_data, indent=0)</code>。在可选参数只有一两个的时候这种方式固然是好用的，但是如果像是requests这种库中的常用方法，有很多很多个可选参数那就该用上这个**kwargs了。顾名思义这个就是<code>keyworkargs</code>的意思，也就是说是带有key的可变参数。可以这样定义一个函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="keyword">print</span> key</span><br><span class="line">        <span class="keyword">print</span> kwargs[key]</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;-----&#x27;</span></span><br><span class="line"></span><br><span class="line">foo(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>, e=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>运行出来的结果可想而知：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">1</span><br><span class="line">-----</span><br><span class="line">c</span><br><span class="line">3</span><br><span class="line">-----</span><br><span class="line">b</span><br><span class="line">2</span><br><span class="line">-----</span><br><span class="line">e</span><br><span class="line">5</span><br><span class="line">-----</span><br><span class="line">d</span><br><span class="line">4</span><br><span class="line">-----</span><br></pre></td></tr></table></figure>

<h1 id="0X02-合在一起怎么用"><a href="#0X02-合在一起怎么用" class="headerlink" title="0X02 合在一起怎么用"></a>0X02 合在一起怎么用</h1><p>值得一提的是如何把这两个放在一起用，这里列举个例子来演示一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">name, sex, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;name is &#x27;</span>, name</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;sex is &#x27;</span>, sex</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;other is &#x27;</span>, args</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> kwargs:</span><br><span class="line">        <span class="keyword">print</span> key, <span class="string">&#x27; is &#x27;</span>, kwargs[key]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;args is &#x27;</span>, args</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;kwargs is &#x27;</span>, kwargs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo(<span class="string">&#x27;shawn&#x27;</span>, <span class="string">&#x27;???&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, hobby=<span class="string">&#x27;computer&#x27;</span>, number=<span class="number">666</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;--------------------------&#x27;</span></span><br><span class="line">bar(<span class="string">&#x27;shawn&#x27;</span>, <span class="string">&#x27;???&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, hobby=<span class="string">&#x27;computer&#x27;</span>, number=<span class="number">666</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name is  shawn</span><br><span class="line">sex is  ???</span><br><span class="line">other is  (<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">hobby  is  computer</span><br><span class="line">number  is  666</span><br><span class="line">--------------------------</span><br><span class="line">args is  (<span class="string">&#x27;shawn&#x27;</span>, <span class="string">&#x27;???&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">kwargs is  &#123;<span class="string">&#x27;hobby&#x27;</span>: <span class="string">&#x27;computer&#x27;</span>, <span class="string">&#x27;number&#x27;</span>: 666&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里有需要注意的一点：参数的名字不一定非要是<code>*args</code>和<code>**kwargs</code>，所以我们定义函数的时候不一定是<code>def foo(*args, **kwargs):</code>，也同样可以定义成<code>def bar(*hehe, **haha):</code>，这里真正标识的是星号而不是名字。不过建议命名的时候符合大家的习惯。</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Paramenter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中Virtualenv和pip的简单用法]]></title>
      <url>/2017/08/18/python-pip-virtualenv/</url>
      <content type="html"><![CDATA[<h1 id="0X00-安装环境"><a href="#0X00-安装环境" class="headerlink" title="0X00 安装环境"></a>0X00 安装环境</h1><p>我们在Python开发和学习过程中需要用到各种库，然后在各个不同的项目和作品里可能用的版本还不一样，正因为有这种问题的存在才催生了<code>virtualenv</code>的诞生。virtualenv可以在电脑上创建一个虚拟环境，可以针对每一个项目创建一个虚拟环境，这样就不用担心各个不同的项目用不同版本的库的时候出现的冲突了。 ** 下面的内容只适用于Linux/OSX，未经Windows环境测试 **</p>
<p>要使用这个功能还是需要安装，安装virtualenv肯定就得直接用pip安装了，<code>pip install virtualenv</code>就可以轻松装上了。装好之后我们就可以来测试一波了。</p>
<a id="more"></a>

<h1 id="0X01-初始化一个空的工作环境"><a href="#0X01-初始化一个空的工作环境" class="headerlink" title="0X01 初始化一个空的工作环境"></a>0X01 初始化一个空的工作环境</h1><p>首先在一个空的环境中执行<code>virtualenv --no-site-packages test_env</code>，就是在当前目录创建一个名为test_env的虚拟环境。这里<code>--no-site-packages</code>参数是指不从全局的Python中携带任何第三方库。就比如说你在全局Python中安装了xxx库，在不用这个参数来创建虚拟环境时，虚拟环境中也会带着这个库；但是加上了这个参数，虚拟环境中就是一个纯净的Python，没有这些库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root <span class="keyword">in</span> ~ λ virtualenv --no-site-packages test_env</span><br><span class="line">New python executable <span class="keyword">in</span> /root/test_env/bin/python</span><br><span class="line">Please make sure you remove any previous custom paths from your /root/.pydistutils.cfg file.</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure>
<p>然后可以通过<code>source test_env/bin/activate</code>可以进入（激活）到这个虚拟环境里去。进入到虚拟环境中之后，通常情况下你的命令提示符最前面会出现一个括号，括号里面写着你虚拟环境的名字。</p>
<blockquote>
<p>这里说是虚拟环境，其实一切都是真实的。只是说你在激活了这个环境，在这个环境下用pip安装的库都放在 <code>test_env</code> 中。</p>
</blockquote>
<p>也可以通过<code>deactivate</code>来退出这个环境。</p>
<h1 id="0X02-批量导出和安装库"><a href="#0X02-批量导出和安装库" class="headerlink" title="0X02 批量导出和安装库"></a>0X02 批量导出和安装库</h1><p>比如我们开发了一个项目，里面用到了pymongo/requests/flask/pymysql等等等等十几二十个库，还要指定特定的版本，那么当把一个项目从机器A迁移到机器B的时候就会很麻烦。需要手动记录每个库和版本，还要逐个去安装，非常麻烦。所以针对这个问题pip已经有了非常完善的解决方案。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(test_env) root <span class="keyword">in</span> ~ λ pip freeze &gt; requirements.txt  <span class="comment"># 导出已安装的库</span></span><br></pre></td></tr></table></figure>
<p>这个命令可以导出当前环境中安装好的所有第三方库，并且是以一个标准的格式导出的。所以一般一个标准的python项目的根目录都会有这个名为<code>requirements.txt</code>的依赖文件。</p>
<p>既然可以一次性导出，那么必然可以一次性安装喽。通过这种方式就可以将上面导出的特定版本的所有库一次性全装上。配合virtualenv可以快速的部署一个Python项目，并且不会搞乱其他的Python项目环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(test_env_1) root <span class="keyword">in</span> ~ λ pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> pip </tag>
            
            <tag> Virtualenv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Python操作消息队列RabbitMQ]]></title>
      <url>/2017/06/13/python-rabbitmq/</url>
      <content type="html"><![CDATA[<p>内容参考自<a href="http://www.cnblogs.com/pangguoping/p/5720134.html">python - 操作RabbitMQ</a></p>
<h1 id="0X00-安装环境"><a href="#0X00-安装环境" class="headerlink" title="0X00 安装环境"></a>0X00 安装环境</h1><p>首先是在Linux上安装rabbitmq</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境为CentOS 7</span></span><br><span class="line">yum install rabbitmq-server	<span class="comment"># 安装RabbitMQ</span></span><br><span class="line">systemctl start rabbitmq-server	<span class="comment"># 启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rabbitmq-server	<span class="comment"># 开机自启</span></span><br><span class="line">systemctl stop firewall-cmd		<span class="comment"># 临时关闭防火墙</span></span><br></pre></td></tr></table></figure>

<p>然后用pip安装Python3的开发包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pika</span><br></pre></td></tr></table></figure>

<p>安装好软件之后可以访问<code>http://115.xx.xx.xx:15672/</code>来访问自带的web页面来查看和管理RabbitMQ。默认管理员的用户密码都是<code>guest</code></p>
<a id="more"></a>

<h1 id="0X01-简单的向队列中加入消息"><a href="#0X01-简单的向队列中加入消息" class="headerlink" title="0X01 简单的向队列中加入消息"></a>0X01 简单的向队列中加入消息</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># @Time    : 2017/6/13 19:25</span></span><br><span class="line"><span class="comment"># @Author  : Shawn</span></span><br><span class="line"><span class="comment"># @Blog    : https://blog.just666.cn</span></span><br><span class="line"><span class="comment"># @Email   : shawnbluce@gmail.com</span></span><br><span class="line"><span class="comment"># @purpose : RabbitMQ_Producer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;115.xx.xx.xx&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建频道对象</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一个队列，如果该队列不存在则创建</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;test_queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交消息</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=<span class="string">&#x27;test_queue&#x27;</span>, body=<span class="string">&#x27;hello,world&#x27;</span> + str(i))</span><br><span class="line">    print(<span class="string">&quot;sent...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<h1 id="0X02-简单的从队列中获取消息"><a href="#0X02-简单的从队列中获取消息" class="headerlink" title="0X02 简单的从队列中获取消息"></a>0X02 简单的从队列中获取消息</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># @Time    : 2017/6/13 19:40</span></span><br><span class="line"><span class="comment"># @Author  : Shawn</span></span><br><span class="line"><span class="comment"># @Blog    : https://blog.just666.cn</span></span><br><span class="line"><span class="comment"># @Email   : shawnbluce@gmail.com</span></span><br><span class="line"><span class="comment"># @purpose : RabbitMQ_Consumer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到RabbitMQ服务器</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;115.xx.xx.xx&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;/&#x27;</span>, credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一个队列，如果该队列不存在则创建</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">&#x27;test_queue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ch, method, properties, body</span>):</span></span><br><span class="line">    print(body.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 告诉RabbitMQ使用callback来接收信息</span></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">&#x27;test_queue&#x27;</span>, no_ack=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;waiting...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始接收信息，并进入阻塞状态，队列里有信息才会调用callback进行处理。按ctrl+c退出。</span></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h1 id="0X03-万一消费者掉线了"><a href="#0X03-万一消费者掉线了" class="headerlink" title="0X03 万一消费者掉线了"></a>0X03 万一消费者掉线了</h1><p>想象这样一种情况：</p>
<p>消费者从消息队列中获取了n条数据，正要处理呢结果宕机了，那该怎么办？在RabbieMQ中有一个ACK可以用来确认消费者处理结束。就有点类似网络中的ACK，消费者每次从队列中获取了数据之后队列不会立刻将数据移除，而是等待对应的ACK。消费者获取到数据并处理完成之后会向队列发送一个ACK包，通知RabbitMQ这堆消息已经处理妥当了，可以删除了，这时候RabbitMQ才会将数据从队列中移除。所以这种情况下即使消费者掉线也没有什么问题，数据依旧会在队列中存在，留给其他消费者处理。</p>
<p>在Python中这样实现：</p>
<p>消费者有这样一行代码<code>channel.basic_consume(callback, queue=&#39;test_queue&#39;, no_ack=False)</code>，其中<code>no_ack=False</code>表示不发送确认包。将其修改为<code>no_ack=True</code>就会在每次处理完之后向RabbitMQ发送一个确认包，以确认消息处理完毕。</p>
<h1 id="0X04-万一RabbitMQ宕机了呢"><a href="#0X04-万一RabbitMQ宕机了呢" class="headerlink" title="0X04 万一RabbitMQ宕机了呢"></a>0X04 万一RabbitMQ宕机了呢</h1><p>虽然有了ACK包，但是万一RabbitMQ挂了那数据还是会损失。所以我们可以给RabbitMQ设置一个数据持久化存储。RabbitMQ会将数据持久化存储到磁盘上，保证下次再启动的时候队列还在。</p>
<p>在Python中这样实现：</p>
<p>我们声明一个队列是这样的<code>channel.queue_declare(queue=&#39;test_queue&#39;)</code>，如果需要持久化一个队列可以这样声明<code>channel.queue_declare(queue=&#39;test_queue&#39;, durable=True)</code>。不过这行直接放在代码中是不能执行的，因为以前已经有了一个名为<code>test_queue</code>的队列，RabbitMQ不允许用不同的方式声明同一个队列，所以可以换一个队列名新建来指定数据持久化存储。不过如果只是这样声明的话，在RabbitMQ宕机重启后确实队列还在，不过队列里的数据就没有了。除非我们这样来声明队列<code>channel.basic_publish(exchange=&#39;&#39;, routing_key=&quot;test_queue&quot;, body=message, properties=pika.BasicProperties(delivery_mode = 2,))</code>。</p>
<h1 id="0X05-最简单的发布订阅"><a href="#0X05-最简单的发布订阅" class="headerlink" title="0X05 最简单的发布订阅"></a>0X05 最简单的发布订阅</h1><p>最简单的发布订阅在RabbitMQ中称之为<code>Fanout模式</code>。也就是说订阅者订阅某个频道，然后发布者向这个频道中发布消息，所有订阅者就都能接收到这条消息。不过因为发布者需要使用订阅者创建的随机队列所以需要先启动订阅者才能启动发布者。</p>
<p>发布者代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># @Time    : 2017/6/13 20:21</span></span><br><span class="line"><span class="comment"># @Author  : Shawn</span></span><br><span class="line"><span class="comment"># @Blog    : https://blog.just666.cn</span></span><br><span class="line"><span class="comment"># @Email   : shawnbluce@gmail.com</span></span><br><span class="line"><span class="comment"># @purpose : RabbitMQ_Publisher</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">&#x27;115.xx.xx.xx&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建频道对象</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义交换机，exchange表示交换机名称，type表示类型</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;my_fanout&#x27;</span>,</span><br><span class="line">                         type=<span class="string">&#x27;fanout&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&#x27;Hello Python&#x27;</span></span><br><span class="line"><span class="comment"># 将消息发送到交换机</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;my_fanout&#x27;</span>,  <span class="comment"># 指定exchange</span></span><br><span class="line">                      routing_key=<span class="string">&#x27;&#x27;</span>,  <span class="comment"># fanout下不需要配置，配置了也不会生效</span></span><br><span class="line">                      body=message)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<p>订阅者代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># @Time    : 2017/6/13 20:20</span></span><br><span class="line"><span class="comment"># @Author  : Shawn</span></span><br><span class="line"><span class="comment"># @Blog    : https://blog.just666.cn</span></span><br><span class="line"><span class="comment"># @Email   : shawnbluce@gmail.com</span></span><br><span class="line"><span class="comment"># @purpose : RabbitMQ_Subscriber</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到RabbitMQ</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;115.xx.xx.xx&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;/&#x27;</span>, credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义交换机，进行exchange声明，exchange表示交换机名称，type表示类型</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">&#x27;my_fanout&#x27;</span>,</span><br><span class="line">                         type=<span class="string">&#x27;fanout&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机创建队列</span></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)  <span class="comment"># exclusive=True表示建立临时队列，当consumer关闭后，该队列就会被删除</span></span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将队列与exchange进行绑定</span></span><br><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;my_fanout&#x27;</span>,</span><br><span class="line">                   queue=queue_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ch, method, properties, body</span>):</span></span><br><span class="line">    print(body.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列获取信息</span></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue=queue_name,</span><br><span class="line">                      no_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Demo </tag>
            
            <tag> RabbieMQ </tag>
            
            <tag> Message Queue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Flask设计实现一套API【成绩管理系统】]]></title>
      <url>/2017/06/03/flask-build-api/</url>
      <content type="html"><![CDATA[<h1 id="0X00-什么是REST风格的API"><a href="#0X00-什么是REST风格的API" class="headerlink" title="0X00 什么是REST风格的API"></a>0X00 什么是REST风格的API</h1><p>众所周知http协议有<code>GET/PUT/POST/PATCH/DELETE</code>等众多方法，还能在提交请求和发送响应的时候携带数据。REST风格的API就是使用了这些HTTP特性的API。针对一个URL可以有多种动词(方法)来表示不同的操作。<br>更多详细的内容可以点击查看阮一峰的博客：<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a></p>
<a id="more"></a>

<h1 id="0X01-怎么选用HTTP动词"><a href="#0X01-怎么选用HTTP动词" class="headerlink" title="0X01 怎么选用HTTP动词"></a>0X01 怎么选用HTTP动词</h1><p>常见的动词有这五种，可以对应自己的需求选用</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>类似的SQL关键字</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>SELECT</td>
<td>获取资源</td>
</tr>
<tr>
<td>POST</td>
<td>CREATE</td>
<td>创建资源</td>
</tr>
<tr>
<td>PUT</td>
<td>UPDATE</td>
<td>更新资源（需要提供改变后的完整资源）</td>
</tr>
<tr>
<td>PATCH</td>
<td>UPDATE</td>
<td>更新资源（需要提供改变的属性）</td>
</tr>
<tr>
<td>DELETE</td>
<td>DELETE</td>
<td>删除资源</td>
</tr>
</tbody></table>
<h1 id="0X02-设计URL"><a href="#0X02-设计URL" class="headerlink" title="0X02 设计URL"></a>0X02 设计URL</h1><p>REST风格的API因为可以用HTTP的动词，所以URL中是不带有动词的，如果我要获取某个学生的信息应该是<code>[GET] http://api.example.com/student/id=12345678900</code>。HTTP动词理论上是能满足各种情况下的需求的，所以URL中只应该出现名词而不应该出现动词。这里用阮一峰举的例子来说明一下</p>
<p>| 动词 | 路径 | 功能 |<br>| –|— |<br>| GET | /zoos | 列出所有动物园 |<br>| POST | /zoos | 新建一个动物园 |<br>| GET | /zoos/ID | 获取某个指定动物园的信息 |<br>| PUT | /zoos/ID | 更新某个指定动物园的信息（提供该动物园的全部信息） |<br>| PATCH | /zoos/ID | 更新某个指定动物园的信息（提供该动物园的部分信息） |<br>| DELETE | /zoos/ID | 删除某个动物园 |<br>| GET | /zoos/ID/animals | 列出某个指定动物园的所有动物 |<br>| DELETE | /zoos/ID/animals/ID | 删除某个指定动物园的指定动物 |</p>
<h1 id="0X03-状态码"><a href="#0X03-状态码" class="headerlink" title="0X03 状态码"></a>0X03 状态码</h1><p>状态码是HTTP中的一大优势，一个响应可以只靠状态码来判请求结果。这些是常见的状态码，自己设计API的时候要严格按照规范来设计状态码，可以提高代码和API的可读性和可理解性。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>信息</th>
<th>请求类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>[GET]</td>
<td>服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</td>
</tr>
<tr>
<td>201</td>
<td>CREATED</td>
<td>[POST/PUT/PATCH]</td>
<td>用户新建或修改数据成功。</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>[*]</td>
<td>表示一个请求已经进入后台排队（异步任务）。</td>
</tr>
<tr>
<td>204</td>
<td>NO CONTENT</td>
<td>[DELETE]</td>
<td>用户删除数据成功。</td>
</tr>
<tr>
<td>400</td>
<td>INVALID REQUEST</td>
<td>[POST/PUT/PATCH]</td>
<td>用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>[*]</td>
<td>表示用户没有权限（令牌、用户名、密码错误）。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>[*]</td>
<td>表示用户得到授权（与401错误相对），但是访问是被禁止的。</td>
</tr>
<tr>
<td>404</td>
<td>NOT FOUND</td>
<td>[*]</td>
<td>用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>[GET]</td>
<td>用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>[GET]</td>
<td>用户请求的资源被永久删除，且不会再得到的。</td>
</tr>
<tr>
<td>422</td>
<td>Unprocesable entity</td>
<td>[POST/PUT/PATCH]</td>
<td>当创建一个对象时，发生一个验证错误。</td>
</tr>
<tr>
<td>500</td>
<td>INTERNAL SERVER ERROR</td>
<td>[*]</td>
<td>服务器发生错误，用户将无法判断发出的请求是否成功。</td>
</tr>
</tbody></table>
<h1 id="0X04-如何用Python实现"><a href="#0X04-如何用Python实现" class="headerlink" title="0X04 如何用Python实现"></a>0X04 如何用Python实现</h1><p>Python有大量第三方库可以实现REST风格的API，我这里选用的是相对轻量化的一个 <a href="http://flask.pocoo.org/">Flask</a>。安装这个库最简单的方式还是用pip，根据环境变量的不同可能具体命令有所不同，在我的Linux上是用<code>pip3 install flask</code>就可以直接安装好的。<br>安装好后进入Python的交互式界面输入<code>import flask</code>如果没有出现<code>Import Error</code>就是安装好了。</p>
<h1 id="0X05创建数据库和表"><a href="#0X05创建数据库和表" class="headerlink" title="0X05创建数据库和表"></a>0X05创建数据库和表</h1><p>现在可以开始设计API了。既然是成绩管理系统，那么首先就要创建一个数据库，我这里的数据库是用的MariaDB。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>类型</th>
<th>含义</th>
<th>键</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>编号</td>
<td>主键</td>
</tr>
<tr>
<td>name</td>
<td>varchar(10)</td>
<td>学生姓名</td>
<td></td>
</tr>
<tr>
<td>number</td>
<td>char(11)</td>
<td>学号</td>
<td></td>
</tr>
<tr>
<td>python</td>
<td>float</td>
<td>Py成绩</td>
<td></td>
</tr>
<tr>
<td>cpp</td>
<td>float</td>
<td>c++成绩</td>
<td></td>
</tr>
<tr>
<td>os</td>
<td>float</td>
<td>操作系统成绩</td>
<td></td>
</tr>
<tr>
<td>network</td>
<td>float</td>
<td>计算机网络成绩</td>
<td></td>
</tr>
<tr>
<td>total</td>
<td>float</td>
<td>总分</td>
<td></td>
</tr>
<tr>
<td>ave</td>
<td>float</td>
<td>平均分</td>
<td></td>
</tr>
</tbody></table>
<h1 id="0X06-创建Py脚本"><a href="#0X06-创建Py脚本" class="headerlink" title="0X06 创建Py脚本"></a>0X06 创建Py脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从这里指定路径、方法、返回数据</span></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;hello,world&lt;/h1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> app.test_request_context():</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>这段代码写好之后运行起来会在本地监听5000端口(默认的)，然后当你用浏览器访问<code>http://localhost:5000/</code>的时候就像你返回<code>&lt;h1&gt;hello,world&lt;/h1&gt;</code>，在浏览器页面下看到的就是一行大号的hello,world。因为在浏览器的地址栏输入URL按回车之后就是向那个URL发送了GET请求，也就正好调用了<code>index()</code>方法。</p>
<p>这里先将与API无关的代码填好，下面开始正式完成各项功能。其实也就是连接了数据库而已</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">database = pymysql.connect(<span class="string">&quot;db_host&quot;</span>, <span class="string">&quot;db_username&quot;</span>, <span class="string">&quot;db_password&quot;</span>, <span class="string">&quot;db_name&quot;</span>)</span><br><span class="line">cursor = database.cursor()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;hello,world&lt;/h1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> app.test_request_context():</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<h1 id="0X07-实现一个构造返回Json数据的方法"><a href="#0X07-实现一个构造返回Json数据的方法" class="headerlink" title="0X07 实现一个构造返回Json数据的方法"></a>0X07 实现一个构造返回Json数据的方法</h1><p>首先我们选择使用Json来作为数据传输格式，因为Json相对XML来说更轻量一点，现在也更流行。规定客户端每次请求会后服务器都会返回下面这样类型的Json数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;time&quot;</span>: <span class="string">&quot;unix_time&quot;</span>,</span><br><span class="line">    “e_msg&quot;: &quot;error_message&quot;,</span><br><span class="line">    &quot;search_list&quot;: &#123;</span><br><span class="line">    	&quot;item0&quot;: &#123;</span><br><span class="line">        	&quot;name&quot;: &quot;name&quot;,</span><br><span class="line">            &quot;number&quot;: &quot;number&quot;,</span><br><span class="line">            &quot;python&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;network&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;cpp&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;total&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;ave&quot;: &quot;ave&quot;</span><br><span class="line">        &#125;,&quot;item1&quot; : &#123;</span><br><span class="line">        	&quot;name&quot;: &quot;name&quot;,</span><br><span class="line">            &quot;number&quot;: &quot;number&quot;,</span><br><span class="line">            &quot;python&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;network&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;cpp&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;total&quot;: &quot;marks&quot;,</span><br><span class="line">            &quot;ave&quot;: &quot;ave&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>API提供增删查改功能，增删改只通过状态码就可以判断执行结果，只有查询的时候才会需要从响应中获取数据。</p>
<h1 id="0X08-增加一条新的数据"><a href="#0X08-增加一条新的数据" class="headerlink" title="0X08 增加一条新的数据"></a>0X08 增加一条新的数据</h1><p>添加一条新数据按照标准应该使用动词<code>POST</code>，根据URL中只有名词不用动词只有名词的标准，隧将URL设计成<code>http://localhost/student</code>，再依据标准添加版本号上去，变成<code>http://localhost/v1/student</code>。<br>具体功能代码实现如下，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(&#x27;/v1/student&#x27;, methods=[&#x27;POST&#x27;]) # 路径为/v1/student，方法为POST</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_student</span>():</span></span><br><span class="line">    data = request.get_data().decode(<span class="string">&#x27;utf-8&#x27;</span>)   <span class="comment"># 将客户端传来的数据解码</span></span><br><span class="line">    json_data = json.loads(data)    <span class="comment"># 将数据转为Json</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从Json中获取数据</span></span><br><span class="line">    name = json_data[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    number = str(json_data[<span class="string">&#x27;number&#x27;</span>])</span><br><span class="line">    python = json_data[<span class="string">&#x27;python&#x27;</span>]</span><br><span class="line">    cpp = json_data[<span class="string">&#x27;cpp&#x27;</span>]</span><br><span class="line">    os = json_data[<span class="string">&#x27;os&#x27;</span>]</span><br><span class="line">    network = json_data[<span class="string">&#x27;network&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算总分平均分</span></span><br><span class="line">    total = python + cpp + os + network</span><br><span class="line">    ave = total / <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询数据库中是否有该学生的信息</span></span><br><span class="line">    sql = <span class="string">&quot;SELECT COUNT(*) FROM student.marks WHERE number=\&quot;%s\&quot;&quot;</span> % number</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    count = cursor.fetchall()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    database.commit()</span><br><span class="line">    <span class="keyword">if</span> count &gt;= <span class="number">1</span>:  <span class="comment"># 该学生信息已经存在，返回400错误</span></span><br><span class="line">        <span class="keyword">return</span> build_json(e_msg=<span class="string">&quot;student early exist&quot;</span>), <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向数据库中插入数据</span></span><br><span class="line">    sql = <span class="string">&quot;INSERT INTO student.marks (name, number, python, os, network, cpp, total, ave)&quot;</span> \</span><br><span class="line">          <span class="string">&quot;VALUES (\&quot;%s\&quot;, \&quot;%s\&quot;, %s, %s, %s, %s, %s, %s)&quot;</span> % (name, number, python, os,</span><br><span class="line">                                                               network, cpp, total, ave)</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    database.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求成功，返回201状态码</span></span><br><span class="line">    <span class="keyword">return</span> build_json(), <span class="number">201</span></span><br></pre></td></tr></table></figure>

<h1 id="0X09-删除已经存在的数据"><a href="#0X09-删除已经存在的数据" class="headerlink" title="0X09 删除已经存在的数据"></a>0X09 删除已经存在的数据</h1><p>根据标准，将API设计成<code>DELETE</code>方法，URL为<code>http://localhost/v1/student/number=&lt;number&gt;</code><br>第一行的<code>number=&lt;number&gt;</code>可以将url中符合这种规范的匹配出来，配合方法定义时的参数，可以直接将url参数传入到方法体中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(&#x27;/v1/student/number=&lt;number&gt;&#x27;, methods=[&#x27;DELETE&#x27;])  # 路径为/v1/student, 方法为DELETE</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_student</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> number.isdigit():    <span class="comment"># 判断number是否合法</span></span><br><span class="line">        <span class="keyword">return</span> build_json(e_msg=<span class="string">&quot;number should be digit&quot;</span>), <span class="number">403</span></span><br><span class="line">    sql = <span class="string">&quot;DELETE FROM student.marks WHERE number=\&quot;%s\&quot;&quot;</span> % number</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    database.commit()</span><br><span class="line">    <span class="keyword">return</span> build_json(), <span class="number">204</span></span><br></pre></td></tr></table></figure>

<h1 id="0X0A-查询学生成绩"><a href="#0X0A-查询学生成绩" class="headerlink" title="0X0A 查询学生成绩"></a>0X0A 查询学生成绩</h1><p>根据标准，将API设计成<code>GET</code>方法，URL为<code>http://localhost/v1/student/sort_by=&lt;sort_by&gt;</code>。提供了<code>python/cpp/network/os/total/ave</code>排序方式，（其实是数据库实现的）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(&#x27;/v1/student/sort_by=&lt;sort_by&gt;&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_student</span>(<span class="params">sort_by</span>):</span></span><br><span class="line">    <span class="comment"># 判断排序的key是否正确</span></span><br><span class="line">    <span class="keyword">if</span> sort_by <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;cpp&#x27;</span>, <span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;network&#x27;</span>, <span class="string">&#x27;total&#x27;</span>, <span class="string">&#x27;ave&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> build_json(e_msg=<span class="string">&quot;sort_by key not found&quot;</span>), <span class="number">404</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建查询SQL</span></span><br><span class="line">    sql = <span class="string">&quot;SELECT name, number, python, cpp, os, network, total, ave FROM student.marks ORDER BY %s DESC&quot;</span> % sort_by</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    database.commit()</span><br><span class="line">    res = cursor.fetchall() <span class="comment"># 获取查询结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建查询结果Json</span></span><br><span class="line">    res_list = &#123;&#125;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">        res_list[<span class="string">&#x27;item&#x27;</span> + str(count)] = &#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: i[<span class="number">0</span>],</span><br><span class="line">            <span class="string">&#x27;number&#x27;</span>: i[<span class="number">1</span>],</span><br><span class="line">            <span class="string">&#x27;python&#x27;</span>: i[<span class="number">2</span>],</span><br><span class="line">            <span class="string">&#x27;cpp&#x27;</span>: i[<span class="number">3</span>],</span><br><span class="line">            <span class="string">&#x27;os&#x27;</span>: i[<span class="number">4</span>],</span><br><span class="line">            <span class="string">&#x27;network&#x27;</span>: i[<span class="number">5</span>],</span><br><span class="line">            <span class="string">&#x27;total&#x27;</span>: i[<span class="number">6</span>],</span><br><span class="line">            <span class="string">&#x27;ave&#x27;</span>: [i[<span class="number">7</span>]]</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> build_json(search_list=res_list), <span class="number">200</span></span><br></pre></td></tr></table></figure>

<h1 id="0X0B-修改学生成绩"><a href="#0X0B-修改学生成绩" class="headerlink" title="0X0B 修改学生成绩"></a>0X0B 修改学生成绩</h1><p>修改学生成绩和添加成绩几乎是一样的操作，只有这么几点是不太一样的。添加信息时如果学号已经存在了那就不能再添加了，而修改的时候是如果学号不存在才错误；添加和修改的SQL不同。就没有别的区别了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(&#x27;/v1/student&#x27;, methods=[&#x27;PUT&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_student</span>():</span></span><br><span class="line">    data = request.get_data().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json_data = json.loads(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从Json中获取数据</span></span><br><span class="line">    name = json_data[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    number = str(json_data[<span class="string">&#x27;number&#x27;</span>])</span><br><span class="line">    python = json_data[<span class="string">&#x27;python&#x27;</span>]</span><br><span class="line">    cpp = json_data[<span class="string">&#x27;cpp&#x27;</span>]</span><br><span class="line">    os = json_data[<span class="string">&#x27;os&#x27;</span>]</span><br><span class="line">    network = json_data[<span class="string">&#x27;network&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询数据库中是否有该学生的信息</span></span><br><span class="line">    sql = <span class="string">&quot;SELECT COUNT(*) FROM student.marks WHERE number=\&quot;%s\&quot;&quot;</span> % number</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    count = cursor.fetchall()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    database.commit()</span><br><span class="line">    <span class="keyword">if</span> count &lt; <span class="number">1</span>:  <span class="comment"># 该学生信息不存在，返回404错误</span></span><br><span class="line">        <span class="keyword">return</span> build_json(e_msg=<span class="string">&quot;student not found&quot;</span>), <span class="number">404</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算总分平均分</span></span><br><span class="line">    total = python + cpp + os + network</span><br><span class="line">    ave = total / <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向数据库中插入数据</span></span><br><span class="line">    sql = <span class="string">&quot;UPDATE student.marks SET name=\&quot;%s\&quot;, python=%s, cpp=%s, os=%s, network=%s, total=%s, ave=%s WHERE number=\&quot;%s\&quot;&quot;</span> % (name, python, cpp, os, network, total, ave, number)</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    database.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求成功，返回201状态码</span></span><br><span class="line">    <span class="keyword">return</span> build_json(), <span class="number">201</span></span><br></pre></td></tr></table></figure>
<h1 id="0X0C-搞定所有API"><a href="#0X0C-搞定所有API" class="headerlink" title="0X0C 搞定所有API"></a>0X0C 搞定所有API</h1><p>现在就搞定了所有的API编写。现在我把所有代码贴上来，注意这段代码是用于Python3的。如果需要测试的话可以用Python自带的<code>requests</code>模块或者<a href="https://www.getpostman.com/">Postman软件</a>来测试该API。</p>
<ul>
<li>声明：代码最后一行的<code>app.run()</code>方法，现在是只在本地监听的。可以改成<code>app.run(&#39;0.0.0.0&#39;)</code>就对外部监听了。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># @Time    : 2017/6/3 11:34</span></span><br><span class="line"><span class="comment"># @Author  : Shawn</span></span><br><span class="line"><span class="comment"># @Blog    : https://blog.just666.cn</span></span><br><span class="line"><span class="comment"># @Email   : shawnbluce@gmail.com</span></span><br><span class="line"><span class="comment"># @purpose : 演示Python_API</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">database = pymysql.connect(<span class="string">&quot;115.29.52.14&quot;</span>, <span class="string">&quot;shawn&quot;</span>, <span class="string">&quot;zhangHAO8&quot;</span>, <span class="string">&quot;student&quot;</span>)</span><br><span class="line">cursor = database.cursor()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_json</span>(<span class="params">search_list=None, e_msg=None</span>) -&gt; str:</span></span><br><span class="line">    json_data = &#123;<span class="string">&#x27;time&#x27;</span>: time.time(), <span class="string">&#x27;search_list&#x27;</span>: search_list, <span class="string">&#x27;e_msg&#x27;</span>: e_msg&#125;</span><br><span class="line">    <span class="keyword">return</span> json.dumps(json_data)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;hello,world&lt;/h1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/v1/student&#x27;, methods=[&#x27;POST&#x27;]) # 路径为/v1/student，方法为POST</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_student</span>():</span></span><br><span class="line">    data = request.get_data().decode(<span class="string">&#x27;utf-8&#x27;</span>)   <span class="comment"># 将客户端传来的数据解码</span></span><br><span class="line">    json_data = json.loads(data)    <span class="comment"># 将数据转为Json</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从Json中获取数据</span></span><br><span class="line">    name = json_data[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    number = str(json_data[<span class="string">&#x27;number&#x27;</span>])</span><br><span class="line">    python = json_data[<span class="string">&#x27;python&#x27;</span>]</span><br><span class="line">    cpp = json_data[<span class="string">&#x27;cpp&#x27;</span>]</span><br><span class="line">    os = json_data[<span class="string">&#x27;os&#x27;</span>]</span><br><span class="line">    network = json_data[<span class="string">&#x27;network&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算总分平均分</span></span><br><span class="line">    total = python + cpp + os + network</span><br><span class="line">    ave = total / <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询数据库中是否有该学生的信息</span></span><br><span class="line">    sql = <span class="string">&quot;SELECT COUNT(*) FROM student.marks WHERE number=\&quot;%s\&quot;&quot;</span> % number</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    count = cursor.fetchall()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    database.commit()</span><br><span class="line">    <span class="keyword">if</span> count &gt;= <span class="number">1</span>:  <span class="comment"># 该学生信息已经存在，返回400错误</span></span><br><span class="line">        <span class="keyword">return</span> build_json(e_msg=<span class="string">&quot;student early exist&quot;</span>), <span class="number">400</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向数据库中插入数据</span></span><br><span class="line">    sql = <span class="string">&quot;INSERT INTO student.marks (name, number, python, os, network, cpp, total, ave)&quot;</span> \</span><br><span class="line">          <span class="string">&quot;VALUES (\&quot;%s\&quot;, \&quot;%s\&quot;, %s, %s, %s, %s, %s, %s)&quot;</span> % (name, number, python, os,</span><br><span class="line">                                                               network, cpp, total, ave)</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    database.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求成功，返回201状态码</span></span><br><span class="line">    <span class="keyword">return</span> build_json(), <span class="number">201</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/v1/student/number=&lt;number&gt;&#x27;, methods=[&#x27;DELETE&#x27;])  # 路径为/v1/student, 方法为DELETE</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_student</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> number.isdigit():    <span class="comment"># 判断number是否合法</span></span><br><span class="line">        <span class="keyword">return</span> build_json(e_msg=<span class="string">&quot;number should be digit&quot;</span>), <span class="number">403</span></span><br><span class="line">    sql = <span class="string">&quot;DELETE FROM student.marks WHERE number=\&quot;%s\&quot;&quot;</span> % number</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    database.commit()</span><br><span class="line">    <span class="keyword">return</span> build_json(), <span class="number">204</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/v1/student/sort_by=&lt;sort_by&gt;&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_student</span>(<span class="params">sort_by</span>):</span></span><br><span class="line">    <span class="comment"># 判断排序的key是否正确</span></span><br><span class="line">    <span class="keyword">if</span> sort_by <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;cpp&#x27;</span>, <span class="string">&#x27;os&#x27;</span>, <span class="string">&#x27;network&#x27;</span>, <span class="string">&#x27;total&#x27;</span>, <span class="string">&#x27;ave&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> build_json(e_msg=<span class="string">&quot;sort_by key not found&quot;</span>), <span class="number">404</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建查询SQL</span></span><br><span class="line">    sql = <span class="string">&quot;SELECT name, number, python, cpp, os, network, total, ave FROM student.marks ORDER BY %s DESC&quot;</span> % sort_by</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    database.commit()</span><br><span class="line">    res = cursor.fetchall()  <span class="comment"># 获取查询结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建查询结果Json</span></span><br><span class="line">    res_list = &#123;&#125;</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">        res_list[<span class="string">&#x27;item&#x27;</span> + str(count)] = &#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: i[<span class="number">0</span>],</span><br><span class="line">            <span class="string">&#x27;number&#x27;</span>: i[<span class="number">1</span>],</span><br><span class="line">            <span class="string">&#x27;python&#x27;</span>: i[<span class="number">2</span>],</span><br><span class="line">            <span class="string">&#x27;cpp&#x27;</span>: i[<span class="number">3</span>],</span><br><span class="line">            <span class="string">&#x27;os&#x27;</span>: i[<span class="number">4</span>],</span><br><span class="line">            <span class="string">&#x27;network&#x27;</span>: i[<span class="number">5</span>],</span><br><span class="line">            <span class="string">&#x27;total&#x27;</span>: i[<span class="number">6</span>],</span><br><span class="line">            <span class="string">&#x27;ave&#x27;</span>: [i[<span class="number">7</span>]]</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> build_json(search_list=res_list), <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/v1/student&#x27;, methods=[&#x27;PUT&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_student</span>():</span></span><br><span class="line">    data = request.get_data().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    json_data = json.loads(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从Json中获取数据</span></span><br><span class="line">    name = json_data[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    number = str(json_data[<span class="string">&#x27;number&#x27;</span>])</span><br><span class="line">    python = json_data[<span class="string">&#x27;python&#x27;</span>]</span><br><span class="line">    cpp = json_data[<span class="string">&#x27;cpp&#x27;</span>]</span><br><span class="line">    os = json_data[<span class="string">&#x27;os&#x27;</span>]</span><br><span class="line">    network = json_data[<span class="string">&#x27;network&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询数据库中是否有该学生的信息</span></span><br><span class="line">    sql = <span class="string">&quot;SELECT COUNT(*) FROM student.marks WHERE number=\&quot;%s\&quot;&quot;</span> % number</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    count = cursor.fetchall()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    database.commit()</span><br><span class="line">    <span class="keyword">if</span> count &lt; <span class="number">1</span>:  <span class="comment"># 该学生信息不存在，返回404错误</span></span><br><span class="line">        <span class="keyword">return</span> build_json(e_msg=<span class="string">&quot;student not found&quot;</span>), <span class="number">404</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算总分平均分</span></span><br><span class="line">    total = python + cpp + os + network</span><br><span class="line">    ave = total / <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向数据库中插入数据</span></span><br><span class="line">    sql = <span class="string">&quot;UPDATE student.marks SET name=\&quot;%s\&quot;, python=%s, cpp=%s, os=%s, network=%s, total=%s, ave=%s WHERE number=\&quot;%s\&quot;&quot;</span> \</span><br><span class="line">          % (name, python, cpp, os, network, total, ave, number)</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    database.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求成功，返回201状态码</span></span><br><span class="line">    <span class="keyword">return</span> build_json(), <span class="number">201</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> app.test_request_context():</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Flask </tag>
            
            <tag> API </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中OS库的常用方法]]></title>
      <url>/2017/04/01/python-os-lib/</url>
      <content type="html"><![CDATA[<p>在写一些系统脚本或者自动化运维脚本的时候经常会用到os库，这里做个整理，方便查找</p>
<h3 id="os-sep"><a href="#os-sep" class="headerlink" title="os.sep"></a>os.sep</h3><p>获得当前操作系统使用的目录分隔符，比如Windows就会得到<code>\</code>而Linux/Unix就会得到<code>/</code></p>
<h3 id="os-name"><a href="#os-name" class="headerlink" title="os.name"></a>os.name</h3><p>获得当前使用的操作系统，Windows是NT内核，所以会得到<code>nt</code>，而Linux/Unix用户则会得到<code>posix</code></p>
<h3 id="os-getcwd"><a href="#os-getcwd" class="headerlink" title="os.getcwd()"></a>os.getcwd()</h3><p>获得当前工作目录，即当前Python脚本工作的目录路径。</p>
<h3 id="os-getenv"><a href="#os-getenv" class="headerlink" title="os.getenv()"></a>os.getenv()</h3><p>用来获得环境变量<br><code>os.getenv(&#39;PATH&#39;)</code></p>
<a id="more"></a>

<h3 id="os-environ"><a href="#os-environ" class="headerlink" title="os.environ"></a>os.environ</h3><p>可以获取并修改环境变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(os.environ[<span class="string">&#x27;PATH&#x27;</span>])</span><br><span class="line">os.environ += <span class="string">&#x27;D:/testdir/bin/&#x27;</span></span><br><span class="line">print(os.environ[<span class="string">&quot;PATH&quot;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="os-listdir"><a href="#os-listdir" class="headerlink" title="os.listdir()"></a>os.listdir()</h3><p>列出某目录下所有的目录和文件<br><code>print(os.listdir())</code></p>
<h3 id="os-remove"><a href="#os-remove" class="headerlink" title="os.remove()"></a>os.remove()</h3><p>删除文件<br><code>os.remove(&#39;D:/test.file&#39;)</code></p>
<h3 id="os-system"><a href="#os-system" class="headerlink" title="os.system()"></a>os.system()</h3><p>运行Shell或者CMD命令<br><code>os.system(&#39;ifconfig&#39;)</code></p>
<h3 id="os-linesep"><a href="#os-linesep" class="headerlink" title="os.linesep"></a>os.linesep</h3><p>获取当前平台使用的行终止符。例如，Windows使用<code>\r\n</code>，Linux使用<code>\n</code>而Mac使用<code>\r</code>。</p>
<h3 id="os-path-split"><a href="#os-path-split" class="headerlink" title="os.path.split()"></a>os.path.split()</h3><p>获得一个列表，list[0]是路径的，list[1]是文件名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&#x27;D:/game/gtav/bin/gtav.exe&#x27;</span></span><br><span class="line">print(os.path.split(path)[<span class="number">0</span>])</span><br><span class="line">print(os.path.split(path)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="os-path-isfile-和os-path-isdir"><a href="#os-path-isfile-和os-path-isdir" class="headerlink" title="os.path.isfile()和os.path.isdir()"></a>os.path.isfile()和os.path.isdir()</h3><p>判断路径是不是文件/目录</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(os.path.isfile(<span class="string">&#x27;D:/game/gtav/bin/gtav.exe&#x27;</span>))</span><br><span class="line">print(os.path.isdir(<span class="string">&#x27;D:/game/gtav/bin&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="os-path-existe"><a href="#os-path-existe" class="headerlink" title="os.path.existe()"></a>os.path.existe()</h3><p>函数用来检验给出的路径是否真地存在</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&#x27;D:\\hadoop-2.6.5\\bin&#x27;</span></span><br><span class="line">print(os.path.exists(path))</span><br><span class="line">path = <span class="string">&#x27;D:\\hadoop-2.6.5\\bin\\hadoop&#x27;</span></span><br><span class="line">print(os.path.exists(path))</span><br></pre></td></tr></table></figure>

<h3 id="os-chdir-dirname"><a href="#os-chdir-dirname" class="headerlink" title="os.chdir(dirname)"></a>os.chdir(dirname)</h3><p>切换工作目录，相当于<code>cd</code>的命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">&#x27;D:/game/gtav/&#x27;</span>)</span><br><span class="line">print(os.getcwd())</span><br></pre></td></tr></table></figure>

<h3 id="os-path-getsize-name"><a href="#os-path-getsize-name" class="headerlink" title="os.path.getsize(name)"></a>os.path.getsize(name)</h3><p>获取文件大小，以字节为单位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size = os.path.getsize(<span class="string">&#x27;D:/iso/debian-8.6.0-amd64-DVD-1.iso&#x27;</span>)</span><br><span class="line">print(size/<span class="number">1024</span>/<span class="number">1024</span>/<span class="number">1024</span>, <span class="string">&#x27;GB&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="os-path-abspath-name"><a href="#os-path-abspath-name" class="headerlink" title="os.path.abspath(name)"></a>os.path.abspath(name)</h3><p>获取绝对路径，如果在Python工作目录下有一个文件<code>file.txt</code>，那么我就可以直接<code>open(&#39;file.txt&#39;)</code>，也可以用该方法获得其绝对路径<code>print(os.path.abspath(&#39;file.txt&#39;))</code>。也可以用来规范路径字符串<code>print(os.path.abspath(&#39;D:/game\gtav\bin/gtav.exe&#39;))</code></p>
<h3 id="os-path-normpath-path"><a href="#os-path-normpath-path" class="headerlink" title="os.path.normpath(path)"></a>os.path.normpath(path)</h3><p>专门用来规范路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&#x27;D:/test/sdf\zfb&#x27;</span></span><br><span class="line">print(os.path.normpath(path))</span><br></pre></td></tr></table></figure>

<h3 id="os-path-splitext"><a href="#os-path-splitext" class="headerlink" title="os.path.splitext()"></a>os.path.splitext()</h3><p>获取文件名和扩展名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&#x27;/home/shawn/hello.py&#x27;</span></span><br><span class="line">print(os.path.splitext(path))</span><br></pre></td></tr></table></figure>

<h3 id="os-path-join-path-name"><a href="#os-path-join-path-name" class="headerlink" title="os.path.join(path,name)"></a>os.path.join(path,name)</h3><p>连接目录和文件名，可以不用自己添加分隔符，能减少bug率提升跨平台性</p>
<h3 id="os-path-basename-path"><a href="#os-path-basename-path" class="headerlink" title="os.path.basename(path)"></a>os.path.basename(path)</h3><p>获取路径中的文件名</p>
<h3 id="os-path-dirname-path"><a href="#os-path-dirname-path" class="headerlink" title="os.path.dirname(path)"></a>os.path.dirname(path)</h3><p>获取路径中的目录名</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析HDFS]]></title>
      <url>/2017/03/06/hdfs-simple/</url>
      <content type="html"><![CDATA[<h1 id="0X00-HDFS的设计"><a href="#0X00-HDFS的设计" class="headerlink" title="0X00 HDFS的设计"></a>0X00 HDFS的设计</h1><p>HDFS作为GFS的开源实现，和GFS是高度一致的。在HDFS中有着下面的优点</p>
<ol>
<li>对超大文件支持良好，由于其分布式实现，可以存储超大文件，甚至单个文件大小可以超过集群中任意一台机器的磁盘大小</li>
<li>采用流式数据访问，一次写入、多次读取是最高效的访问模式。因为Hadoop作为一个大数据处理平台，并没有频繁的写入操作，只是在需要的时候一次将大量的数据写入然后在对这些数据进行读操作</li>
<li>Hadoop并不需要运行在昂贵且高可靠的硬件之上，单个节点可能性能可靠性都参差不齐，但是由于其高可靠性的设计，使之能在遇到节点故障时继续运行且不让用户察觉到明显的终端</li>
</ol>
<p>但是HDFS也不是适用于各种场景，一下的几种场景就不适</p>
<ol>
<li>低时间延迟的数据访问，因为HDFS是以时间延迟为代价针对高数据吞吐量优化的，所以HDFS不适用与低延迟的数据访问</li>
<li>大量的小文件，因为Namenode的设计是将文件系统的元数据存储在内存中的，所以理论上HDFS中的文件最大数量受限于Namenode的内存容量，因此大量的小文件会占用Namenode大量的内存</li>
<li>HDFS目前不支持有多个写入者的操作，也不支持修改文件系统中的文件</li>
</ol>
<a id="more"></a>

<h1 id="0X01-数据块的设计"><a href="#0X01-数据块的设计" class="headerlink" title="0X01 数据块的设计"></a>0X01 数据块的设计</h1><p>我们知道在传统的文件系统中就是分块的，寻址开销与分块的大小成负相关，磁盘利用率与分块大小成负相关。且HDFS的设计就是用来处理大文件的，所以将块设计的很大，默认为64MB且好多时候采用的是128MB的设置。</p>
<p>在HDFS中的块设计和传统文件系统有些不同，在传统文件系统中假设一个块为4kb，如果一个文件只有1kb则仍然会占用4kb的空间，但是在HDFS中一个小于块大小的文件并不会占据整个块的空间。</p>
<p><img src="https://blog.just666.cn/usr/uploads/hdfs_arch.png" alt="HDFS架构"></p>
<h1 id="0X02-Namenode和Datanode"><a href="#0X02-Namenode和Datanode" class="headerlink" title="0X02 Namenode和Datanode"></a>0X02 Namenode和Datanode</h1><p>HDFS中有两种节点，Namenode和Datanode。</p>
<p>其中Namenode管理文件系统的命名空间，他维护着文件系统树和整棵树内所有的文件和目录。</p>
<p>其中的Datanode负责存储并检索数据块，且定期向Namenode发送存储的块的列表。</p>
<h1 id="0X03-Namenode容错机制"><a href="#0X03-Namenode容错机制" class="headerlink" title="0X03 Namenode容错机制"></a>0X03 Namenode容错机制</h1><p>Namenode有两种常用的容错机制，第一种是实时将自己的操作和文件同步到NFS上，且是原子操作所以NFS上会有和Namenode完全相同的文件。另一种方式是运行一个辅助的Namenode，定期通过编辑日志合并命名空间镜像。</p>
<h1 id="0X04-联邦HDFS"><a href="#0X04-联邦HDFS" class="headerlink" title="0X04 联邦HDFS"></a>0X04 联邦HDFS</h1><p>毕竟HDFS是为处理海量数据诞生的，所以避免不了海量的集群来搭建HDFS，但是前面也说过因为设计的问题导致一个拥有大量文件的集群会对Namenode的内存造成严峻的考验，这时候可以使用联邦HDFS来解决。在联邦环境下可以配置多个Namenode，每个Namenode负责维护一个命名空间卷。也就相当于每个Namenode负责一个目录树中的子目录，这样就可以保证在HDFS中有大量文件的时候也不会对Namenode造成太大的威胁。</p>
<h1 id="0X05-高可用性"><a href="#0X05-高可用性" class="headerlink" title="0X05 高可用性"></a>0X05 高可用性</h1><p>虽然Namenode有了备份但是还是存在Namenode的单点问题，也就是说当Namenode出现故障之后依旧会对HDFS整个文件系统造成影响，虽然有备份但是还是要等到有下一台Namenode节点上线之后才会运行，所以当时运行的MapReduce等程序依然会终止。针对这种问题Hadoop在2.x中做出了适当的处理。可以配置一对活动-备用的Namenode用于做热备份。</p>
<ol>
<li>Namenode之间可以共享编辑日志，且使用高可用的方式实现共享存储</li>
<li>Datanode需要同时向两个Namenode发送数据块处理报告，因为要保持两个Namenode完全相同</li>
</ol>
<p>在这样的配置之下当活动的Namenode故障以后备用的Namenode可以在几十秒内实现任务接管。且在备用的Namenode也失效的情况下还可以通过配置来指定另一台备用Namenode用于做冷启动。</p>
]]></content>
      
        
        <tags>
            
            <tag> File System </tag>
            
            <tag> HDFS </tag>
            
            <tag> Big Data </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的字符串]]></title>
      <url>/2017/02/13/java-str/</url>
      <content type="html"><![CDATA[<blockquote>
<p>String类中每一个看起来会修改String值得方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。   —《Java编程思想》第13章</p>
</blockquote>
<h1 id="0X00-String常量池"><a href="#0X00-String常量池" class="headerlink" title="0X00 String常量池"></a>0X00 String常量池</h1><p>如果使用常用的方式定义两个内容完全一样的字符串，那么Java使用常量的方式，也就是说第二个字符串并没有生成一个对象而是引用了之前的字符串，导致他们的本质是一样的，所以当使用<code>==</code>判断两个字符串对象是否是同一个对象的时候，会显示是同一个对象。但是如果我们每次声明一个字符串的时候使用<code>new String()</code>的方式，则会每次创建一个String对象，两者就不是同一个对象了。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 两个相同的字符串引用自同一处</span></span><br><span class="line">        String str1 = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这两个字符串就是每次生成一个新对象</span></span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        System.out.println(str3 == str4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0X01-StringBuilder"><a href="#0X01-StringBuilder" class="headerlink" title="0X01 StringBuilder"></a>0X01 StringBuilder</h1><p>字符串的拼接在Java中非常方便，但常用的使用<code>+</code>来拼接字符串效率很低，在需要拼接的次数不是很多的时候不会影响多少效率，但当需要拼接的字符串数量很多的时候就需要使用<code>StringBuilder</code>来拼接。该类中有一个<code>append()</code>的方法，就是将一个字符串连接到本对象的字符串后面。下面我们来对比一下这两个拼接方法的速度差异。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String string = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">		<span class="comment">// 循环连接1W次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            string += <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> middle = <span class="keyword">new</span> Date().getTime();</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">		<span class="comment">// 循环连接1000W次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = <span class="keyword">new</span> Date().getTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用+连接耗时: &quot;</span> + (middle - start));</span><br><span class="line">        System.out.println(<span class="string">&quot;使用StringBuilder连接耗时: &quot;</span> + (end - middle));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用+连接耗时: 850</span><br><span class="line">使用StringBuilder连接耗时: 263</span><br></pre></td></tr></table></figure>
<p>速度差异很明显，使用加号连接只连接一万次就耗时800多毫秒，而使用StringBuilder即使连接一千万次也只需要200多毫秒。</p>
<p>该类中还有其他的方法<code>insert()指定位置插入</code> / <code>replace()分片赋值</code> / <code>substring()提取子字符串</code> / <code>reverse()翻转字符串</code> / <code>toString()返回字符串</code><br>使用演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        stringBuilder.insert(<span class="number">5</span>, <span class="string">&quot;hello,world&quot;</span>);	<span class="comment">// 插入字符串</span></span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        stringBuilder.replace(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&quot;hello,world&quot;</span>);	<span class="comment">// 分片赋值</span></span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        stringBuilder.substring(<span class="number">3</span>, <span class="number">5</span>);	<span class="comment">// 提取子字符串</span></span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        stringBuilder.reverse();	<span class="comment">// 翻转字符串</span></span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0X02-String的其他方法"><a href="#0X02-String的其他方法" class="headerlink" title="0X02 String的其他方法"></a>0X02 String的其他方法</h1><p>String类中有很多方法，这里有几个常用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String string;</span><br><span class="line">        <span class="keyword">boolean</span> bool;</span><br><span class="line"></span><br><span class="line">        string = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        bool = string.equals(<span class="string">&quot;hello,world&quot;</span>);    <span class="comment">// 判断字符串是否相同</span></span><br><span class="line">        System.out.println(bool);</span><br><span class="line"></span><br><span class="line">        string = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        bool = string.contains(<span class="string">&quot;hello&quot;</span>);    <span class="comment">// 检查字符串中是否有另一个字符串</span></span><br><span class="line">        System.out.println(bool);</span><br><span class="line"></span><br><span class="line">        string = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        bool = string.startsWith(<span class="string">&quot;he&quot;</span>); <span class="comment">// 是否以某个字符串开头</span></span><br><span class="line"><span class="comment">//        bool = string.endsWith(&quot;ld&quot;); // 结尾</span></span><br><span class="line">        System.out.println(bool);</span><br><span class="line"></span><br><span class="line">        string = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        string = string.replace(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;java&quot;</span>);   <span class="comment">// 字符串搜索替换</span></span><br><span class="line">        System.out.println(string);</span><br><span class="line"></span><br><span class="line">        string = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        string = string.toUpperCase();  <span class="comment">// 全转成大写</span></span><br><span class="line"><span class="comment">//        string = string.toLowerCase();    // 小写</span></span><br><span class="line">        System.out.println(string);</span><br><span class="line"></span><br><span class="line">        string = <span class="string">&quot;  hello,world   &quot;</span>;</span><br><span class="line">        string = string.trim(); <span class="comment">// 去掉字符串两头的空白</span></span><br><span class="line">        System.out.println(string);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0X03-String的正则方法"><a href="#0X03-String的正则方法" class="headerlink" title="0X03 String的正则方法"></a>0X03 String的正则方法</h1><p>简单的正则匹配可以直接使用String类中的方法，比如查看字符串是否符合某正则表达式的<code>matches()</code>和切割字符串的<code>split()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">&quot;java0python00cpp&quot;</span>;</span><br><span class="line">        System.out.println(string.matches(<span class="string">&quot;[\\w\\d]+&quot;</span>));	<span class="comment">// 检测是否能匹配</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        String[] strings = string.split(<span class="string">&quot;\\d+&quot;</span>);	<span class="comment">// 按正则表达式分割字符串，返回字符串数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++)&#123;</span><br><span class="line">            System.out.print(strings[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 奇技淫巧 (五) 系统脚本]]></title>
      <url>/2017/01/31/python-magic-5/</url>
      <content type="html"><![CDATA[<blockquote>
<h5 id="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"><a href="#文章中的代码仅在Python3中测试成功，没有在Python2中测试。" class="headerlink" title="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"></a>文章中的代码仅在Python3中测试成功，没有在Python2中测试。</h5></blockquote>
<h1 id="0X00-退出程序，显示错误信息"><a href="#0X00-退出程序，显示错误信息" class="headerlink" title="0X00 退出程序，显示错误信息"></a>0X00 退出程序，显示错误信息</h1><p>写脚本的时候经常会有执行出错，出错的时候可以用一句话把程序退出并且打印错误信息<br><code>raise SystemExit(&#39;error message&#39;)</code></p>
<h1 id="0X01-输入密码"><a href="#0X01-输入密码" class="headerlink" title="0X01 输入密码"></a>0X01 输入密码</h1><p>有的时候需要输入用户名和密码，使用<code>input()</code>输入用户名自然没有问题，但是用相同的方法输入密码的时候时使用明文的。长期用Linux的可能对Linux中密码的输入比较有印象，输入密码的时候是密文，且没有任何提示，包括星号，所以用这种方法输入密码是非常安全的。使用<code>petpass</code>库可以简单的输入用户名和密码，输入用户名最简单还是<code>input()</code>，如果要获取当前登录的用户名就可以使用<code>getpass.getuser()</code>，输入密码就可以使用<code>getpass.getpass()</code>来实现Linux中的那种密码输入。 <strong>如果测试的时候有问题可以在命令行下测试，比如Windows的CMD或者Linux的终端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    user = input(<span class="string">&quot;Username:&quot;</span>)</span><br><span class="line">    <span class="comment"># user = getpass.getuser()</span></span><br><span class="line"></span><br><span class="line">    passwd = getpass.getpass()</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0X03-执行命令"><a href="#0X03-执行命令" class="headerlink" title="0X03 执行命令"></a>0X03 执行命令</h1><p>在Linux中想要用Python代替Shell必然会出现在Python中调用命令的时候，那么这个时候就可以用这个方法来执行命令并获得输出内容。<code>subprocess.check_output([])</code>这个方法的参数是一个列表，列表里是一个或多个字符串，就像下面介绍的那样把命令通过空格拆分开，放到这个列表中。<code>check_output</code>返回的是一个二进制串，可以对其进行编码转变成人类可读的字符串。 <strong>这种方法只在Linux里测试过</strong> 毕竟没几个人会在WIndows下写脚本是吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    out_bype  = subprocess.check_output([<span class="string">&#x27;ls&#x27;</span>, <span class="string">&#x27;/dev&#x27;</span>])</span><br><span class="line">    out_text = out_bype.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    print(out_text)</span><br></pre></td></tr></table></figure>

<h1 id="0X04-复制-移动-文件-目录"><a href="#0X04-复制-移动-文件-目录" class="headerlink" title="0X04 复制/移动 文件/目录"></a>0X04 复制/移动 文件/目录</h1><p>在Python中复制移动文件和目录非常简单，尤其是在不考虑链接的情况下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    shutil.copy(<span class="string">&#x27;/etc/passwd&#x27;</span>, <span class="string">&#x27;passwd&#x27;</span>)	<span class="comment"># 将/etc/passwd复制到当前目录，等同于Linux中的  cp /etc/passwd passwd</span></span><br><span class="line">    shutil.copytree(<span class="string">&#x27;/etc&#x27;</span>, <span class="string">&#x27;etc&#x27;</span>)			<span class="comment"># 复制目录</span></span><br><span class="line"></span><br><span class="line">    shutil.move(<span class="string">&#x27;passwd&#x27;</span>, <span class="string">&#x27;mima&#x27;</span>)			<span class="comment"># 移动文件，也可以重命名，和Linux中的mv命令一样</span></span><br></pre></td></tr></table></figure>

<h1 id="0X05-获取终端大小"><a href="#0X05-获取终端大小" class="headerlink" title="0X05 获取终端大小"></a>0X05 获取终端大小</h1><p>在Linux中一般是在终端下工作，那么有的时候需要知道当前终端大小来控制输出的字符串长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sz = os.get_terminal_size()</span><br><span class="line">    columns = sz.columns</span><br><span class="line">    lines   = sz.lines</span><br><span class="line">    print(sz)</span><br><span class="line">    print(columns)</span><br><span class="line">    print(lines)</span><br></pre></td></tr></table></figure>

<h1 id="0X06-os-walk"><a href="#0X06-os-walk" class="headerlink" title="0X06 os.walk()"></a>0X06 os.walk()</h1><p>经常需要遍历一个目录，来获取目录中的内容，如果只需要查看一个目录，那么使用<code>os.listdir()</code>就足够了，如果只判断一个文件是否为目录，则<code>os.path.isdir()</code>也足够了。但是有的时候我们需要逐层遍历目录，且区别对待目录和文件，那么通常会自己手写一个递归的方法来解决。这样虽然能解决问题，但是毕竟多写了代码且效率还不高，其实<code>os</code>库里有一个方法值得我们使用就是<code>os.walk()</code>。这个方法接收一个目录作为参数，返回一个迭代器，每次迭代是一个元组，元组有三个元素，第一个元素是当前路径，第二个元素是当前目录下的目录名，第三个元素是当前目录下的文件。具体的可以看代码注释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    files = os.walk(<span class="string">&#x27;D:/movie&#x27;</span>)		<span class="comment"># 这里调用了方法，传入一个路径，返回一个可迭代对象</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> files:		<span class="comment"># 开始迭代</span></span><br><span class="line">        print(<span class="string">&#x27;path_name: &#x27;</span>, i[<span class="number">0</span>])	<span class="comment"># 输出当前路径</span></span><br><span class="line">        print(<span class="string">&#x27;dir_name : &#x27;</span>, i[<span class="number">1</span>])	<span class="comment"># 当前目录下的目录</span></span><br><span class="line">        print(<span class="string">&#x27;file_name: &#x27;</span>, i[<span class="number">2</span>])	<span class="comment"># 当前目录下的文件</span></span><br><span class="line">        print(<span class="string">&#x27;-----------------&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这个输出是下面这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">path_name:  D:/movie</span><br><span class="line">dir_name :  [<span class="string">&#x27;加勒比海盗&#x27;</span>, <span class="string">&#x27;机械师&#x27;</span>, <span class="string">&#x27;火影忍者&#x27;</span>, <span class="string">&#x27;蜘蛛侠&#x27;</span>]</span><br><span class="line">file_name:  [<span class="string">&#x27;V字仇杀队.mkv&#x27;</span>, <span class="string">&#x27;wikileaks-720p.mkv&#x27;</span>, <span class="string">&#x27;湄公河行动.mkv&#x27;</span>, <span class="string">&#x27;盗梦空间.mkv&#x27;</span>, <span class="string">&#x27;神奇动物在哪里.mp4&#x27;</span>, <span class="string">&#x27;绝地逃亡.mkv&#x27;</span>]</span><br><span class="line">-----------------</span><br><span class="line">path_name:  D:/movie\加勒比海盗</span><br><span class="line">dir_name :  []</span><br><span class="line">file_name:  [<span class="string">&#x27;加勒比海盗1：黑珍珠号的诅咒.mkv&#x27;</span>, <span class="string">&#x27;加勒比海盗2：聚魂棺.avi&#x27;</span>, <span class="string">&#x27;加勒比海盗3：世界尽头.avi&#x27;</span>, <span class="string">&#x27;加勒比海盗4：惊涛怪浪.mkv&#x27;</span>]</span><br><span class="line">-----------------</span><br><span class="line">path_name:  D:/movie\机械师</span><br><span class="line">dir_name :  []</span><br><span class="line">file_name:  [<span class="string">&#x27;机械师1.mkv&#x27;</span>, <span class="string">&#x27;机械师2：复活.mp4&#x27;</span>]</span><br><span class="line">-----------------</span><br><span class="line">path_name:  D:/movie\火影忍者</span><br><span class="line">dir_name :  []</span><br><span class="line">file_name:  [<span class="string">&#x27;火影忍者：博人传.mp4&#x27;</span>, <span class="string">&#x27;火影忍者：忍者之路.mkv&#x27;</span>, <span class="string">&#x27;火影忍者：终章.mp4&#x27;</span>]</span><br><span class="line">-----------------</span><br><span class="line">path_name:  D:/movie\蜘蛛侠</span><br><span class="line">dir_name :  []</span><br><span class="line">file_name:  [<span class="string">&#x27;蜘蛛侠1-2002.mkv&#x27;</span>, <span class="string">&#x27;蜘蛛侠2-2004.mkv&#x27;</span>, <span class="string">&#x27;蜘蛛侠3-2007.mkv&#x27;</span>, <span class="string">&#x27;超凡蜘蛛侠1-2012.mkv&#x27;</span>, <span class="string">&#x27;超凡蜘蛛侠2-2014.mp4&#x27;</span>]</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<h1 id="0X07-修改配置文件"><a href="#0X07-修改配置文件" class="headerlink" title="0X07 修改配置文件"></a>0X07 修改配置文件</h1><p>在Linux中有大量的配置文件，Windows中也有一些ini格式的配置文件，语法都一样的。那么用脚本来修改配置文件当然不必要全部读完整个文件后正则匹配，有一个非常简单且好用的方法。下面是我用来做测试的实例配置文件，命名为<code>1.ini</code>放在<code>D:/</code>根目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[home]</span><br><span class="line">phone &#x3D; On</span><br><span class="line">kindle &#x3D; Off</span><br><span class="line">learn &#x3D; False</span><br><span class="line"></span><br><span class="line">[school]</span><br><span class="line">phone &#x3D; On</span><br><span class="line">kindle &#x3D; On</span><br><span class="line">learn &#x3D; True</span><br></pre></td></tr></table></figure>
<p>可以看到，手机无论在哪都开机，Kindle只有在学校才用，学习也只有在学校才学。那么我们可以通过下面的方式来读取和修改这个配置文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> configparser <span class="keyword">import</span> ConfigParser</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    cfg = ConfigParser()    <span class="comment"># 实例化一个对象</span></span><br><span class="line">    cfg.read(<span class="string">&#x27;D:/1.ini&#x27;</span>)    <span class="comment"># 读取配置文件</span></span><br><span class="line"></span><br><span class="line">    tables = cfg.sections() <span class="comment"># 获取标签</span></span><br><span class="line">    print(tables)</span><br><span class="line"></span><br><span class="line">    phone_value = cfg.get(<span class="string">&#x27;home&#x27;</span>, <span class="string">&#x27;Phone&#x27;</span>)  <span class="comment"># 获取home标签下Phone的值</span></span><br><span class="line">    print(phone_value)</span><br><span class="line"></span><br><span class="line">    kindle_value = cfg.get(<span class="string">&#x27;school&#x27;</span>, <span class="string">&#x27;Kindle&#x27;</span>)  <span class="comment"># 获取school下Kindle的值</span></span><br><span class="line">    print(kindle_value)</span><br><span class="line"></span><br><span class="line">    learn_value = cfg.get(<span class="string">&#x27;school&#x27;</span>, <span class="string">&#x27;learn&#x27;</span>)    <span class="comment"># 获取school下learn的值</span></span><br><span class="line">    print(learn_value)</span><br><span class="line"></span><br><span class="line">    cfg.set(<span class="string">&#x27;home&#x27;</span>, <span class="string">&#x27;learn&#x27;</span>, <span class="string">&#x27;True&#x27;</span>)     <span class="comment"># 修改home下的learn为True</span></span><br><span class="line">    f = open(<span class="string">&#x27;D:/1.ini&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)            <span class="comment"># 用可写模式打开文件</span></span><br><span class="line">    cfg.write(f)        <span class="comment"># 将数据写回</span></span><br><span class="line">    f.close()           <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure>

<h1 id="0X08-打开浏览器"><a href="#0X08-打开浏览器" class="headerlink" title="0X08 打开浏览器"></a>0X08 打开浏览器</h1><p>不管是要给用户展示一个页面还是要将数据用HTML形式展示出来，都需要打开浏览器，这个在Python中可以用一行代码来搞定。<code>webbrowser.open_new(&#39;http://blog.just666.cn&#39;)</code>可以打开一个新的浏览器窗口，并打开这个链接，<code>webbrowser.open_new_table(&#39;http://blog.just666.cn&#39;)</code>可以在当前浏览器窗口新开一个标签。（需要先导入<code>webbrowser</code>这个包）</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Script </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 奇技淫巧 (四) 文件&I/O]]></title>
      <url>/2017/01/24/python-magic-4/</url>
      <content type="html"><![CDATA[<blockquote>
<h5 id="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"><a href="#文章中的代码仅在Python3中测试成功，没有在Python2中测试。" class="headerlink" title="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"></a>文章中的代码仅在Python3中测试成功，没有在Python2中测试。</h5></blockquote>
<h1 id="0X00-指定编码"><a href="#0X00-指定编码" class="headerlink" title="0X00 指定编码"></a>0X00 指定编码</h1><p>每个文本文件都是以某一编码格式保存的，如果解码格式和文本格式不同就会出现乱码，在Python中可以简单的控制用什么编码来打开文件以读写文件。使用<code>open</code>打开文件的时候指定一个<code>encoding</code>参数就可以使用其他而非默认编码打开文件了。这里用到了一个打开文件的方式是<code>with open() as f:</code>这样，这样做的话在这个with下面的代码块中可以直接调用f这个文件对象，并且执行到with代码块之外的时候会自动关闭文件，不需要再手动关闭文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用utf-8编码，写模式，打开文件D:/test.txt</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;D:/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&#x27;你好，世界&#x27;</span>)    <span class="comment"># 写一行汉子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用utf-8编码，读模式，打开文件D:/test.txt</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;D:/test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read())       <span class="comment"># 因为是编码相同所以可以正常读出文字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用latin-1编码，读模式，打开文件D:/test.txt</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;D:/test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;latin-1&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read())       <span class="comment"># 因为使用的编码格式不同，所以会出现乱码</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0X01-输出重定向"><a href="#0X01-输出重定向" class="headerlink" title="0X01 输出重定向"></a>0X01 输出重定向</h1><p>在Linux中可以对命令的输出进行重定向，将本应该输出到屏幕的东西输出到指定的文件里，在Python中也是可以简单做到这一点的。假设一个已经用写入模式打开的文件对象f，在输出文字的时候就可以直接这样调用<code>print(&#39;hello,world&#39;, file=f)</code>就可以直接将输出的内容重定向到文件中。这里需要注意的就是文件必须已经用可写模式打开，且是文本模式。</p>
<h1 id="0X02-指定分隔符和结尾"><a href="#0X02-指定分隔符和结尾" class="headerlink" title="0X02 指定分隔符和结尾"></a>0X02 指定分隔符和结尾</h1><p>我们可以使用这样一条语句打印多个字符串<code>print(&#39;hello&#39;, &#39;world&#39;, &#39;hello&#39;, &#39;python&#39;)</code>，会直接将字符串连接到一起，默认没有分隔符且使用系统默认作为结尾符号。可以给<code>print()</code>指定两个参数来设置分隔符和结尾符。<code>print(&#39;hello,&#39;, world&#39;, &#39;hello&#39;, &#39;python&#39;, sep=&#39;,&#39;, end=&#39;\n&#39;)</code>这里指定了使用逗号分隔开这些字符串，并且使用<code>\n</code>作为结尾符号。如果使用空字符串作为结尾符号，输出的时候最后就不自动换行。</p>
<h1 id="0X03-读写二进制文件"><a href="#0X03-读写二进制文件" class="headerlink" title="0X03 读写二进制文件"></a>0X03 读写二进制文件</h1><p>有一个最常见的二进制文件读写实例：从网上下载东西到本地。比如有一个url是<code>http://blog.just666.cn/usr/themes/Themia/img/sj/134.jpg</code>，那怎么把这个图片下载到本地呢？可以使用下面这段代码。先找到url，然后使用urlopen打开这个网络文件并获取到文件内容，最后用二进制模式写入到新的本地文件就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    web_img = urlopen(<span class="string">&#x27;http://blog.just666.cn/usr/themes/Themia/img/sj/134.jpg&#x27;</span>)	<span class="comment"># 使用urlopen打开一个url</span></span><br><span class="line">    web_img = web_img.read()	<span class="comment"># 获得文件内容，当然这里是二进制的所以没有可读性</span></span><br><span class="line">	<span class="comment"># 新打开一个文件，使用二进制写入模式</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;D:/hey.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:	<span class="comment"># 在w后面指定一个b也就是二进制写入模式</span></span><br><span class="line">        f.write(web_img)	<span class="comment"># 将新文件写入进去</span></span><br></pre></td></tr></table></figure>

<h1 id="0X04-路径名"><a href="#0X04-路径名" class="headerlink" title="0X04 路径名"></a>0X04 路径名</h1><p>在Python中可以使用<code>os.path</code>处理路径名的问题，比较常用的三个方法<code>os.path.basename()</code>、<code>os.path.dirname()</code>、<code>os.path.join()</code>，分别用来显示一个完整地址的最后文件名、显示某完整地址文件的目录地址、将目录和文件拼接起来。因为Python比较强大，所以可以做到容错效果，比如说在Windows中地址是这样的<code>D:\game\steam\steamapps\csgo</code>，但是如果我写成了Linux下的格式<code>D:/game/steam/steamapps/csgo</code>也是没有问题的，照样可以用这些方法处理，没有影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path = <span class="string">&#x27;/var/www/html/index.html&#x27;</span>	<span class="comment"># 这里是一个完整地址的文件</span></span><br><span class="line">    print(os.path.basename(path))		<span class="comment"># 可以显示文件名  index.html</span></span><br><span class="line">    print(os.path.dirname(path))		<span class="comment"># 可以显示当前文件的地址位置 /var/www/html/</span></span><br><span class="line">    print(os.path.join(<span class="string">&#x27;D:/&#x27;</span>, <span class="string">&#x27;hehe.exe&#x27;</span>))	<span class="comment"># 将连接拼起来编程 D:/hehe.exe</span></span><br></pre></td></tr></table></figure>

<h1 id="0X05-小技巧"><a href="#0X05-小技巧" class="headerlink" title="0X05 小技巧"></a>0X05 小技巧</h1><p>检验文件是否存在：<code>os.path.exists(&#39;D:/test.txt&#39;)</code>如果文件存在则返回True否则就是False<br>获取文件元数据：<code>os.path.getatime(&#39;D:/test.txt&#39;)</code>查看修改时间   <code>getsize</code>获取文件大小</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> I/O </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 奇技淫巧 (三) 函数]]></title>
      <url>/2017/01/21/python-magic-3/</url>
      <content type="html"><![CDATA[<blockquote>
<h5 id="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"><a href="#文章中的代码仅在Python3中测试成功，没有在Python2中测试。" class="headerlink" title="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"></a>文章中的代码仅在Python3中测试成功，没有在Python2中测试。</h5></blockquote>
<h1 id="0X00-任意个参数"><a href="#0X00-任意个参数" class="headerlink" title="0X00 任意个参数"></a>0X00 任意个参数</h1><p>Python中一般定义函数是这样的<code>def add(a, b)</code>，参数的个数是固定的，那么怎么才可以接收任意多个参数就像<code>rm 1.txt 2.jpg 3.mp3 4.cpp</code>这样？很简单，使用<code>*</code>和<code>**</code>就可以。下面代码里第一个参数a接收到了<code>hello,world</code>而<code>*b</code>则接收到了其余所有的参数，将其作为一个元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, *b</span>):</span></span><br><span class="line">    print(a)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x = add(<span class="string">&#x27;hello,world&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0X01-添加注解"><a href="#0X01-添加注解" class="headerlink" title="0X01 添加注解"></a>0X01 添加注解</h1><p>在Python中定义函数的同时可以也给函数添加注解，注解可以帮助我们在调用函数的时候起到一个提醒的作用。虽然几十行的代码不会遇到看不懂的情况，但是在修改别人代码或者编写一个大项目的时候必然会有这种问题。我们可以直接在代码中加注释来解释说明，但是使用注解还是要比注释来得简单方便。不过通过注解注解指定的类型不像是C语言那样有实际意义，就算是你传入的参数和返回的值不是按照注解来的也不会报错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a: int, b: int</span>) -&gt; int:</span>	<span class="comment"># 这里声明了a和b都是int型，返回值也是int型</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(add(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h1 id="0X02-默认参数"><a href="#0X02-默认参数" class="headerlink" title="0X02 默认参数"></a>0X02 默认参数</h1><p>我们常用的一些内置函数是有好多个可选参数的，不过我们不需要每个参数都要传入，因为Python可以给参数设置默认值，如果没有传入那个参数就会选择使用默认值，比如下面这个<code>add</code>函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a = <span class="number">3</span>, b = <span class="number">5</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(add())		<span class="comment"># 没有任何参数，默认使用３和５，最后结果则为8</span></span><br><span class="line">    print(add(<span class="number">1</span>))		<span class="comment"># 传入了参数a为1，最后结果则为6</span></span><br><span class="line">    print(add(<span class="number">4</span>, <span class="number">6</span>))	<span class="comment"># 传入了参数a和b分别为4和6，最后结果为10</span></span><br><span class="line">	print(add(b = <span class="number">3</span>))	<span class="comment"># 值传入了b参数为3，所以最后结果为6</span></span><br><span class="line">	print(add(b = <span class="number">3</span>, a = <span class="number">10</span>))	<span class="comment"># 指定参数的话也可以不按顺序</span></span><br></pre></td></tr></table></figure>

<h1 id="0X03-函数mini-匿名函数"><a href="#0X03-函数mini-匿名函数" class="headerlink" title="0X03 函数mini 匿名函数"></a>0X03 函数mini 匿名函数</h1><p>这里称之为匿名函数感觉还是有点别扭，因为这儿定义的函数并不是真的匿名，也是有名字的，因为函数自身非常短小倒不如称之为函数mini。在Python中有一个关键字<code>lambda</code>，可以定义一个匿名函数，使用这个关键字定义函数的时候函数声明、返回值、函数体只能写成一行。这样的函数功能肯定不能很强大，不过确实能减少代码量，少写好多重复的代码。正式代码的第一行就定义了一个函数，名为add，参数是x和y，返回值是x+y。所以说标准是这样的<code>函数名 = lambda 参数 ： 返回值</code>。这里还有个例子：<code>my_sqrt = lambda x : math.sqrt(x)</code>。注意，在匿名函数里什么<code>if-else</code>、<code>while</code>、<code>try-except</code>都是不能用的，总之你的函数就只能写一行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    add = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line">    print(add(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">    print(add(<span class="number">2</span>, <span class="number">7</span>))</span><br><span class="line">    print(add(<span class="number">1</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Function </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 奇技淫巧 (二) 字符串、文本]]></title>
      <url>/2017/01/19/python-magic-2/</url>
      <content type="html"><![CDATA[<blockquote>
<h5 id="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"><a href="#文章中的代码仅在Python3中测试成功，没有在Python2中测试。" class="headerlink" title="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"></a>文章中的代码仅在Python3中测试成功，没有在Python2中测试。</h5></blockquote>
<h1 id="0X00-split升级"><a href="#0X00-split升级" class="headerlink" title="0X00 split升级"></a>0X00 split升级</h1><p>字符串有一个<code>split</code>方法，可以用某个字符或字符串把源字符串切开。但是存在一个弊端，切割位置是固定的，不能灵活切割。有这样一个需求，将这个字符串<code>hello 1 wrld 2 python 3 linux</code>切割开，以每个数字为分隔符。这样标准的<code>str.split</code>就不能完成任务了。但是在<code>re</code>模块中有一个<code>re.split</code>可以完成这任务。这个方法的分隔符不是使用准确不变的字符/串而是使用正则表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_str = <span class="string">&#x27;hello 1 wrld 2 python 3 linux&#x27;</span></span><br><span class="line">    res = re.split(<span class="string">&#x27;[0-9]&#x27;</span>, my_str)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>
<p>这里使用的正则表达式就是普通的字符串形式，而不需要<code>re.compile</code>进行编译。有了这个方法就可以更加灵活地切割字符串了。</p>
<a id="more"></a>

<h1 id="0X01-字符串开头结尾的匹配"><a href="#0X01-字符串开头结尾的匹配" class="headerlink" title="0X01 字符串开头结尾的匹配"></a>0X01 字符串开头结尾的匹配</h1><p>当我们有一堆的url，想在url中找到http开头且.jpg结尾的图片文件，以前我总是直接<code>str.strip(&#39;http://&#39;) == str</code>来判断开头是不是’http://‘但是这样太蠢了，而且也不是很靠谱、因为万一开头不是而结尾是的话就会误判。这里有两个方法可以非常简单地做出这种判断：<code>str.startswith()</code>和<code>str.endswitch()</code>两个。一个是用来判断字符串是否以xxx开头、另一个是用来判断字符串是否以xxx结尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = <span class="string">&#x27;http://blog.just666.cn/img/01.jpg&#x27;</span></span><br><span class="line">    print(url.startswith(<span class="string">&#x27;http://&#x27;</span>))</span><br><span class="line">    print(url.endswith(<span class="string">&#x27;.jpg&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这种方式可以有一个简单的改变，使用列表推导式来批量判断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_list = [<span class="string">&#x27;http://hey.sdf.we/sdfw.jpg&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;http://asdf.ser.x/zxvw.jpg&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;http://sdf.re.xcv/ind.html&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;http://zx.er.cxv/held.html&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;http://zx.sdf.vs/hell.jpg&#x27;</span>]</span><br><span class="line">	<span class="comment"># 这里是列表推导式</span></span><br><span class="line">    jpg_list = [jpg <span class="keyword">for</span> jpg <span class="keyword">in</span> url_list <span class="keyword">if</span> jpg.endswith(<span class="string">&#x27;.jpg&#x27;</span>)]</span><br><span class="line">    print(jpg_list)</span><br></pre></td></tr></table></figure>
<p>也可以将后两行换成<code>print(all(jpg.startswith(&#39;.jpg&#39;) for jpg in url_list))</code>就会输出<code>False</code>因为并不是所有都以’.jpg’结尾。<br>还可以使用匹配的方式，比如你需要在N多url中找到’http/ftp’这两个协议的url，可以这么写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    choices = [<span class="string">&#x27;http://&#x27;</span>, <span class="string">&#x27;ftp://&#x27;</span>]</span><br><span class="line">    choices = tuple(choices)	<span class="comment"># 这里必须要使用元组类型</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">    print(url.startswith(choices))</span><br><span class="line"></span><br><span class="line">    url = <span class="string">&#x27;ftp://192.168.1.2&#x27;</span></span><br><span class="line">    print(url.startswith(choices))</span><br><span class="line"></span><br><span class="line">    url = <span class="string">&#x27;https://www.taoba.com&#x27;</span></span><br><span class="line">    print(url.startswith(choices))</span><br></pre></td></tr></table></figure>
<p><code>startswith</code>和<code>endswitch</code>两个函数完全可以被正则表达式替代，但是对于简单匹配来说没必要用正则表达式，这两个函数比正则要快且可读性搞书写快。</p>
<h1 id="0X02-Shell通配符"><a href="#0X02-Shell通配符" class="headerlink" title="0X02 Shell通配符"></a>0X02 Shell通配符</h1><p>在匹配字符串的时候不仅可以使用比较复杂的正则表达式，还可以用比较简单的通配符。使用通配符需要注意的一个问题就是大小写。在Linux/Unix/Mac上要区分大小写，在Windows上不区分大小写。<code>fnmatch</code>下有两个方法，<code>fnmatch</code>按操作系统来判断到底区不区分大小写，而<code>fnmatchcase</code>则强制区分大小写。使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch, fnmatchcase</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filename = <span class="string">&#x27;hello.c&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(filename, <span class="string">&#x27;*.c&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(filename, <span class="string">&#x27;hell?.c&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(filename, <span class="string">&#x27;hellO.c&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(filename, <span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h1 id="0X03-查找替换"><a href="#0X03-查找替换" class="headerlink" title="0X03 查找替换"></a>0X03 查找替换</h1><p>将字符串A中所有的某个子字符串B替换为另外的字符串C，可以简单的使用字符串的<code>replace</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    text = <span class="string">&#x27;hello world hello python&#x27;</span></span><br><span class="line">    print(text.replace(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hey&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>还有一种使用<code>re</code>模块的方案，可以使用正则匹配来查找并替换。<code>re.sub()</code>方法可以做到这一点。这里sub的第一个参数是匹配的正则表达式，第二个参数是替换的字符串（其中\1 \2 \3表示匹配的编号），第三个参数就是待匹配替换的字符串了。这个例子将<code>1/19/2017</code>转变为<code>2017/1/19</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    text = <span class="string">&#x27;hello world 1/19/2017&#x27;</span></span><br><span class="line">    print(re.sub(<span class="string">r&#x27;(\d+)/(\d+)/(\d+)&#x27;</span>, <span class="string">r&#x27;\3-\1-\2&#x27;</span>, text))</span><br></pre></td></tr></table></figure>


<h1 id="0X04-Unicode大法好"><a href="#0X04-Unicode大法好" class="headerlink" title="0X04 Unicode大法好"></a>0X04 Unicode大法好</h1><p>我们有的时候会遇到一些奇怪的字符串问题，比如看起来明明完全一样的两个字符串在对比的时候居然不相等。得益于Python3使用的Unicode我们可以简单的对字符串统一规范。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s1 = <span class="string">&#x27;char: \u00f1&#x27;</span></span><br><span class="line">    s2 = <span class="string">&#x27;char: n\u0303&#x27;</span></span><br><span class="line">    print(s1)</span><br><span class="line">    print(s2)</span><br><span class="line">    print(s1 == s2, <span class="string">&#x27;   &#x27;</span>, len(s1), <span class="string">&#x27;   &#x27;</span>, len(s2))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改一下编码</span></span><br><span class="line">    s1 = unicodedata.normalize(<span class="string">&#x27;NFC&#x27;</span>, s1)</span><br><span class="line">    s2 = unicodedata.normalize(<span class="string">&#x27;NFC&#x27;</span>, s2)</span><br><span class="line">    print(s1)</span><br><span class="line">    print(s2)</span><br><span class="line">    print(s1 == s2, <span class="string">&#x27;   &#x27;</span>, len(s1), <span class="string">&#x27;   &#x27;</span>, len(s2))</span><br></pre></td></tr></table></figure>
<p>这里面用到的那个奇怪的字符我也不知道是什么，是在《Python Cookbok》这本书上找的例子。就是说看起来<code>\u00f1</code>这个字符和<code>n\u0303</code>是一样的，但是很明显前者是一个字符而后者是两个字符，所以我们在对比的时候才会出现字符串不相同甚至长度不同的问题。然后引入了<code>unicodedata</code>模块之后用里面的<code>normalize</code>方法可以将字符串规范化，<code>s1 = unicodedata.normalize(&#39;NFC&#39;, s1)</code>就是将s1采用NFC方式规范。所谓NFC方式就是 <strong>全组成</strong> 也就是说“如果可能的话就是用单个代码点，也就是s1那种方式”（这里和近场通讯的NFC很明显没半点关系）。可选的除了NFC还有NFD（尽量使用组合字符，也就是s2那种方式），还支持NFKC和NFKD这里就自行Google一下吧。</p>
<h1 id="0X05-字符串对齐"><a href="#0X05-字符串对齐" class="headerlink" title="0X05 字符串对齐"></a>0X05 字符串对齐</h1><p>有的时候我们需要对字符串进行对齐操作，比如在终端中模拟界面之类的。可以使用C语言风格的%10S这种去替代，但是有更好用简单的方法，就是使用字符串内置的<code>ljust/rjust/center</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    text = <span class="string">&#x27;Main Menu&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;左对齐：&#x27;</span>, text.ljust(<span class="number">30</span>))</span><br><span class="line">    print(<span class="string">&#x27;右对齐：&#x27;</span>, text.rjust(<span class="number">30</span>))</span><br><span class="line">    print(<span class="string">&#x27;中对齐：&#x27;</span>, text.center(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;左对齐填充：&#x27;</span>, text.ljust(<span class="number">30</span>, <span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">    print(<span class="string">&#x27;右对齐填充：&#x27;</span>, text.rjust(<span class="number">30</span>, <span class="string">&#x27;=&#x27;</span>))</span><br><span class="line">    print(<span class="string">&#x27;中对齐填充：&#x27;</span>, text.center(<span class="number">30</span>, <span class="string">&#x27;*&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>还有一个炫酷的融合函数叫<code>format</code>。这个函数接收两个参数，第一个参数是待处理字符串，第二个参数是选项。具体选项如下：其中’^’是居中，’&gt;’是右对齐，’&lt;’是左对齐，后面跟着的数字是宽度，对齐字符前面是填充字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    text = <span class="string">&#x27;Main Menu&#x27;</span></span><br><span class="line">    print(format(text, <span class="string">&#x27;&gt;20&#x27;</span>))</span><br><span class="line">    print(format(text, <span class="string">&#x27;&lt;20&#x27;</span>))</span><br><span class="line">    print(format(text, <span class="string">&#x27;^20&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    print(format(text, <span class="string">&#x27;-&gt;20&#x27;</span>))</span><br><span class="line">    print(format(text, <span class="string">&#x27;=&lt;20&#x27;</span>))</span><br><span class="line">    print(format(text, <span class="string">&#x27;*^20&#x27;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 奇技淫巧 (一) 列表、集合、字典]]></title>
      <url>/2017/01/15/python-magic-1/</url>
      <content type="html"><![CDATA[<blockquote>
<h3 id="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"><a href="#文章中的代码仅在Python3中测试成功，没有在Python2中测试。" class="headerlink" title="文章中的代码仅在Python3中测试成功，没有在Python2中测试。"></a>文章中的代码仅在Python3中测试成功，没有在Python2中测试。</h3></blockquote>
<h1 id="0X00-表达式"><a href="#0X00-表达式" class="headerlink" title="0X00 *表达式"></a>0X00 *表达式</h1><p>从某个可迭代对象中分解出N个元素，但是这个可迭代的对象可能会超过N，会出现too many values to unpack异常。</p>
<p>比如我这儿有N个统计信息，因为第一次和最后一次的信息不准确需要删除掉，而将中间的信息保留下来，那么就可以这么弄。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    grade = [<span class="number">23</span>, <span class="number">45</span>, <span class="number">42</span>, <span class="number">45</span>, <span class="number">78</span>, <span class="number">98</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">69</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">50</span>, <span class="number">65</span>, <span class="number">99</span>, <span class="number">98</span>]</span><br><span class="line">    first, *new_grade, last = grade</span><br><span class="line">    print(new_grade)</span><br></pre></td></tr></table></figure>
<p>这里的赋值就是将第一个和最后一个赋给了first和last，而中间的给了new_grade</p>
<a id="more"></a>

<h1 id="0X01-定长队列"><a href="#0X01-定长队列" class="headerlink" title="0X01 定长队列"></a>0X01 定长队列</h1><p>有一种情况：程序在运行的时候会记录日志，比如说web程序的访问历史。如果我们需要只保留最后的1W条数据，那么很快能想到使用一个列表，每次插入数据的时候判断长度，然后对应的append和del。但是有一个更简单且更快速的方法就是使用<code>collections.deque()</code>。下面的例子中有一个1024长的列表，我们列表里只存最新的7条。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入一个包</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	<span class="comment"># 当做一种数据解雇来用就可以</span></span><br><span class="line">    auto_queue = collections.deque(maxlen=<span class="number">7</span>)</span><br><span class="line">    my_list = range(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> my_list:</span><br><span class="line">        auto_queue.append(i)</span><br><span class="line">    print(auto_queue)</span><br></pre></td></tr></table></figure>
<p>运行之后可以看到，列表里只保存了最后插入的七条数据。</p>
<h1 id="0X02-最大最小的几个元素"><a href="#0X02-最大最小的几个元素" class="headerlink" title="0X02 最大最小的几个元素"></a>0X02 最大最小的几个元素</h1><p>当我们有一个列表，需要找到列表里最大的N个元素时，一般会想到先排序然后分片，这想法当然不多，但是还有一个更好用的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_list = [<span class="number">34</span>, <span class="number">234</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">345</span>, <span class="number">456</span>, <span class="number">23</span>, <span class="number">213</span>, <span class="number">456</span>, <span class="number">8</span>, <span class="number">98</span>, <span class="number">43</span>, <span class="number">2</span>, <span class="number">67</span>]</span><br><span class="line">    print(<span class="string">&#x27;max: &#x27;</span>, heapq.nlargest(<span class="number">3</span>,  my_list))	<span class="comment"># 找到最大的三个</span></span><br><span class="line">    print(<span class="string">&#x27;min: &#x27;</span>, heapq.nsmallest(<span class="number">2</span>, my_list)) <span class="comment"># 找到最小的两个</span></span><br></pre></td></tr></table></figure>
<p>我这里用列表来演示，但是这个方法支持更复杂的数据结构。比如我有一个列表，列表里包含很多个字典，字典里是学生考试信息，那么我就可以用考试分数来找到前三名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_list = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;grade&#x27;</span>: <span class="number">56</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;grade&#x27;</span>: <span class="number">87</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小刚&#x27;</span>, <span class="string">&#x27;grade&#x27;</span>: <span class="number">67</span>&#125;,</span><br><span class="line">               &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小志&#x27;</span>, <span class="string">&#x27;grade&#x27;</span>: <span class="number">46</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小逗逼&#x27;</span>, <span class="string">&#x27;grade&#x27;</span>: <span class="number">99</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小华&#x27;</span>, <span class="string">&#x27;grade&#x27;</span>: <span class="number">85</span>&#125;,]</span><br><span class="line">    print(<span class="string">&#x27;max: &#x27;</span>, heapq.nlargest(<span class="number">3</span>,  my_list, key=<span class="keyword">lambda</span> s: s[<span class="string">&#x27;grade&#x27;</span>]))</span><br><span class="line">    print(<span class="string">&#x27;min: &#x27;</span>, heapq.nsmallest(<span class="number">3</span>, my_list, key=<span class="keyword">lambda</span> s: s[<span class="string">&#x27;grade&#x27;</span>]))</span><br></pre></td></tr></table></figure>
<p>key 后面的 <code>lambda s: s[&#39;grade&#39;]</code>是用了一个 <strong>匿名函数</strong> 。列表里唯一的值就是排序的关键字。更多关于<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431843456408652233b88b424613aa8ec2fe032fd85a000">更多关于匿名函数</a></p>
<p>如果N相对总数据量来说很小，可以用<code>heapq.heapify()</code>获得更好的性能。这个函数会将原来的集合转变成列表并以 <strong>堆</strong> 的形式排序。而堆最重要的一个特性就是最小的那个元素一定在第一位。所以我们可以利用这个性质来获取最小的前N个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_list = [<span class="number">234</span>, <span class="number">324</span>, <span class="number">456</span>, <span class="number">567</span>, <span class="number">345</span>, <span class="number">23</span>, <span class="number">546</span>, <span class="number">567</span>, <span class="number">98</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="number">576</span>]</span><br><span class="line">    heapq.heapify(my_list)</span><br><span class="line">    print(my_list)	<span class="comment"># 查看排序结果</span></span><br><span class="line">    print(heapq.heappop(my_list))	<span class="comment"># 取第一个元素，并重拍</span></span><br><span class="line">    print(heapq.heappop(my_list))</span><br><span class="line">    print(heapq.heappop(my_list))</span><br></pre></td></tr></table></figure>

<h1 id="0X03-优先级队列"><a href="#0X03-优先级队列" class="headerlink" title="0X03 优先级队列"></a>0X03 优先级队列</h1><p>普通队列都是按照FIFO(first in first out)来增删数据，有些特殊情况需要给每个元素设定优先级，push元素的时候设定优先级，pop的时候找到优先级最高的。比如说操作系统的任务调度就是这样的，会给每个进程设置优先级。不过当然，不会使用Python实现的了。这里的内部也是用堆来实现的，所以在15行的位置用了<code>-priority</code>来让堆反向排、</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个类就是队列类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._queue = []    <span class="comment"># 队列元素</span></span><br><span class="line">        self._index = <span class="number">0</span>     <span class="comment"># 索引</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item, priority</span>):</span></span><br><span class="line">        heapq.heappush(self._queue, (-priority, self._index, item))</span><br><span class="line">        self._index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(self._queue)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列中的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name    <span class="comment"># 只有一个属性、name</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Item(&#123;!r&#125;)&#x27;</span>.format(self.name)   <span class="comment"># 将格式化好的字符串返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_queue = PriorityQueue()  <span class="comment"># 实例化一个优先级队列</span></span><br><span class="line">    my_queue.push(Item(<span class="string">&#x27;内核&#x27;</span>), <span class="number">99</span>)   <span class="comment"># 内核的优先级最高了</span></span><br><span class="line">    my_queue.push(Item(<span class="string">&#x27;文件复制&#x27;</span>), <span class="number">40</span>)</span><br><span class="line">    my_queue.push(Item(<span class="string">&#x27;CS:GO&#x27;</span>), <span class="number">75</span>)</span><br><span class="line">    print(my_queue.pop())   <span class="comment"># 找到优先级最高的</span></span><br></pre></td></tr></table></figure>

<h1 id="0X04-一键多值"><a href="#0X04-一键多值" class="headerlink" title="0X04 一键多值"></a>0X04 一键多值</h1><p>我们可以轻松的写出用一个键对应多个值的字典，只需要让键对应到列表或者集合就好了，但是要啰里啰嗦写一大堆东西。其实可以用一个内建的方法来解决这个问题。通过这个方法可以快速创建这种字典，也可以像操作普通列表一样操作里面的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_dic = defaultdict(list)</span><br><span class="line">    my_dic[<span class="string">&#x27;name&#x27;</span>].append(<span class="string">&#x27;李华&#x27;</span>)</span><br><span class="line">    my_dic[<span class="string">&#x27;qq&#x27;</span>].append(<span class="string">&#x27;66666&#x27;</span>)</span><br><span class="line">    my_dic[<span class="string">&#x27;qq&#x27;</span>].append(<span class="string">&#x27;23333&#x27;</span>)</span><br><span class="line">    my_dic[<span class="string">&#x27;qq&#x27;</span>].append(<span class="string">&#x27;88888&#x27;</span>)</span><br><span class="line">    print(my_dic)</span><br></pre></td></tr></table></figure>

<h1 id="0X05-分片命名"><a href="#0X05-分片命名" class="headerlink" title="0X05 分片命名"></a>0X05 分片命名</h1><p>Python中分片非常好用，有的时候会在程序中出现很多分片，管理起来特别麻烦。可以通过这种方式给分片命名，下次再次调用的时候可以直接使用分片的名字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = <span class="string">&#x27;shawn 17 M&#x27;</span></span><br><span class="line">    name = slice(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    age  = slice(<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">    sex  = slice(<span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">    print(data[name])</span><br><span class="line">    print(data[age])</span><br><span class="line">    print(data[sex])</span><br></pre></td></tr></table></figure>

<h1 id="0X06-词频统计"><a href="#0X06-词频统计" class="headerlink" title="0X06 词频统计"></a>0X06 词频统计</h1><p>从一个序列中找到出现次数最多的元素。<code>Counter</code>对象还可以进行简单的加减，比如a序列里出现了10次’hello’而b序列里出现了3次’hello’，那么a+b的话’hello’的值就会变成13。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;hey&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;hey&#x27;</span>, <span class="string">&#x27;york&#x27;</span>, <span class="string">&#x27;hey&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line">    word_count = Counter(data)</span><br><span class="line">    print(word_count.most_common(<span class="number">1</span>))	<span class="comment"># 这个参数1可以更改，表示的是出现次数最多的几个元素</span></span><br></pre></td></tr></table></figure>

<h1 id="0X07-对字典列表排序"><a href="#0X07-对字典列表排序" class="headerlink" title="0X07 对字典列表排序"></a>0X07 对字典列表排序</h1><p>比如我们从数据库中查询到了部分学生的成绩，每个学生的信息存成一个字典，多个字典组成一个列表。然后需要让列表按学生成绩排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    student = [</span><br><span class="line">        &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;mark&#x27;</span>: <span class="number">98</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;mark&#x27;</span>: <span class="number">87</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;小刚&#x27;</span>, <span class="string">&#x27;mark&#x27;</span>: <span class="number">58</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;李华&#x27;</span>, <span class="string">&#x27;mark&#x27;</span>: <span class="number">100</span>&#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    student = sorted(student, key=itemgetter(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> student:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>

<h1 id="0X08-筛选序列"><a href="#0X08-筛选序列" class="headerlink" title="0X08 筛选序列"></a>0X08 筛选序列</h1><p>有一个列表，里面全是某次考试的成绩，需要成绩列表中找到所有的不及格成绩。可以轻松写出：定义空列表，for遍历成绩单，判断&lt;60的就append。但是还有一个更方便的方案，就是使用 <strong>列表推导式</strong> 来完成。<a href="https://eastlakeside.gitbooks.io/interpy-zh/content/Comprehensions/list-comprehensions.html">更多关于列表推导式</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_list = [<span class="number">34</span>, <span class="number">56</span>, <span class="number">67</span>, <span class="number">78</span>, <span class="number">95</span>, <span class="number">23</span>, <span class="number">96</span>, <span class="number">23</span>, <span class="number">86</span>, <span class="number">78</span>, <span class="number">89</span>, <span class="number">45</span>]</span><br><span class="line">    print([n <span class="keyword">for</span> n <span class="keyword">in</span> my_list <span class="keyword">if</span> n &lt;= <span class="number">60</span>])</span><br></pre></td></tr></table></figure>

<p>也可以用同样的方式来从字典中筛选子字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mark_list = &#123;</span><br><span class="line">        <span class="string">&#x27;小明&#x27;</span>: <span class="number">58</span>,</span><br><span class="line">        <span class="string">&#x27;小红&#x27;</span>: <span class="number">94</span>,</span><br><span class="line">        <span class="string">&#x27;小刚&#x27;</span>: <span class="number">67</span>,</span><br><span class="line">        <span class="string">&#x27;小智&#x27;</span>: <span class="number">76</span>,</span><br><span class="line">        <span class="string">&#x27;小亮&#x27;</span>: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unpass = &#123;key:value <span class="keyword">for</span> key, value <span class="keyword">in</span> mark_list.items() <span class="keyword">if</span> value &lt; <span class="number">60</span>&#125;</span><br><span class="line">    print(unpass)</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Dictionary </tag>
            
            <tag> List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python的实例方法、静态方法、类方法]]></title>
      <url>/2017/01/01/python-function/</url>
      <content type="html"><![CDATA[<h1 id="0X00-实例方法"><a href="#0X00-实例方法" class="headerlink" title="0X00 实例方法"></a>0X00 实例方法</h1><p>Python中的实例方法是在面向对象编程中用到的最多的方法类型了。 <strong>实例方法</strong> 从字面理解就可以，就是说这个方法是属于实例的。每次实例化一个对象出来，这个对象都会拥有这个方法。从下面代码中就可以看得出来，这里我定义了一个实例方法’get_name()’，定义实例方法不需要任何特殊的修饰符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一个实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = Student()</span><br><span class="line">    a.name = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">    <span class="keyword">print</span> a.get_name()</span><br><span class="line">    b = Student()</span><br><span class="line">    b.name = <span class="string">&#x27;小红&#x27;</span></span><br><span class="line">    <span class="keyword">print</span> b.get_name()</span><br></pre></td></tr></table></figure>
<p>从运行结果可以看出来，针对每一个实例，调用实例方法的输出是不同的，也就可以证明这个方法是属于某个实例的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明</span><br><span class="line">小红</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0X01-静态方法"><a href="#0X01-静态方法" class="headerlink" title="0X01 静态方法"></a>0X01 静态方法</h1><p>静态方法用的也很多，比如我们写正则表达式的时候经常会用到表达式的编译，一般都是这么写的’re.compile()’这里就是一个静态方法。可以看到我们在调用编译方法的时候是并没有实例化一个re对象的。所以可以知道 <strong>静态方法</strong> 就是不需要实例化对象即可调用的方法。下面有一个例子，例子中还是上面的Student类，但是定义了一个静态方法’say_hello()’，因为这是一个静态方法，所以不需要实例化对象即可调用。正因为这些特点，在定义静态方法的时候没有一个默认的参数self。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里使用装饰器定义了一个静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Student.say_hello()</span><br></pre></td></tr></table></figure>
<p>运行结果如下。我个人觉得静态方法的最大作用就是实现一些工具类，比如某些固定的重复的操作之类的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,world</span><br></pre></td></tr></table></figure>

<h1 id="0X02-类方法"><a href="#0X02-类方法" class="headerlink" title="0X02 类方法"></a>0X02 类方法</h1><p>使用类方法需要弄清楚类中属性的种类。类里有两种属性，一种是 <strong>类属性</strong> 一种是 <strong>实例属性</strong> 。顾名思义，类属性就是说这个属性是属于类的，这个类的所有实例共享着一个属性。实例属性就是属于实例的属性，每个实例的实例属性间不共享。下面这个例子里可以看到，类属性和实例属性是可以重名的，但是调用的时候要用’cls’或者’self’来制定到底调用的是哪个属性。下面的例子中有一个类属性’name’和一个实例属性’name’。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="comment"># 声明并赋值了一个类属性</span></span><br><span class="line">    name = <span class="string">&#x27;默认的类属性&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&#x27;默认的对象属性&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_class_name</span>(<span class="params">cls</span>):</span></span><br><span class="line">        cls.name = <span class="string">&#x27;修改的对象属性&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_object_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&#x27;修改的对象属性&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_class_name</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = Student()</span><br><span class="line">    <span class="keyword">print</span> a.get_class_name()</span><br><span class="line">    <span class="keyword">print</span> a.get_object_name()</span><br><span class="line">    a.set_class_name()</span><br><span class="line">    a.set_object_name()</span><br><span class="line">    <span class="keyword">print</span> a.get_class_name()</span><br><span class="line">    <span class="keyword">print</span> a.get_object_name()</span><br></pre></td></tr></table></figure>
<p>通过运行结果可以清晰地看出类属性的使用方式。运行结果如下。首先实例化一个对象，获取了a的实例属性和Student的类属性，然后调用了实例方法和类方法对两个属性重新赋值，最后再输出一次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认的类属性</span><br><span class="line">默认的对象属性</span><br><span class="line">修改的对象属性</span><br><span class="line">修改的对象属性</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> OOP </tag>
            
            <tag> Instance Method </tag>
            
            <tag> Static Method </tag>
            
            <tag> Class Method </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决Linux下MySQL/MariaDB中文变问号？问题]]></title>
      <url>/2016/12/15/linux-mysql-chinese/</url>
      <content type="html"><![CDATA[<h1 id="0X00-修改配置文件"><a href="#0X00-修改配置文件" class="headerlink" title="0X00 修改配置文件"></a>0X00 修改配置文件</h1><p>MySQL/MariaDB默认并没有采用utf-8编码，所以我们要修改配置文件，以让其使用utf-8。<br><code>/etc/my.cnf</code>就是配置文件，打开之后在<code>[mysqld]</code>下面加入两行，使其变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br></pre></td></tr></table></figure>
<p>修改好配置文件之后重启服务</p>
<a id="more"></a>

<h1 id="0X01-修改数据库的字符集"><a href="#0X01-修改数据库的字符集" class="headerlink" title="0X01 修改数据库的字符集"></a>0X01 修改数据库的字符集</h1><p>在修改配置文件之后新建的数据库默认就是使用utf-8了，但是之前的还不是所以要修改一下。登录到数据库，在命令行界面修改数据库的字符集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> <span class="string">`databases_name`</span> <span class="keyword">COLLATE</span> <span class="string">&#x27;utf8_bin&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>再次重启数据库服务。这样再连接到数据库就解决掉汉字变问号的问题了</p>
<h1 id="0X02-推荐两款软件"><a href="#0X02-推荐两款软件" class="headerlink" title="0X02 推荐两款软件"></a>0X02 推荐两款软件</h1><p>大家好多人都在用Navicat，但绝大多数人用的都是盗版软件，这里推荐大家用一些好用的开源软件来替代。</p>
<h3 id="1-HeidiSQL"><a href="#1-HeidiSQL" class="headerlink" title="1 HeidiSQL"></a>1 HeidiSQL</h3><ol>
<li>一款开源软件</li>
<li>可以连接MySQL/MariaDB/SQL Server</li>
<li>官方中文支持</li>
</ol>
<p><a href="http://www.heidisql.com/">下载地址：HeidiSQL</a></p>
<h3 id="2-MySQL-Workbench"><a href="#2-MySQL-Workbench" class="headerlink" title="2 MySQL Workbench"></a>2 MySQL Workbench</h3><ol>
<li>一款开源软件</li>
<li>MySQL官方开发</li>
<li>导出表关系图非常强大</li>
</ol>
<p><a href="http://www.mysql.com/products/workbench/">下载地址：MySQL Workbench</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
            <tag> MariaDB </tag>
            
            <tag> Encodeing </tag>
            
            <tag> Chinese </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简述几种简单的页面置换算法]]></title>
      <url>/2016/12/15/page-swap/</url>
      <content type="html"><![CDATA[<h1 id="0X00-最优算法—不可能实现算法"><a href="#0X00-最优算法—不可能实现算法" class="headerlink" title="0X00 最优算法—不可能实现算法"></a>0X00 最优算法—不可能实现算法</h1><p>最优算法听起来很棒，但是 <strong>实现起来是不可能的</strong> 。最优算法是：当发生缺页中断时，将最晚会用到的页换出。也就是说，有三个页，现在发生了缺页中断，第一个页在第201条指令的时候会用到，第二个页在第5001条指令的时候会用到，第三个页在第20000条指令的时候会用到，那么第三个页面就是最晚会被用到的，就将其换出。这样确实是最好的效率，但是真正实现不了的原因是：程序不可能知道自己在什么时候需要哪些内存，所以就不能找到最晚会被用到的页。因为要用未来的事情来判断所以我一般称之为未来算法。虽说实现不了，也不是说这个算法就没意义了。这个算法最大的意义就在于可以比较效率。效率越是接近最优算法的就越好，当一个算法已经能达到最优算法效率的101%时，就没必要累死累活的去优化效率了，可以去找一些别的瓶颈了。</p>
<h1 id="0X01-最近未使用—NRU"><a href="#0X01-最近未使用—NRU" class="headerlink" title="0X01 最近未使用—NRU"></a>0X01 最近未使用—NRU</h1><p>如果说最优算法叫未来算法的话，那么这个最近未使用就可以叫做历史算法，这样就好理解了。当系统发生缺页中断的时候，在内存中找到最久没被用过的页，将其换出。有一种实现方法：给每一个页设置一个 <strong>R(read)位和M(modify)位</strong> 。当一个进程启动的时候将这个进程的所有页的RM位都设置为0。然后每访问一个页就将R位置为1，每修改一个页就将M置为1。系统每隔一段时间就将所有页的R置为0。那么这里就会出现四种页，其实这里只是一个表示，比如第1类。不可能出现一个没被访问就修改的页，但是第3类页经过一段时间之后将R置为0的话就是第1类了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类别   |    访问   |   修改    | R | M</span><br><span class="line">--------------------------------------</span><br><span class="line">第0类：| 没有被访问 | 没有被修改 | 0 | 0</span><br><span class="line">第1类：| 没有被访问 | 已经被修改 | 0 | 1</span><br><span class="line">第2类：| 已经被访问 | 没有被修改 | 1 | 0</span><br><span class="line">第3类：| 已经被访问 | 已经被修改 | 1 | 1</span><br><span class="line">--------------------------------------</span><br></pre></td></tr></table></figure>
<p>现在内存中的每个页都是这0到4的其中一种。那么当发生缺页中断的时候，NRU算法就会从类别编号最小的一堆页中 <strong>随机</strong> 换出。</p>
<a id="more"></a>
<h1 id="0X02-先进先出—队列置换算法-FIFO"><a href="#0X02-先进先出—队列置换算法-FIFO" class="headerlink" title="0X02 先进先出—队列置换算法 FIFO"></a>0X02 先进先出—队列置换算法 FIFO</h1><p>这种算法相对容易实现，就像是数据结构中的 <strong>队列</strong> 一样。每次的新页放在队列尾部，当发生缺页中断时将队列头部的页踢掉，将新页放到队列尾部。这种算法有一个非常严重的问题就是会踢掉一些必要的页，比如操作系统核心功能。想想系统启动的时候，首先加入了10000个页以用来运行操作系统，但是发生缺页中断的时候就会将核心页换出去，然后因为核心页被换出去了就需要再换进来，有可能就造成了连续10000个页从队首换到了队尾，产生了20000个操作。</p>
<h1 id="0X03-第二次机会—FIFO改进"><a href="#0X03-第二次机会—FIFO改进" class="headerlink" title="0X03 第二次机会—FIFO改进"></a>0X03 第二次机会—FIFO改进</h1><p>因为FIFO会将所有队尾直接踢出去，第二次机会就是给了每个页面再一次机会。也就是说：每个页面还是有一个R位，然后有一个时间位用来记录装入时间。每当发生缺页中断的时候查看队首页的R值，如果R值为0那么就将其换出，否则就将其R值设置为0，并设置‘装入时间’（在哪个时钟的时候装入的），然后再从队首的下一个页开始判断。</p>
<h1 id="0X04-时钟算法—CLOCK"><a href="#0X04-时钟算法—CLOCK" class="headerlink" title="0X04 时钟算法—CLOCK"></a>0X04 时钟算法—CLOCK</h1><p>因为二次机会算法还是基于单向链表的，所以会经常需要在链表中移动页面，虽然是在内存中操作但还是会浪费资源。这里就把单向链表改成了 <strong>环形链表</strong> 。当发生缺页中断的时候，检查指针指向的页面，如果页的R位是0则提出这个页面将新的页加到这个位置，并设置R位为1；否则就将当前的R位设置为0并将指针下移。所以时钟算法也可以理解成是第二次机会算法的改进版本。</p>
<p><img src="http://qiniu.just666.cn//article/image/clock.png" alt="时钟算法"></p>
<blockquote>
<p>图片来源：《现代操作系统》 Andrew S. Tanenbaum</p>
</blockquote>
<h1 id="0X05-最近最少使用置换算法—LRU"><a href="#0X05-最近最少使用置换算法—LRU" class="headerlink" title="0X05 最近最少使用置换算法—LRU"></a>0X05 最近最少使用置换算法—LRU</h1><p>有这样一种情况：“在前面几条指令中频繁使用的页很可能在后面的及条指令中被使用”，所以说已经很久没有用过的页很可能在未来的一段时间内也不会被用到。所以可以在发生缺页中断的时候将最久未使用的页替换出去。为了实现LRU算法需要将所有页串成一个链表，链表的一端是最常使用的页，另一端则是最不常用的页，每次调用一个页的时候都要将整个链表更新，但移动整个链表是很慢的。</p>
<p>可以通过特殊硬件来实现LRU。</p>
<p>第一种方案：这里需要一个64位的计数器，计数器在每条指令执行完成之后自动加一，且每个页表项中需要需要足够容纳这个计数器。在每次访问内存的时候将当前计数器的值赋值给该页表项的对应区域。当发生缺页中断的时候找到每个页表项中该值最小的，这个页表项就是最近最少使用的。</p>
<p>需要注意的一点是： <strong>这个计数器只有一个</strong> 而不是每个页表项一个；每个页表项里只是有一个可以容纳这个计数器的位置，也就是说要有一个64位的空间来保存数字。这里保存的数字不会随着指令的执行而自增，随着指令执行自增的就只有那个唯一的计数器。</p>
<p>第二种方案：假设某机器有n个页框，那么LRU硬件就是一个n * n的矩阵，初始化为零矩阵。当访问页框k时 <strong>先</strong> 将k行全部置1， <strong>再</strong> 将k列全部置0。在任意时间二进制数值最小的行就是最近最少使用的，第二小的就是下一个最近最少使用的。</p>
<h1 id="0X06-最不常用置换算法—NFU"><a href="#0X06-最不常用置换算法—NFU" class="headerlink" title="0X06 最不常用置换算法—NFU"></a>0X06 最不常用置换算法—NFU</h1><p>因为LRU算法需要独立的硬件设备，然而大多数计算机并没有这种硬件，所以需要一个能用软件实现的解决方案。这种成为NFU的最不常用置换算法就是一种使用软件模拟LRU的实现。在NFU中针对每一个页设置一个计数器，每当发生缺页中断时刷新所有的页对应的计数器，先将每一个页的R值（R值用来标识该页是否用过，为0或1）加到计数器上，再将R置0。这个计数器基本可以反映某个页的使用频率。当发生缺页中断的时候就可以踢出计数器最小的页。</p>
<p>这个算法的一大问题就是：记忆力太强。比如说我开机的时候开机相关的页可能调用了10万次，开机之后其他的东西并没有这么高的使用率，但是因为这些页的计数器太大了，所以不会被轻易踢出去，就会导致有一批‘元老页’滞留在内存中浪费空间。</p>
<p>可以通过一个简单的小修改解决这个问题：首先在R值加到计数器之前先将计数器右移一位（二进制移位，最后一位抛掉），其次将R位加入到计数器的最左端，而不是最右端（简单的NFU是加入到最右端的）。经过这种修改的算法称之为 <strong>老化算法</strong> 。因为这种算法中新的操作会对计数器产生较大的影响，可以让以前的计数器迅速变老，所以称为老化算法。</p>
]]></content>
      
        
        <tags>
            
            <tag> Operation System </tag>
            
            <tag> Virtual Memerry </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python使用threading实现多线程]]></title>
      <url>/2016/12/12/python-threading/</url>
      <content type="html"><![CDATA[<h1 id="0X00-多线程"><a href="#0X00-多线程" class="headerlink" title="0X00 多线程"></a>0X00 多线程</h1><p>多线程是个提高程序运行效率的好办法，本来要顺序执行的程序现在可以并行执行，可想而知效率要提高很多。但是多线程也不是能提高所有程序的效率。程序的两个极端是‘CPU密集型’和‘I/O密集型’两种，多线程技术比较适用于后者，因为在串行结构中当你去读写磁盘或者网络通信的时候CPU是闲着的，毕竟网络比磁盘要慢几个数量级，磁盘比内存慢几个数量级，内存又比CPU慢几个数量级。多线程技术就可以同时执行，比如你的程序需要发送N个http数据包（10秒），还需要将文件从一个位置复制到另一个位置（20秒），然后还需要统计另一个文件中’hello,world’字符串的出现次数（4秒），现在一共是要用34秒。但是因为这些操作之间没有关联，所以可以写成多线程程序，几乎只需要20秒就完成了。这是针对I/O密集型的，如果是CPU密集型的就不行了。比如我的程序要计算1000的阶乘（10秒），还要计算100000的累加（5秒），那么即使程序是并行的，还是会要用15秒，甚至更多。因为当程序使用CPU的时候CPU是通过轮转来执行的，IO密集型的程序可以在IO的同时用CPU计算，但是这里的CPU密集型就只能先执行一会儿线程1再执行一会儿线程2。所以就需要15秒，甚至会更多，因为CPU在切换的时候需要耗时。解决CPU密集型程序的多线程问题就是CPU的事情了，比如Intel的超线程技术，可以在同一个核心上真正的并行两个线程，所以称之为‘双核四线程’或者‘四核八线程’，我们这里具体的先不谈，谈我也不知道。</p>
<a id="more"></a>

<h1 id="0X01-Python骗人"><a href="#0X01-Python骗人" class="headerlink" title="0X01 Python骗人"></a>0X01 Python骗人</h1><p>说了这么多多线程的好处，但是其实Python不支持真正意义上的多线程编程。在Python中有一个叫做GIL的东西，中文是 <em>全局解释器锁</em> ，这东西控制了Python，让Python只能同时运行一个线程。相当于说真正意义上的多线程是由CPU来控制的，Python中的多线程由GIL控制。如果有一个CPU密集型程序，用C语言写的，运行在一个四核处理器上，采用多线程技术的话最多可以获得4倍的效率提升，但是如果用Python写的话并不会有提高，甚至会变慢，因为线程切换的问题。所以Python多线程相对更加适合写I/O密集型程序，再说了真正的对效率要求很高的CPU密集型程序都用C/C++去了。</p>
<h1 id="0X02-第一个多线程"><a href="#0X02-第一个多线程" class="headerlink" title="0X02 第一个多线程"></a>0X02 第一个多线程</h1><p>Python中多线程的库一般用<code>thread</code>和<code>threading</code>这两个，<code>thread</code>不推荐新手和一般人使用，<code>threading</code>模块就相当够用了。<br>有一个程序，如下。两个循环，分别休眠3秒和5秒，串行执行的话需要8秒。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_3</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_5</span>():</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;start sleep 3&#x27;</span></span><br><span class="line">    sleep_3()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;start sleep 5&#x27;</span></span><br><span class="line">    sleep_5()</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="keyword">print</span> str(end_time - start_time) + <span class="string">&#x27; s&#x27;</span></span><br></pre></td></tr></table></figure>
<p>输出是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start sleep 3</span><br><span class="line">start sleep 5</span><br><span class="line">8.00100016594 s</span><br></pre></td></tr></table></figure>
<p>然后我们对它进行修改，使其变成多线程程序，虽然改动没有几行。首先引入了threading的库，然后实例化一个threading.Thread对象，将一个函数传进构造方法就行了。然后调用Thread的start方法开始一个线程。join()方法可以等待该线程结束，就像我下面用的，如果我不加那两个等待线程结束的代码，那么就会直接执行输出时间的语句，这样一来统计的时间就不对了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading    <span class="comment"># 引入threading</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_3</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep_5</span>():</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;start sleep 3&#x27;</span></span><br><span class="line">    thread_1 = threading.Thread(target=sleep_3)     <span class="comment"># 实例化一个线程对象，使线程执行这个函数</span></span><br><span class="line">    thread_1.start()        <span class="comment"># 启动这个线程</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;start sleep 5&#x27;</span></span><br><span class="line">    thread_2 = threading.Thread(target=sleep_5)     <span class="comment"># 实例化一个线程对象，使线程执行这个函数</span></span><br><span class="line">    thread_2.start()        <span class="comment"># 启动这个线程</span></span><br><span class="line">    thread_1.join()     <span class="comment"># 等待thread_1结束</span></span><br><span class="line">    thread_2.join()     <span class="comment"># 等待thread_2结束</span></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="keyword">print</span> str(end_time - start_time) + <span class="string">&#x27; s&#x27;</span></span><br></pre></td></tr></table></figure>
<p>执行结果是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start sleep 3</span><br><span class="line">start sleep 5</span><br><span class="line">5.00099992752 s</span><br></pre></td></tr></table></figure>

<h1 id="0X03-daemon-守护线程"><a href="#0X03-daemon-守护线程" class="headerlink" title="0X03 daemon 守护线程"></a>0X03 daemon 守护线程</h1><p>在我们理解中守护线程应该是很重要的，类比于Linux中的守护进程。但是在<code>threading.Thread</code>中偏偏不是。</p>
<blockquote>
<p>如果把一个线程设置为守护线程，就表示这个线程是不重要的，进程退出的时候不需要等待这个线程执行完成。 ———《Python核心编程 第三版》</p>
</blockquote>
<p>在Thread对象中默认所有线程都是非守护线程，这里有两个例子说明区别。这段代码执行的时候就没指定<code>my_thread</code>的<code>daemon</code>属性，所以默认为非守护，所以进程等待他结束。最后就可以看到100个hello,world</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_thread = threading.Thread(target=hello_world)</span><br><span class="line">    my_thread.start()</span><br></pre></td></tr></table></figure>
<p>这里设置了<code>my_thread</code>为守护线程，所以进程直接就退出了，并没有等待他的结束，所以我们看不到100个hello,world只有几个而已。甚至还会抛出一个异常告诉我们有线程没结束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_thread = threading.Thread(target=hello_world)</span><br><span class="line">    my_thread.daemon = <span class="literal">True</span>   <span class="comment"># 设置了标志位True</span></span><br><span class="line">    my_thread.start()</span><br></pre></td></tr></table></figure>

<h1 id="0X04-传个参数"><a href="#0X04-传个参数" class="headerlink" title="0X04 传个参数"></a>0X04 传个参数</h1><p>之前的代码都是直接执行一段代码，没有过参数的传递，那么怎么传递参数呢？其实还是很简单的。<code>threading.Thread(target=hello_world, args=(&#39;hello,&#39;, &#39;world&#39;))</code>就可以了。args后面跟的是一个元组，如果没有参数可以不写，如果有参数就直接在元组里按顺序添加就行了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>(<span class="params">str_1, str_2</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">print</span> str_1 + str_2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_thread = threading.Thread(target=hello_world, args=(<span class="string">&#x27;hello,&#x27;</span>, <span class="string">&#x27;world&#x27;</span>))    <span class="comment"># 这里传递参数</span></span><br><span class="line">    my_thread.start()</span><br></pre></td></tr></table></figure>


<h1 id="0X05-再来个多线程"><a href="#0X05-再来个多线程" class="headerlink" title="0X05 再来个多线程"></a>0X05 再来个多线程</h1><p>threading有三种创建Thread对象的方式，但是一般只会用到两种，一种是上面<code>0X02</code>说的传个函数进去，另一种就是这里说的继承<code>threading.Thread</code>。在这儿我们自己定义了两个类，类里重写了run()方法，也就是调用start()之后执行的代码，开启线程就和之前开启是一样的。之前的方式更面向过程，这个更面向对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadHello</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadWorld</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">&#x27;world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_hello = MyThreadHello()</span><br><span class="line">    thread_world = MyThreadWorld()</span><br><span class="line">    thread_hello.start()</span><br><span class="line">    thread_world.start()</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Thread </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下MariaDB/MySql的安装配置、用户管理和备份]]></title>
      <url>/2016/11/20/linux-mysql-dump/</url>
      <content type="html"><![CDATA[<h1 id="0x00-MariaDB的身世"><a href="#0x00-MariaDB的身世" class="headerlink" title="0x00  MariaDB的身世"></a>0x00  MariaDB的身世</h1><p>自从MySQL被Oracle收购之后，社区就一直担心MySQL可能会被闭源或者一些其他的原因导致MySQL的支持出现问题。所以现在好多发行版本默认的数据库都从MySQL转移到了Mariadb。而且社区也开始大力支持Mariadb，再加上Mariadb的使用和API和MySQL完全一样，所以这里选择使用Mariadb而不是MySQL。</p>
<blockquote>
<p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。<br>MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，10.0.9版起使用XtraDB（名称代号为Aria）来代替MySQL的InnoDB。<br>MariaDB由MySQL的创始人麦克尔·维德纽斯主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自麦克尔·维德纽斯的女儿玛丽亚（英语：Maria）的名字。——————————维基百科</p>
</blockquote>
<a id="more"></a>

<h1 id="0X01-安装Mariadb"><a href="#0X01-安装Mariadb" class="headerlink" title="0X01 安装Mariadb"></a>0X01 安装Mariadb</h1><p>MariaDB是一组软件，如果只安装一部分的话后期扩展可能会出现问题，所以我们可以一次安装整个软件组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># yum groupinstall mariadb mariadb-client -y</span></span><br></pre></td></tr></table></figure>
<p>安装需要一点时间，我们只需要等待安装结束。</p>
<h1 id="0X02-打开Mariadb服务并配置防火墙"><a href="#0X02-打开Mariadb服务并配置防火墙" class="headerlink" title="0X02 打开Mariadb服务并配置防火墙"></a>0X02 打开Mariadb服务并配置防火墙</h1><p>启动Mariadb服务。在CentOS7.x中推荐使用systemctl来配置服务的启动方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mariadb.service</span><br></pre></td></tr></table></figure>

<p>配置防火墙，允许从MariaDB使用的3306端口监听，由于历史遗留问题，这里还是称之为MySql。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># firewall-cmd --add-service=mysql</span></span><br><span class="line">success</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># firewall-cmd --list-services</span></span><br><span class="line">dhcpv6-client mysql ssh</span><br></pre></td></tr></table></figure>

<h1 id="0X03-配置MariaDB的安全性"><a href="#0X03-配置MariaDB的安全性" class="headerlink" title="0X03 配置MariaDB的安全性"></a>0X03 配置MariaDB的安全性</h1><p>MariaDB提供了一个脚本来为新安装的MariaDB提升安全性。但是在使用这个脚本之前必须要先打开MariaDB服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># systemctl start mariadb</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># systemctl enable mariadb</span></span><br><span class="line">ln -s <span class="string">&#x27;/usr/lib/systemd/system/mariadb.service&#x27;</span> <span class="string">&#x27;/etc/systemd/system/multi-user.target.wants/mariadb.service&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后运行这个脚本，这个脚本会有几次提示：</p>
<ol>
<li>询问当前密码，如果没设置密码就直接回车</li>
<li>设置root用户的密码</li>
<li>删除匿名用户(anonymous-user)</li>
<li>删除可以从外部登陆的root用户</li>
<li>删除test测试数据库</li>
<li>重载数据库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># mysql_secure_installation</span></span><br><span class="line">/usr/bin/mysql_secure_installation: line 379: find_mysql_client: <span class="built_in">command</span> not found</span><br><span class="line"></span><br><span class="line">NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB</span><br><span class="line">      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!</span><br><span class="line"></span><br><span class="line">In order to <span class="built_in">log</span> into MariaDB to secure it, we<span class="string">&#x27;ll need the current</span></span><br><span class="line"><span class="string">password for the root user.  If you&#x27;</span>ve just installed MariaDB, and</span><br><span class="line">you haven<span class="string">&#x27;t set the root password yet, the password will be blank,</span></span><br><span class="line"><span class="string">so you should just press enter here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter current password for root (enter for none):</span></span><br><span class="line"><span class="string">OK, successfully used password, moving on...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Setting the root password ensures that nobody can log into the MariaDB</span></span><br><span class="line"><span class="string">root user without the proper authorisation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Set root password? [Y/n] y</span></span><br><span class="line"><span class="string">New password:</span></span><br><span class="line"><span class="string">Re-enter new password:</span></span><br><span class="line"><span class="string">Password updated successfully!</span></span><br><span class="line"><span class="string">Reloading privilege tables..</span></span><br><span class="line"><span class="string"> ... Success!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">By default, a MariaDB installation has an anonymous user, allowing anyone</span></span><br><span class="line"><span class="string">to log into MariaDB without having to have a user account created for</span></span><br><span class="line"><span class="string">them.  This is intended only for testing, and to make the installation</span></span><br><span class="line"><span class="string">go a bit smoother.  You should remove them before moving into a</span></span><br><span class="line"><span class="string">production environment.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Remove anonymous users? [Y/n] y</span></span><br><span class="line"><span class="string"> ... Success!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Normally, root should only be allowed to connect from &#x27;</span>localhost<span class="string">&#x27;.  This</span></span><br><span class="line"><span class="string">ensures that someone cannot guess at the root password from the network.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Disallow root login remotely? [Y/n] y</span></span><br><span class="line"><span class="string"> ... Success!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">By default, MariaDB comes with a database named &#x27;</span><span class="built_in">test</span><span class="string">&#x27; that anyone can</span></span><br><span class="line"><span class="string">access.  This is also intended only for testing, and should be removed</span></span><br><span class="line"><span class="string">before moving into a production environment.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Remove test database and access to it? [Y/n] y</span></span><br><span class="line"><span class="string"> - Dropping test database...</span></span><br><span class="line"><span class="string"> ... Success!</span></span><br><span class="line"><span class="string"> - Removing privileges on test database...</span></span><br><span class="line"><span class="string"> ... Success!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Reloading the privilege tables will ensure that all changes made so far</span></span><br><span class="line"><span class="string">will take effect immediately.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Reload privilege tables now? [Y/n] y</span></span><br><span class="line"><span class="string"> ... Success!</span></span><br></pre></td></tr></table></figure>

<h1 id="0X04-登陆到MariaDB"><a href="#0X04-登陆到MariaDB" class="headerlink" title="0X04 登陆到MariaDB"></a>0X04 登陆到MariaDB</h1><p>配置好密码和接入点之后就可以登录到MariaDB了。使用mysql命令来登陆MariaDB。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># mysql -h localhost -u root -p</span></span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 12</span><br><span class="line">Server version: 5.5.50-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2016, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt;</span><br></pre></td></tr></table></figure>
<p>参数：-h 指定主机， -u 指定用户，　-p 指定密码<br>这三个参数都可以省略，当我们省略主机名的时候就默认登录到本地，当省略用户名的时候默认使用root，当省略密码的时候默认没有密码登陆</p>
<h1 id="0X05-用户管理"><a href="#0X05-用户管理" class="headerlink" title="0X05 用户管理"></a>0X05 用户管理</h1><p>在MariaDB中有用户的概念和权限的概念。用户名+密码+登陆地点，三个选项唯一确定一个用户，就比如同一个用户名<code>shawn</code>在10.13.1.2和在10.13.1.3的登陆密码可以是不同的，这在MariaDB里会分成两条来存储。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建一个名为shawn的，从localhost登陆的，密码为test的用户</span><br><span class="line">MariaDB [(none)]&gt; CREATE USER &#x27;shawn&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;test&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">创建一个名为shawn_test的，任意地点，密码为6666的用户</span><br><span class="line">MariaDB [(none)]&gt; CREATE USER &#x27;shawn_test&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;6666&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>而且在MariaDB中用户和权限是分开的，如果只添加一个用户的话，这个用户是没有任何权限的。</p>
<p>删除用户的话是使用<code>DROP</code>命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; DROP USER heiheihei@&#x27;localhost&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<h1 id="0X06-权限管理"><a href="#0X06-权限管理" class="headerlink" title="0X06 权限管理"></a>0X06 权限管理</h1><p>登录到MariaDB之后可以给用户添加具体的权限，使用<code>GRANT</code>命令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">允许从localhost登陆的shawn对mysql数据库的user表执行查询</span><br><span class="line">MariaDB [(none)]&gt; GRANT SELECT ON mysql.user to shawn@&#x27;localhost&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">允许从localhost登陆的shawn对mysql数据库的user表执行查询和插入</span><br><span class="line">MariaDB [(none)]&gt; GRANT SELECT, INSERT ON mysql.user to shawn@&#x27;localhost&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">允许从localhost登陆的shawn对mysql数据库的user表执行增删查改四种操作</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL ON mysql.user to shawn@&#x27;localhost&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">允许从localhost登陆的shawn对mysql数据库的所有表执行增删查改四种操作</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL ON mysql.* to shawn@&#x27;localhost&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">允许从localhost登陆的shawn对所有库的所有表执行增删查改四种操作</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL ON *.* to shawn@&#x27;localhost&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">允许从任意地点登陆的shawn对所有库的所有表执行增删查改四种操作</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL ON *.* to shawn@&#x27;%&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>使用<code>REVOKE</code>可以删除给定的权限，使用方法和<code>GRANT</code>是一样的，只是开头不同而已<br>使用<code>FLUSH PRIVILEGES;</code>可以刷新权限信息<br>使用<code>SHOW GRANT FOR root@localhost</code>可以查看某用户的权限信息</p>
<h1 id="0X07-数据库备份"><a href="#0X07-数据库备份" class="headerlink" title="0X07 数据库备份"></a>0X07 数据库备份</h1><p>MariaDB有逻辑备份和物理备份两种备份方案，逻辑备份就是可以把表结构数据等导出成sql文件，而物理备份就是直接备份文件。<br>逻辑备份比较慢，因为要将备份的数据全部都查询一遍，但是可以不下线备份；物理备份比较快，但是需要下线备份。这里说的是逻辑备份.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># mysqldump -u root -h localhost -p --all-databases &gt; backup.sql</span></span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure>
<p>这里我使用了一个<code>--all-databases</code>的参数，是备份所有数据库，可选的参数有下面这几个</p>
<ol>
<li><code>--all-databases</code>备份所有数据库</li>
<li><code>--add-drop-tables</code>生成的sql中包含drop tables语句，删除以前的table</li>
<li><code>--no-data</code>只生成库和表结构，没有数据</li>
<li><code>--lock-all-tables</code>在备份结束之前，锁定所有表，保证数据完整性</li>
<li><code>--add-drop-databases</code>生成的sql中包含drop database语句，删除以前的database</li>
</ol>
<h1 id="0X08-数据库还原"><a href="#0X08-数据库还原" class="headerlink" title="0X08 数据库还原"></a>0X08 数据库还原</h1><p>当我们有了一个备份出来的sql文件之后，可以将这个sql直接导入到数据库。这了的用法和之前登录到MariaDB的方法是一样的，只是将sql文件重定向过去就可以了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># mysql -u root -h localhost -p &lt; backup.sql</span></span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
            <tag> Service Configure </tag>
            
            <tag> MariaDB </tag>
            
            <tag> User Configure </tag>
            
            <tag> Data Dump </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS7中使用firewall-Cmd控制端口和端口转发]]></title>
      <url>/2016/11/17/firewall-cmd/</url>
      <content type="html"><![CDATA[<h1 id="0X00-firewalld-守护进程"><a href="#0X00-firewalld-守护进程" class="headerlink" title="0X00 firewalld 守护进程"></a>0X00 firewalld 守护进程</h1><p><code>firewall-cmd</code>命令需要<code>firewalld</code>进程处于运行状态。我们可以使用<code>systemctl status/start/stop/restart firewalld</code>来控制这个守护进程。<code>firewalld</code>进程为防火墙提供服务。</p>
<p>当我们修改了某些配置之后（尤其是配置文件的修改），firewall并不会立即生效。可以通过两种方式来激活最新配置<code>systemctl restart firewalld</code>和<code>firewall-cmd --reload</code>两种方式，前一种是重启firewalld服务，建议使用后一种“重载配置文件”。重载配置文件之后不会断掉正在连接的tcp会话，而重启服务则会断开tcp会话。</p>
<a id="more"></a>

<h1 id="0X01-控制端口-服务"><a href="#0X01-控制端口-服务" class="headerlink" title="0X01 控制端口/服务"></a>0X01 控制端口/服务</h1><p>可以通过两种方式控制端口的开放，一种是指定端口号另一种是指定服务名。虽然开放http服务就是开放了80端口，但是还是不能通过端口号来关闭，也就是说通过指定服务名开放的就要通过指定服务名关闭；通过指定端口号开放的就要通过指定端口号关闭。还有一个要注意的就是指定端口的时候一定要指定是什么协议，tcp还是udp。知道这个之后以后就不用每次先关防火墙了，可以让防火墙真正的生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-service=mysql		<span class="comment"># 开放mysql端口</span></span><br><span class="line">firewall-cmd --remove-service=http		<span class="comment"># 阻止http端口</span></span><br><span class="line">firewall-cmd --list-services			<span class="comment"># 查看开放的服务</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --add-port=3306/tcp		<span class="comment"># 开放通过tcp访问3306</span></span><br><span class="line">firewall-cmd --remove-port=80tcp		<span class="comment"># 阻止通过tcp访问3306</span></span><br><span class="line">firewall-cmd --add-port=233/udp			<span class="comment"># 开放通过udp访问233</span></span><br><span class="line">firewall-cmd --list-ports				<span class="comment"># 查看开放的端口</span></span><br></pre></td></tr></table></figure>

<h1 id="0X02-伪装IP"><a href="#0X02-伪装IP" class="headerlink" title="0X02 伪装IP"></a>0X02 伪装IP</h1><p>防火墙可以实现伪装IP的功能，下面的端口转发就会用到这个功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-masquerade <span class="comment"># 检查是否允许伪装IP</span></span><br><span class="line">firewall-cmd --add-masquerade   <span class="comment"># 允许防火墙伪装IP</span></span><br><span class="line">firewall-cmd --remove-masquerade<span class="comment"># 禁止防火墙伪装IP</span></span><br></pre></td></tr></table></figure>


<h1 id="0X03-端口转发"><a href="#0X03-端口转发" class="headerlink" title="0X03 端口转发"></a>0X03 端口转发</h1><p>端口转发可以将指定地址访问指定的端口时，将流量转发至指定地址的指定端口。转发的目的如果不指定ip的话就默认为本机，如果指定了ip却没指定端口，则默认使用来源端口。<br>如果配置好端口转发之后不能用，可以检查下面两个问题：</p>
<ol>
<li>比如我将80端口转发至8080端口，首先检查本地的80端口和目标的8080端口是否开放监听了</li>
<li>其次检查是否允许伪装IP，没允许的话要开启伪装IP</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将80端口的流量转发至8080</span></span><br><span class="line">firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将80端口的流量转发至</span></span><br><span class="line">firewall-cmd --add-forward-port=port=80:proto=tcp:toaddr=192.168.1.0.1192.168.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将80端口的流量转发至192.168.0.1的8080端口</span></span><br><span class="line">firewall-cmd --add-forward-port=port=80:proto=tcp:toaddr=192.168.0.1:toport=8080</span><br></pre></td></tr></table></figure>
<ol>
<li>当我们想把某个端口隐藏起来的时候，就可以在防火墙上阻止那个端口访问，然后再开一个不规则的端口，之后配置防火墙的端口转发，将流量转发过去。</li>
<li>端口转发还可以做流量分发，一个防火墙拖着好多台运行着不同服务的机器，然后用防火墙将不同端口的流量转发至不同机器。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Firewall </tag>
            
            <tag> firewall-cmd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文件系统简述]]></title>
      <url>/2016/11/16/filesystem/</url>
      <content type="html"><![CDATA[<h1 id="0X00-文件"><a href="#0X00-文件" class="headerlink" title="0X00 文件"></a>0X00 文件</h1><p>** ‘文件’是进程创建的逻辑单元。 ** —《现代操作系统（原书第三版）》<br>文件我们再熟悉不过了，电脑磁盘上存的都是文件。在Windows里和Unix系列系统里，表面看上去文件之间还是有一点点小的区别。比如，在Windows里主要还是以文件的后缀名来标识文件具体是什么类型的，图片还是视频；在Unix系列里文件的后缀名就没那么重要，主要后缀名是用来帮助人们识别文件类型的，操作系统并不很关心。<br>** 真正的文件类型 ** 是文件的本质类型，不是我们常说的exe类型、doc类型、更不是什么图片类型和视频类型。在Windows下有常见的普通文件和目录。<em>没错，目录其实是文件的</em>。在Unix里，还有一些叫字符特殊文件和块特殊文件的。</p>
<a id="more"></a>
<h1 id="0X01-文件的元数据"><a href="#0X01-文件的元数据" class="headerlink" title="0X01 文件的元数据"></a>0X01 文件的元数据</h1><p>文件里最重要的东西肯定是文件内容了，但是文件存在磁盘里是还有一些其他的相关数据也被存进去了的，那些数据被称之为<strong>元数据</strong>。想一下文件的相关信息，在Windows里右键一个文件选择属性或者在Linux里使用<code>ls -l</code>看到的文件的详细信息，这些几乎全部都是文件的元数据，都存到了磁盘中。常见的元数据有下面这些:创建者、拥有者、权限标志、文件大小、锁等等。比如说我们在Linux下输入<code>ls -l</code>能看到文件的大小、权限、所属者，这些都是文件的元数据。</p>
<h1 id="0X02-MBR-主引导记录"><a href="#0X02-MBR-主引导记录" class="headerlink" title="0X02 MBR-主引导记录"></a>0X02 MBR-主引导记录</h1><p>经常装系统的话应该比较熟悉这个词‘主引导记录’，在以前的磁盘上常用的就是这种称为MBR的磁盘分区方式，其实现在还有好多在用MBR的，不过由于MBR的原理导致不支持2TB以上的磁盘且不支持4个以上的主分区，所以用的越来越少了，取而代之的是GPT。不过由于MBR比较简单，就先介绍一下MBR。<br>计算机在启动的时候，BIOS会读取MBR的分区表来找到引导分区并引导操作系统。可以启动的分区称为活动分区，必须要是活动的分区才可以引导系统启动；MBR的分区表只能容纳四个分区，如果需要更多的分区就需要创建扩展分区。可以在一个MBR的分区表中创建三个主分区，在最后一个位置创建一个扩展分区。实际上最后一个扩展分区是不能直接使用的，相当于扩展分区在磁盘上花了一块当另一个磁盘用、在扩展分区头部还有一个扩展分区的分区表，里面保存着逻辑分区的分区信息，且这个分区表的空间比较大，所以逻辑分区可以创建好多个。</p>
<h1 id="0X03-文件存储"><a href="#0X03-文件存储" class="headerlink" title="0X03 文件存储"></a>0X03 文件存储</h1><p>文件存储在磁盘中有好多种分配方案，这些方案各有利弊。随着存储介质、CPU等设备的发展和人们需求的变化，出现了下面这些比较好的方案。</p>
<h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><p>首先我们把磁盘想象成一个超长的条形存储设备，这样就比较好理解（然而实际上现在常见的磁盘是区分盘面、磁道、柱面、扇区的）。<br>早期的磁盘和现代的CD-ROM是使用这种连续分配方式存储数据的。连续分配，由字面可知是把文件连续的从头到尾得存到磁盘里，这种方式读写都非常快，但是却非常不适合日常使用。考虑下面这种情况，我有下面这些文件<br><code>[  A  ][  B  ][  C  ][  D  ][  E  ][  F  ]</code>整个磁盘大小为6GB，每个文件都有1GB，刚刚好用完整个磁盘。但是当我删除了B和E两个文件的时候就会变成下面这样，空余两个1GB的位置出来，但是这两个空间不连续<br><code>[  A  ][     ][  C  ][  D  ][     ][  F  ]</code>现在我有2GB的空间。系统需要维护一个空闲空间列表来让后来的文件放在这些空闲的地方，因为如果不维护这张表的话，当磁盘写满过一次就再也不能写入新的数据了。虽然我们维护了一张这样的表也并不能很让人满意，比如有一个1.5GB的文件想存到磁盘里，系统就会查找连续的空余空间，但是并没有一个连续的高达1.5GB的空间，所以并不能把文件存进去，显然这并不能让人满意。而且，这些还都是建立在一个前提之下的，就是说“存储文件之前必须知道文件的大小”，然而事实上很多时候是不知道的，比如我们打开了AE（一款渲染视频的软件）来制作一段视频特效，然而在生成视频的时候没有人知道这个文件最后是多大的，所以就并不适用于这种情况。但是这种分配方案就没有优点了吗？也不是的。比如我们需要将数据刻录到CD-ROM上，因为CD-ROM是只读设备，所以在第一次刻录之后就没有修改的可能了，那么我们就可以通过这种方案直接将已有的数据顺序刻录到光盘里，这样以后的读取就会变得很快了。然后针对磁盘有了下面的‘链表分配方案’</p>
<h2 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h2><p>使用链表分配方案时，目录下的每一个文件都只保留文件的头指针，每个文件都是一个链表，这样我们就可以顺着指针的指向把整个文件从文件系统中遍历出来。虽然链表分配方案成功的利用起来了空闲空间，但是还是有下面两个比较严重的问题：</p>
<ol>
<li>每次想要访问文件的第n个节点时候，都要从文件头开始访问，有n-1次磁盘的访问是无效的，所以这种方案对随机读取非常慢；</li>
<li>因为每个磁盘块的大小都是2的n次幂，保存的大小也就是2的n次幂，但是因为文件头被指针占去了一定的字节，就导致实际存储的文件并不是2的n次幂。虽然这个问题并不是致命的，但是确实会让系统变慢，也会让面向系统的编程变得困难很多。</li>
</ol>
<p>内存链表解决了链表分配的一些问题。</p>
<h2 id="内存链表分配"><a href="#内存链表分配" class="headerlink" title="内存链表分配"></a>内存链表分配</h2><p>内存链表分配是将磁盘里所有文件的所有块都做成链表，依旧是每个文件一个链表。但是这次将链表整个存放到内存中，这样在随机访问的时候因为链表全都在内存中就会非常快。但是由于要对每一个文件建立存储，且存放在内存中，所以这种文件系统并不适合用于小文件大磁盘。对于一个200GB的磁盘，里面充满了1KB的块，那么根据系统优化之后这张表需要600~800MB的内存，然而现在动辄TB级的磁盘，则非常不适用。这种内存链表分配方案中维护的表称之为‘文件分配表’英文也就是我们熟悉的‘File Allocation Table-----FAT’<br>为了克服内存链表分配的内存占用大的问题，有了i-Node方案。</p>
<h2 id="i-Node"><a href="#i-Node" class="headerlink" title="i-Node"></a>i-Node</h2><p>i-Node方案在磁盘头部预留一段空间用来存放i-Node，这里的i-Node是一种数据结构，里面包含了文件的一些元数据和文件所有块的相关信息，所以根据一个i-Node就可以找到着整个文件。因为每个i-Node的预留空间都是固定的，如果文件太大太分散就会导致一个i-Node并不能存储完所有信息，那么i-Node中最后一段就保存了另一个i-Node的地址，然后在另一个i-Node中继续保存信息。因为i-Node是保存在磁盘里的，所以不会影响到内存，只有当文件真正打开的时候才会将数据加载到内存。所以内存占用是核同时打开的文件数量相关的。在Linux中我们使用<code>ls -l -i</code>就可以看到每个文件的i-Node编号。现在的大多数文件系统都采用这种方案了，比如EXT、NTFS、XFS等。</p>
<h1 id="0X04-文件共享"><a href="#0X04-文件共享" class="headerlink" title="0X04 文件共享"></a>0X04 文件共享</h1><p>首先明确两点：1. 这里说的文件共享并不是说将一个文件通过网络传输给他人的那种文件共享； 2. 系统中的文件结构不是树状，而是图。（当Windows中我们给一个文件建立了一个快捷方式并放在了另一个目录里的时候，就形成了图解构）<br>这里的文件共享主要就是链接的问题，关于链接的内容可以在我博客里找到。<a href="http://blog.just666.cn/index.php/archives/10/">Linux软连接/硬链接 理解Linux链接</a><br>每个文件会保存指向自己的链接数，当只想自己的链接数为0的时候，那么这块数据就抛弃掉了。</p>
<h1 id="0X05-文件系统"><a href="#0X05-文件系统" class="headerlink" title="0X05 文件系统"></a>0X05 文件系统</h1><h2 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h2><p>因为现在的CPU运算能力和磁盘容量、内存容量等都有了非常大的进步，所以在不实际访问磁盘只在高速缓存上就能访问到很多需要的数据，所以根据这种情况，就出现了日志结构文件系统(Log-structred File System)。这种文件系统将文件操作结构化成日志。在这种文件系统中每次将数据读写缓存到内存，然后定时定量地将数据从内存写入磁盘。</p>
<h2 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h2><p>日志文件系统比日志结构文件系统有更强的鲁棒性（Roubst 也就是健壮性）。在这种文件系统中进行文件操作时，先记录下要干什么，然后再开始操作。这样不管什么时候出了错误，都可以根据日志来恢复操作。比如在Unix中删除一个文件分成三个步骤：1.在目录中删除文件 2.释放i-Node到空间i-Node节点池 3.强磁盘块归还到操作系统。 如果完成了第一步，就死机了，那么由于日志的存在就可以在知道这个操作究竟要干什么，在恢复开机的时候就可以继续完成这次操作。当所有的任务项都完成了的时候就删除这个日志。</p>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>在Windows里用的是多根目录的方式，也就是有多个根目录，比如C盘D盘E盘等，但是在Linux中我们使用的是单根目录形式，如果要同时使用几种文件系统比如：根目录使用XFS、/home使用ext4、/usr目录使用ext3、那么久需要使用一种叫做虚拟文件系统的技术。两个不同的文件系统之间需要连接的话需要使用VFS（虚拟文件系统）接口来将两个文件系统连起来。使用这种虚拟文件系统的技术就可以让同一个根目录下面挂载有不同文件系统的设备。</p>
<h1 id="0X06-磁盘分块"><a href="#0X06-磁盘分块" class="headerlink" title="0X06 磁盘分块"></a>0X06 磁盘分块</h1><p>已知文件在磁盘里是按照块存储的，那么每个块分配多大就成为了一个问题。因为在磁盘底层，每个文件占用的块都是整数，比如我一个块是1kb，那么我有一个2.5kb的文件也要占用3个块，甚至是1字节的文件也要占用1kb，每个块中剩余的部分是不能存储其他文件的。从这方面看来分块越大就越浪费空间，块越小磁盘空间利用率越高。那么我们把块都分成最小，这样就行了吗？显然没有这么简单。因为磁盘在读写数据的时候是按照块来的，所以分的块越大读写的速度越快，因为磁盘里的总块数少，块越小越慢。总结下来是这样：随着块大小的提升，磁盘读写效率会提高，但是空间利用率会降低。统计所得，分块大小为4kb最容易获得最佳性能。</p>
<h1 id="0X07-缓冲区"><a href="#0X07-缓冲区" class="headerlink" title="0X07 缓冲区"></a>0X07 缓冲区</h1><p>现在的文件系统都支持缓冲区写入。缓冲区写入对应的另一种是‘同步写入’。缓冲区写入：程序生成的或者用户的数据首先写入到内存中，当达到一定时间或者一定量的时候一次性写入磁盘；同步写入：将程序和用户产生的数据实时写入磁盘里。下面对比一下这两种的优缺点</p>
<p><strong>同步写入优点</strong>：数据实时同步，出现数据丢失的可能性很小<br><strong>同步写入缺点</strong>：由于数据产生很慢，所以磁盘利用率不高，且长期占据磁盘<br><strong>缓冲写入优点</strong>：数据首先写入比磁盘快得多的内存中，再统一写入磁盘只会短时间占用磁盘，且占用磁盘时利用率高<br><strong>缓冲写入缺点</strong>：当数据在缓冲区没有写入磁盘时系统发生异常或者崩溃，数据非常容易丢失</p>
<p>这里有两段Python的代码，展示了缓冲区写入和同步写入的速度差异，首先是使用同步写入方式写入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">&#x27;D:/list.txt&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>, <span class="number">0</span>)    <span class="comment">#不使用缓冲</span></span><br><span class="line">start_time = ctime()    <span class="comment">#开始时间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3000000</span>):</span><br><span class="line">    f.write(<span class="string">&#x27;hello,world\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line">end_time = ctime()  <span class="comment">#结束时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> start_time</span><br><span class="line"><span class="keyword">print</span> end_time</span><br></pre></td></tr></table></figure>
<p>运行结果是这样的，我们看到写入300W行’hello,world’用了8秒，最后生成的数据量是37.1MB</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thu Nov 17 11:12:21 2016</span><br><span class="line">Thu Nov 17 11:12:29 2016</span><br></pre></td></tr></table></figure>
<p>然后使用Python默认大小的缓冲区试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">&#x27;D:/list.txt&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>, <span class="number">-1</span>)    <span class="comment">#使用默认缓冲区大小</span></span><br><span class="line">start_time = ctime()    <span class="comment">#开始时间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3000000</span>):</span><br><span class="line">    f.write(<span class="string">&#x27;hello,world\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line">end_time = ctime()  <span class="comment">#结束时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> start_time</span><br><span class="line"><span class="keyword">print</span> end_time</span><br></pre></td></tr></table></figure>
<p>运行结果是这样的，我们看到这次写入相同的数据只用了1秒</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thu Nov 17 11:18:04 2016</span><br><span class="line">Thu Nov 17 11:18:05 2016</span><br></pre></td></tr></table></figure>

<h1 id="0X08-坏块屏蔽"><a href="#0X08-坏块屏蔽" class="headerlink" title="0X08 坏块屏蔽"></a>0X08 坏块屏蔽</h1><p>在磁盘这种物理结构里出现错误是比较正常的，尤其是机械磁盘磁臂在旋转的时候与磁道的摩擦会产生部分坏块。这些坏块上的数据会发生丢失或者错误，那么怎么屏蔽这些坏块呢？之前在那些分区软件里看到过坏块屏蔽，感觉非常高端，其实原理是很简单的。比如磁盘里有23块坏块，那么修复程序就创建一个文件，指定这个文件就存储在这23个坏块上，且对操作系统不可见，那么操作系统虽然知道这里有文件，但是不会去管他，这样就相当于屏蔽了磁盘里的坏块。</p>
<h1 id="0X09-提升文件系统性能-高速缓存"><a href="#0X09-提升文件系统性能-高速缓存" class="headerlink" title="0X09 提升文件系统性能 高速缓存"></a>0X09 提升文件系统性能 高速缓存</h1><p>高速缓存就是将即将需要的文件和经常使用的文件放在磁盘的高速缓存里，因为高速缓存的速度比磁盘要快得多，所以就可以通过这种方式来提高I/O效率。<br>在Unix里有一个系统调用sync，在Windows里有一个FlushFileBuffers，是用来将高速缓存里的数据同步写入到磁盘里的。在Unix系列系统中每隔30秒就执行一次sync将数据写入，在Windows中则是实时的。这两种方案并没有谁好谁坏之分，各有优劣。</p>
<h1 id="0X0A-磁盘碎片整理"><a href="#0X0A-磁盘碎片整理" class="headerlink" title="0X0A 磁盘碎片整理"></a>0X0A 磁盘碎片整理</h1><p>因为绝大多数的现代文件系统都采用了链表存储的方案，所以在使用磁盘一段时间之后文件都是分散的放在磁盘的各个角落的，这样的话读写文件就会变得比较慢，文件越零散读写就越慢。那么我们可以手动将磁盘进行整理，将分散的文件数据聚合到一起，当然也只能是尽量，因为某些数据是不能被移动的，比如页文件、休眠文件、日志。当零散的文件变成连续的文件的时候读写的效率就会有大幅度提升。但是由于各个操作系统采用的文件系统的内部实现不同，导致几乎只有Windows需要对磁盘进行手动整理。当然所谓的手动整理也是有软件支持的，不需要用户自己去操作磁盘。但是因为Windows的发展，也几乎不再需要手动进行整理了。</p>
]]></content>
      
        
        <tags>
            
            <tag> File System </tag>
            
            <tag> Operation System </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 中计划任务和周期任务]]></title>
      <url>/2016/11/02/linux-crontab/</url>
      <content type="html"><![CDATA[<h1 id="0X00-Linux中的计划任务"><a href="#0X00-Linux中的计划任务" class="headerlink" title="0X00 Linux中的计划任务"></a>0X00 Linux中的计划任务</h1><p>我们使用Linux更多的时候是在服务器上，然而我们有的时候就需要让计算机在固定的某个时间做一些事情。比如我们就可能有有如下需求：</p>
<ol>
<li>临时有事需要离开电脑，但是一个小时后需要备份某个目录里的文件</li>
<li>写了个爬虫去抓取某网站的新闻，每隔十分钟就去爬取一次</li>
<li>周期性的执行某脚本，但放在后台的话退出ssh就会被自动关掉</li>
<li>其实还有好多这种可能…………</li>
</ol>
<p>在Linux中有两种常见的任务管理，一个是<code>at</code>也就是在某时做某事，另一个是<code>crontab</code>也就是周期性任务表。使用at可以方便地给Linux设置一个在什么时候做什么事的计划，用crontab可以方便地给Linux设置我要做某事，多久做一次。</p>
<a id="more"></a>

<h1 id="0X01-使用at命令"><a href="#0X01-使用at命令" class="headerlink" title="0X01 使用at命令"></a>0X01 使用at命令</h1><h2 id="检查atd服务是否开启"><a href="#检查atd服务是否开启" class="headerlink" title="检查atd服务是否开启"></a>检查atd服务是否开启</h2><p><code>atd</code>就是at命令的守护进程，系统默认是打开着的，但是也有可能被关掉，在RHEL系中可以使用<code>systemctl status atd</code>来查看服务是否已经开启，没有开启的话可以用<code>systemctl restart atd</code>来打开服务</p>
<h2 id="创建一个计划任务"><a href="#创建一个计划任务" class="headerlink" title="创建一个计划任务"></a>创建一个计划任务</h2><p>先创建一个在今天的<code>21:09</code>的任务，任务内容是输出hello,world重定向到/hello文件。然后到时间之后再检查这个文件是否出现了。当我们只指定时分的时候，默认是当天，如果已经过了的时间的话，会默认为次日。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个即日的计划任务</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># date</span></span><br><span class="line">Wed Nov  2 21:07:07 CST 2016</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># at 21:09</span></span><br><span class="line">at&gt; <span class="built_in">echo</span> <span class="string">&quot;hello,world&quot;</span> &gt; /hello</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 5 at Wed Nov  2 21:09:00 2016</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># date</span></span><br><span class="line">Wed Nov  2 21:09:10 CST 2016</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># cat /hello</span></span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure>
<p>当我们输入<code>at 21:09</code>之后，就进入了at模式，我们在这里输入的命令就是之后将要执行的命令。当输入完命令之后按<code>Ctrl + D</code>就可以退出at模式，此时计划任务创建完毕，系统会提示你计划任务的执行时间。</p>
<p>下面还有几个例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个准确定时的计划任务</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># at 00:00 2016-11-11	# 在2016光棍节零点输出一个&#x27;hey 单身狗&#x27;</span></span><br><span class="line">at&gt; <span class="built_in">echo</span> <span class="string">&quot;hey single dog&quot;</span></span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 7 at Fri Nov 11 00:00:00 2016</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在十分钟后执行</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># at now+10min</span></span><br><span class="line">at&gt; <span class="built_in">echo</span> <span class="string">&#x27;hello single dog&#x27;</span></span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 9 at Wed Nov  2 21:26:00 2016</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一小时后执行</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># at now+1hour</span></span><br><span class="line">at&gt; <span class="built_in">echo</span> <span class="string">&#x27;hey single dog&#x27;</span></span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 10 at Wed Nov  2 22:16:00 2016</span><br></pre></td></tr></table></figure>

<h2 id="查看已有的at"><a href="#查看已有的at" class="headerlink" title="查看已有的at"></a>查看已有的at</h2><p>可以使用<code>atq</code>命令来查看存在的at计划任务，注意这里并不一定全都是用户自己创建的，也有的是系统创建的。通过atq查看到之后可以使用<code>at -c </code>来查看某个计划任务的具体信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># at now+1hour</span></span><br><span class="line">at&gt; <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 11 at Wed Nov  2 22:23:00 2016</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># atq</span></span><br><span class="line"><span class="comment"># 这里输出的第一列就是at的编号，下面查看详细信息就是根据编号查看的</span></span><br><span class="line">7	Fri Nov 11 00:00:00 2016 a root</span><br><span class="line">6	Thu Nov  3 03:00:00 2016 a root</span><br><span class="line">10	Wed Nov  2 22:16:00 2016 a root</span><br><span class="line">9	Wed Nov  2 21:26:00 2016 a root</span><br><span class="line">11	Wed Nov  2 22:23:00 2016 a root</span><br><span class="line">1	Wed Nov  2 21:52:00 2016 a root</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># at -c 11</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># atrun uid=0 gid=0</span></span><br><span class="line"><span class="comment"># mail root 0</span></span><br><span class="line"><span class="built_in">umask</span> 22</span><br><span class="line">XDG_SESSION_ID=669; <span class="built_in">export</span> XDG_SESSION_ID</span><br><span class="line">............................... <span class="comment"># 这里省略了好多环境变量，重点在下面</span></span><br><span class="line">XDG_RUNTIME_DIR=/run/user/0; <span class="built_in">export</span> XDG_RUNTIME_DIR</span><br><span class="line"><span class="built_in">cd</span> /root || &#123;</span><br><span class="line">	 <span class="built_in">echo</span> <span class="string">&#x27;Execution directory inaccessible&#x27;</span> &gt;&amp;2</span><br><span class="line">	 <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$&#123;SHELL:-/bin/sh&#125;</span> &lt;&lt; <span class="string">&#x27;marcinDELIMITER0e9efce8&#x27;</span>	<span class="comment"># 这里是执行的命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">marcinDELIMITER0e9efce8</span><br></pre></td></tr></table></figure>

<h2 id="删除一个at"><a href="#删除一个at" class="headerlink" title="删除一个at"></a>删除一个at</h2><p>使用一个<code>atrm</code>命令可以指定at号删除特定的at计划任务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># at now+1hour</span></span><br><span class="line">at&gt; <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 12 at Wed Nov  2 22:27:00 2016</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># atq</span></span><br><span class="line">7	Fri Nov 11 00:00:00 2016 a root</span><br><span class="line">6	Thu Nov  3 03:00:00 2016 a root</span><br><span class="line">10	Wed Nov  2 22:16:00 2016 a root</span><br><span class="line">11	Wed Nov  2 22:23:00 2016 a root</span><br><span class="line">12	Wed Nov  2 22:27:00 2016 a root</span><br><span class="line">1	Wed Nov  2 21:52:00 2016 a root</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># atm 12</span></span><br><span class="line">-bash: atm: <span class="built_in">command</span> not found</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># atrm 12</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># atq</span></span><br><span class="line">7	Fri Nov 11 00:00:00 2016 a root</span><br><span class="line">6	Thu Nov  3 03:00:00 2016 a root</span><br><span class="line">10	Wed Nov  2 22:16:00 2016 a root</span><br><span class="line">11	Wed Nov  2 22:23:00 2016 a root</span><br><span class="line">1	Wed Nov  2 21:52:00 2016 a root</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># at now+1hour</span></span><br><span class="line">at&gt; <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 12 at Wed Nov  2 22:27:00 2016</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># atq</span></span><br><span class="line">7	Fri Nov 11 00:00:00 2016 a root</span><br><span class="line">6	Thu Nov  3 03:00:00 2016 a root</span><br><span class="line">10	Wed Nov  2 22:16:00 2016 a root</span><br><span class="line">11	Wed Nov  2 22:23:00 2016 a root</span><br><span class="line">12	Wed Nov  2 22:27:00 2016 a root</span><br><span class="line">1	Wed Nov  2 21:52:00 2016 a root</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># atrm 12</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># atq</span></span><br><span class="line">7	Fri Nov 11 00:00:00 2016 a root</span><br><span class="line">6	Thu Nov  3 03:00:00 2016 a root</span><br><span class="line">10	Wed Nov  2 22:16:00 2016 a root</span><br><span class="line">11	Wed Nov  2 22:23:00 2016 a root</span><br><span class="line">1	Wed Nov  2 21:52:00 2016 a root</span><br></pre></td></tr></table></figure>

<h1 id="0X02-使用crontab命令"><a href="#0X02-使用crontab命令" class="headerlink" title="0X02 使用crontab命令"></a>0X02 使用crontab命令</h1><ul>
<li>这里的配置分成六段</li>
</ul>
<p>分—时—日—月—周—命令</p>
<h2 id="创建周期任务"><a href="#创建周期任务" class="headerlink" title="创建周期任务"></a>创建周期任务</h2><p>使用任何一个用户登陆到系统之后，就可以执行<code>crontab -e</code>就进入了vi的编辑器模式，然后我们来编辑这个文件就可以创建/修改周期任务了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">15  10 1 10 * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello		<span class="comment"># 在每个10月1号10点15分执行命令</span></span><br><span class="line">15  10 1 *  * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello		<span class="comment"># 在每个1号10点15分执行命令</span></span><br><span class="line">15  10 * *  * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello		<span class="comment"># 在每个10点15分执行命令</span></span><br><span class="line">15  *  * *  * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello		<span class="comment"># 在每个15分执行命令</span></span><br><span class="line">*/3 *  * *  * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello		<span class="comment"># 每3分钟执行命令</span></span><br></pre></td></tr></table></figure>
<p>退出保存之后就可以按照这个时间来执行命令了。</p>
<h2 id="查看周期任务"><a href="#查看周期任务" class="headerlink" title="查看周期任务"></a>查看周期任务</h2><p>使用<code>crontab -l</code>查看该用户的周期任务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># crontab -l</span></span><br><span class="line">15  10 1 10 * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello</span><br><span class="line">15  10 1 *  * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello</span><br><span class="line">15  10 * *  * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello</span><br><span class="line">15  *  * *  * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello</span><br><span class="line">*/3 *  * *  * <span class="built_in">echo</span> <span class="string">&#x27;hello&#x27;</span> &gt; /tmp/hello</span><br></pre></td></tr></table></figure>

<h2 id="删除周期任务"><a href="#删除周期任务" class="headerlink" title="删除周期任务"></a>删除周期任务</h2><p>可以使用<code>crontab -r</code>删除当前用户所有的周期任务。</p>
<h2 id="管理周期任务"><a href="#管理周期任务" class="headerlink" title="管理周期任务"></a>管理周期任务</h2><p>每个用户都可以使用<code>crontab -e</code>来管理自己的周期任务，然而root用户可以使用<code>crontab -u</code>来管理其他用户的周期任务。只要加一个-u选项即可，参数后面接上要管理的用户就可以了。然后还是和上面的操作一样，只是多了一个这个参数而已。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Crontab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux权限控制列表 ACL修改]]></title>
      <url>/2016/11/02/linux-acl/</url>
      <content type="html"><![CDATA[<h1 id="0X00-ACL是什么"><a href="#0X00-ACL是什么" class="headerlink" title="0X00 ACL是什么"></a>0X00 ACL是什么</h1><p>ACL的全称是<code>Access Control List</code>访问控制列表。在Linux中可以给文件设置权限，<code>-rwx-rw-rw</code>这样，但是这里并不能细分，只能分到用户、组、其他用户。如果我想给某个单独的用户设置权限的话是做不到的。所以有了ACL的出现。通过ACL可以给Linux下的文件提供详细的访问控制，比如我们在设置了基本的<code>rwx</code>权限之后，可以通过ACL在细分用户对文件的权限。</p>
<a id="more"></a>

<h1 id="0X01-查看文件的ACL"><a href="#0X01-查看文件的ACL" class="headerlink" title="0X01 查看文件的ACL"></a>0X01 查看文件的ACL</h1><p>使用<code>getfacl</code>命令可以查看文件的ACL和详细的权限设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rwxr-xr-x 1 root root 1714 Oct 28 22:24 hello.py</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># getfacl hello.py</span></span><br><span class="line"><span class="comment"># file: hello.py</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">other::r-x</span><br></pre></td></tr></table></figure>
<p>这里显示了文件名、所属用户、所属组、还有相对应的权限。</p>
<h1 id="0X02-创建测试用户-组-文件"><a href="#0X02-创建测试用户-组-文件" class="headerlink" title="0X02 创建测试用户/组/文件"></a>0X02 创建测试用户/组/文件</h1><p>先创建测试用户、测试组、测试文件。创建了<code>xiaoming</code>和<code>xiaohong</code>两个用户，在<code>china</code>组，创建了一个<code>jack</code>用户在<code>usa</code>组。然后用root用户在<code>/tmp/</code>目录下创建了一个acltest目录，用来做测试，因为这个目录是任何人都可以访问的，但是由于是root用户创建的子目录，所以要给这个目录<code>777</code>的权限，让其他用户可以在里面测试。现在里面又创建了一些目录和文件，但是全部都是root用户的，文件权限是<code>644</code>，目录权限是<code>755</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># groupadd china</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># useradd xiaoming -g china</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># useradd xiaohong -g china</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># groupadd usa</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># useradd jack -g usa</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># cd /tmp</span></span><br><span class="line">[root@iZ28jaak5nnZ tmp]<span class="comment"># mkdir acltest</span></span><br><span class="line">[root@iZ28jaak5nnZ tmp]<span class="comment"># chmod 777 acltest</span></span><br><span class="line">[root@iZ28jaak5nnZ tmp]<span class="comment"># cd acltest/</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># touch file_&#123;1,3&#125;</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># mkdir dir_&#123;1,3&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="0X03-设置文件的ACL"><a href="#0X03-设置文件的ACL" class="headerlink" title="0X03 设置文件的ACL"></a>0X03 设置文件的ACL</h1><p>使用<code>setfacl</code>命令可以设置文件ACL。这个命令有下面这几个常用参数</p>
<h2 id="setfacl-各个参数"><a href="#setfacl-各个参数" class="headerlink" title="setfacl 各个参数"></a>setfacl 各个参数</h2><ul>
<li>所谓的后续ACL就是在默认ACL的基础上添加的新的规则。</li>
</ul>
<h3 id="m-设置后续ACL"><a href="#m-设置后续ACL" class="headerlink" title="-m 设置后续ACL"></a>-m 设置后续ACL</h3><p>对某一个文件/目录设置某一个用户的访问权限， u表示用户 冒号后面是用户名 再一个冒号后面是权限 最后接文件/目录<br><code>[root@iZ28jaak5nnZ acltest]# setfacl -m u:user_1:rwx file_1</code></p>
<p>对某一个文件/目录设置某一个用户组的访问权限，u表示组 冒号后面是组名 再一个冒号后面是权限 最后接文件/目录<br><code>[root@iZ28jaak5nnZ acltest]# setfacl -m g:group_1:rwx file_1</code></p>
<h3 id="x-删除后续ACL"><a href="#x-删除后续ACL" class="headerlink" title="-x 删除后续ACL"></a>-x 删除后续ACL</h3><p>删除之前添加的ACL项，指定用户或者指定组都是可以的，语法和上面差不多。这里删除的是一条ACL数据，下面说的-b参数是删除所有的ACL数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># setfacl -x u:xiaoming file_1</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl file_1</span></span><br><span class="line"><span class="comment"># file: file_1</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rw-</span><br><span class="line">group::r--</span><br><span class="line">mask::r--</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure>

<h3 id="b-删除所有后续ACL"><a href="#b-删除所有后续ACL" class="headerlink" title="-b 删除所有后续ACL"></a>-b 删除所有后续ACL</h3><p>这里是删除之前创建的所有ACL，包括下面会说的默认ACL</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl file_1</span></span><br><span class="line"><span class="comment"># file: file_1</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rw-</span><br><span class="line">user:xiaoming:rwx</span><br><span class="line">user:xiaohong:rw-</span><br><span class="line">group::r--</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># setfacl -b file_1</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl file_1</span></span><br><span class="line"><span class="comment"># file: file_1</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rw-</span><br><span class="line">group::r--</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure>

<h3 id="d-设置默认ACL"><a href="#d-设置默认ACL" class="headerlink" title="-d 设置默认ACL"></a>-d 设置默认ACL</h3><p>设置默认ACL只能为目录设置，为目录设置了ACL之后里面新建的目录和文件都是使用这个默认的ACL</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl dir_1</span></span><br><span class="line"><span class="comment"># file: dir_1</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">other::r-x</span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># setfacl -m d:u:jack:rwx dir_1	# 设置目录的默认ACL</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl dir_1	# 我们可以看到现在出现了一段默认ACL</span></span><br><span class="line"><span class="comment"># file: dir_1</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">other::r-x</span><br><span class="line">default:user::rwx</span><br><span class="line">default:user:jack:rwx</span><br><span class="line">default:group::r-x</span><br><span class="line">default:mask::rwx</span><br><span class="line">default:other::r-x</span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># cd dir_1</span></span><br><span class="line">[root@iZ28jaak5nnZ dir_1]<span class="comment"># touch hello</span></span><br><span class="line">[root@iZ28jaak5nnZ dir_1]<span class="comment"># getfacl hello	# 新建的文件也使用这些默认设置</span></span><br><span class="line"><span class="comment"># file: hello</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rw-</span><br><span class="line">user:jack:rwx			<span class="comment">#effective:rw-</span></span><br><span class="line">group::r-x			<span class="comment">#effective:r--</span></span><br><span class="line">mask::rw-</span><br><span class="line">other::r--</span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># setfacl -m u::rwx -d dir_3	# 设置为每个用户，也可以修改为用户组</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl dir_3</span></span><br><span class="line"><span class="comment"># file: dir_3</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">other::r-x</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::r-x</span><br><span class="line">default:other::r-x</span><br></pre></td></tr></table></figure>

<h3 id="k-删除默认ACL"><a href="#k-删除默认ACL" class="headerlink" title="-k 删除默认ACL"></a>-k 删除默认ACL</h3><p>这里可以删除之前设置的默认ACL，只限默认ACL</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl dir_3 # 查看ACL，这里显示有默认的ACL</span></span><br><span class="line"><span class="comment"># file: dir_3</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">other::r-x</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::r-x</span><br><span class="line">default:other::r-x</span><br><span class="line"></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># setfacl -k dir_3	# 删除dir_3的默认ACL</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl dir_3</span></span><br><span class="line"><span class="comment"># file: dir_3</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">other::r-x</span><br></pre></td></tr></table></figure>

<h3 id="R-递归设置ACL"><a href="#R-递归设置ACL" class="headerlink" title="-R 递归设置ACL"></a>-R 递归设置ACL</h3><p>给某一个目录设置递归的ACL之后这个目录和这个目录里的文件和子目录全部都会应用这个ACL，也就是说是相当于应用到了这个目录下的所有文件和目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先创建一下测试用的目录结构</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># mkdir -p dir1/dir2/dir3</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># touch dir1/hello.c</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># touch dir1/dir2/hey.c</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># setfacl -m u:jack:r -R dir1	递归设置ACL</span></span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl dir1</span></span><br><span class="line"><span class="comment"># file: dir1</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rwx</span><br><span class="line">user:jack:r--</span><br><span class="line">group::r-x</span><br><span class="line">mask::r-x</span><br><span class="line">other::r-x</span><br><span class="line">[root@iZ28jaak5nnZ acltest]<span class="comment"># getfacl dir1/hello.c</span></span><br><span class="line"><span class="comment"># file: dir1/hello.c</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line">user::rw-</span><br><span class="line">user:jack:r--</span><br><span class="line">group::r--</span><br><span class="line">mask::r--</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ACL </tag>
            
            <tag> Permission </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用nmcli和ip命令配置CentOS/RHEL的网络]]></title>
      <url>/2016/10/28/linux-nmcli-ip/</url>
      <content type="html"><![CDATA[<h1 id="0X00-查看网络配置文件"><a href="#0X00-查看网络配置文件" class="headerlink" title="0X00 查看网络配置文件"></a>0X00 查看网络配置文件</h1><p>在CentOS中网络是以配置文件的形式存在系统里的，在<code>/etc/sysconfig/network-scripts/</code>目录下，一般情况下网卡的配置文件都在这里了，以<code>ifcfg-</code>就是配置文件了，打开配置文件看一下。下面注释一下关键的配置项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet	# 网络类型</span><br><span class="line">BOOTPROTO&#x3D;static	# 协议取值，常见的是static和dhcp</span><br><span class="line">IPADDR&#x3D;10.13.7.33	# 给网卡ip赋值</span><br><span class="line">NETMASK&#x3D;255.255.255.0	# 给网卡子网掩码赋值</span><br><span class="line">DEFROUTE&#x3D;yes</span><br><span class="line">PEERDNS&#x3D;yes</span><br><span class="line">PEERROUTES&#x3D;yes</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;yes</span><br><span class="line">IPV6_AUTOCONF&#x3D;yes</span><br><span class="line">IPV6_DEFROUTE&#x3D;yes</span><br><span class="line">IPV6_PEERDNS&#x3D;yes</span><br><span class="line">IPV6_PEERROUTES&#x3D;yes</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no</span><br><span class="line">NAME&#x3D;enp0s8</span><br><span class="line">USERCTL&#x3D;no	# 是否允许非root用户控制</span><br><span class="line">UUID&#x3D;4c967913-c4c9-4961-ae03-de7865f144d0	# 网卡的唯一标识码</span><br><span class="line">DEVICE&#x3D;enp0s8	# 设备名</span><br><span class="line">ONBOOT&#x3D;no	# 是否在开机时激活</span><br></pre></td></tr></table></figure>
<p>但是一般不建议直接使用编辑器修改网络配置文件，因为这样容易出现一些语法错误和逻辑错误，所以建议使用命令行来管理配置网络，虽然本质上都是去修改配置文件。但是使用命令行去管理网络，命令都是确保配置没有问题才会写入到文件，所以会更加安全。包括下面介绍的<code>ip</code>和<code>nmcli</code>命令，都是通过修改配置文件来完成功能的。</p>
<a id="more"></a>

<h1 id="0X01-ifconfig-命令"><a href="#0X01-ifconfig-命令" class="headerlink" title="0X01 ifconfig 命令"></a>0X01 ifconfig 命令</h1><p>这个命令在CentOS7中已经不建议使用了，不过由于之前的版本都是在用这个命令，还是说一下。<code>ifconfig</code>是<code>interface configuration</code>的缩写，也就是接口配置。</p>
<h2 id="查看网络"><a href="#查看网络" class="headerlink" title="查看网络"></a>查看网络</h2><p>直接输入这个命令就可以看到现在启动着的所有网络。也可以接上某个特定的网卡来查看单独的信息<code>ifconfig enp0s3</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ifconfig</span></span><br><span class="line">enp0s8: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 08:00:27:79:c4:b1  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 0  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>如果想查看包括已经关闭了的网络时，使用<code>ifconfig -a</code>就可以了</p>
<blockquote>
<p>最后的那个lo是回环网络，暂时不用管</p>
</blockquote>
<h2 id="开关网络"><a href="#开关网络" class="headerlink" title="开关网络"></a>开关网络</h2><p><code>ifconfig</code>还可以开关网络，命令后面接<code>interface name</code>也就是网卡名，然后接上<code>up/down</code>就可以开关网络了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ifconfig enp0s8 down	# 关闭网络</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig</span></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 0  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig enp0s8 up	# 打开网络</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig</span></span><br><span class="line">enp0s8: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 123.123.123.2  netmask 255.255.255.128  broadcast 123.123.123.1</span><br><span class="line">        ether 08:00:27:79:c4:b1  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 0  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p><code>ifconfig</code>命令可以在不重启的情况下开关网络接口，修改IP、掩码、网关等信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ifconfig enp0s8	# 查看ep0s8的网卡信息</span></span><br><span class="line">enp0s8: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 08:00:27:79:c4:b1  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig enp0s8 123.233.233.123	# 修改ip为123.233.233.123</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig enp0s8</span></span><br><span class="line">enp0s8: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 123.233.233.123  netmask 255.0.0.0  broadcast 123.255.255.255</span><br><span class="line">        ether 08:00:27:79:c4:b1  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig enp0s8 netmask 255.255.255.0	# 修改子网掩码为255.255.255.0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig enp0s8</span></span><br><span class="line">enp0s8: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 123.233.233.123  netmask 255.255.255.0  broadcast 123.233.233.255</span><br><span class="line">        ether 08:00:27:79:c4:b1  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig enp0s8 123.123.123.2 netmask 255.255.255.128	# 当然也可以把这些写成一行</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig enp0s8</span></span><br><span class="line">enp0s8: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 123.123.123.2  netmask 255.255.255.128  broadcast 123.123.123.</span><br><span class="line">        ether 08:00:27:79:c4:b1  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<h1 id="0X02-nmtui-简单的类图形管理工具"><a href="#0X02-nmtui-简单的类图形管理工具" class="headerlink" title="0X02 nmtui 简单的类图形管理工具"></a>0X02 nmtui 简单的类图形管理工具</h1><p>在终端中输入<code>nmtui</code>就可以打开一个类图形的界面，用这个界面可以更简单得管理配置网络，但是不能做比较细致的配置，而且使用比较简单，所以这里就不多做介绍了，可以自己在终端上打开看看。这个命令的一大优点是可以在ssh远程连接的时候使用，在Windows下的XShell等软件中都可以直接调出。</p>
<h1 id="0X03-ip-命令"><a href="#0X03-ip-命令" class="headerlink" title="0X03 ip 命令"></a>0X03 ip 命令</h1><p>ip是现在推荐使用的命令，功能比较强大。</p>
<h2 id="ip命令管理设备开关"><a href="#ip命令管理设备开关" class="headerlink" title="ip命令管理设备开关"></a>ip命令管理设备开关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ip link show enp0s8	# 这个命令大致相当于 ifconfig enp0s8 查看这个网卡的信息</span></span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast state DOWN mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 08:00:27:79:c4:b1 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">[root@localhost ~]<span class="comment"># ip link set dev enp0s8 up	# 设置一个device，enp0s8，打开</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ip link show enp0s8</span></span><br><span class="line">3: enp0s8: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc pfifo_fast state DOWN mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 08:00:27:79:c4:b1 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">[root@localhost ~]<span class="comment"># ip link set dev enp0s8 down	# 设置 设备 网卡名 打开/关闭</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ip link show enp0s8</span></span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast state DOWN mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 08:00:27:79:c4:b1 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<h2 id="ip命令修改网卡MAC地址"><a href="#ip命令修改网卡MAC地址" class="headerlink" title="ip命令修改网卡MAC地址"></a>ip命令修改网卡MAC地址</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ip link set dev enp0s8 address 00:00:ff:bb:aa:22	# 修改网卡的物理地址，也就是MAC地址</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ip link show enp0s8</span></span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast state DOWN mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 00:00:ff:bb:aa:22 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<h1 id="0X04-nmcli-管理网络"><a href="#0X04-nmcli-管理网络" class="headerlink" title="0X04 nmcli 管理网络"></a>0X04 nmcli 管理网络</h1><p><code>nmcli</code>是<code>network manager command line interface</code>的简写，这个命令可以用来管理配置网络。</p>
<h2 id="查看网络接口状态"><a href="#查看网络接口状态" class="headerlink" title="查看网络接口状态"></a>查看网络接口状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli -p g</span></span><br><span class="line">=============================================================</span><br><span class="line">                    NetworkManager status</span><br><span class="line">=============================================================</span><br><span class="line">STATE      CONNECTIVITY  WIFI-HW  WIFI     WWAN-HW  WWAN    </span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">connected  full          enabled  enabled  enabled  enabled</span><br></pre></td></tr></table></figure>

<h2 id="查看修改主机名"><a href="#查看修改主机名" class="headerlink" title="查看修改主机名"></a>查看修改主机名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli general hostname</span></span><br><span class="line">localhost.localdomain</span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli general hostname test</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli general hostname</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="查看网络设备"><a href="#查看网络设备" class="headerlink" title="查看网络设备"></a>查看网络设备</h2><p>以前可以用ifconfig来查看网络设备，ip命令也可以查看。可以直接查看所有的，也可以指定某一个设备查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli device show	# 莎看所有设备</span></span><br><span class="line">GENERAL.DEVICE:                         enp0s3</span><br><span class="line">GENERAL.TYPE:                           ethernet</span><br><span class="line">GENERAL.HWADDR:                         08:00:27:35:C7:CE</span><br><span class="line">GENERAL.MTU:                            1500</span><br><span class="line">.......................	<span class="comment"># 输出太多，就不全放在这里了</span></span><br><span class="line">IP6.ADDRESS[1]:                         ::1/128</span><br><span class="line">IP6.GATEWAY:                 </span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli device show enp0s8	# 查看指定设备</span></span><br><span class="line">GENERAL.DEVICE:                         enp0s8</span><br><span class="line">GENERAL.TYPE:                           ethernet</span><br><span class="line">GENERAL.HWADDR:                         08:00:27:79:C4:B1</span><br><span class="line">GENERAL.MTU:                            1500</span><br><span class="line">GENERAL.STATE:                          100 (connected)</span><br><span class="line">GENERAL.CONNECTION:                     enp0s8</span><br><span class="line">GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/7</span><br><span class="line">WIRED-PROPERTIES.CARRIER:               off</span><br><span class="line">IP4.ADDRESS[1]:                         123.123.123.2/25</span><br><span class="line">IP4.GATEWAY:                            </span><br><span class="line">IP6.GATEWAY:          </span><br></pre></td></tr></table></figure>

<h2 id="修改网卡配置"><a href="#修改网卡配置" class="headerlink" title="修改网卡配置"></a>修改网卡配置</h2><p>一个设备可以有多个连接，在CentOS7中网络是以连接管理的。虽然每个设备可以有多个连接，但是同时生效的只能有一个。我们可以使用<code>nmcli connection</code>查看连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli connection show</span></span><br><span class="line">NAME    UUID                                  TYPE            DEVICE</span><br><span class="line">enp0s8  ae99f48d-5f20-4a9c-a487-c4ebafa3f92e  802-3-ethernet  enp0s8</span><br><span class="line">enp0s3  2edc4731-888c-4102-8ff5-236ea47eeedb  802-3-ethernet  enp0s3</span><br></pre></td></tr></table></figure>
<p>我们可以进行如下操作<code>nmcli connection add/delete/edit</code>也就是增删改三个操作。<br>每一个连接都有一个名字，我们可以根据名字索引来操作对应到的连接。我们先来删除掉之前配置的网络。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli connection delete enp0s8 	# 这样可以删掉之前的连接</span></span><br><span class="line">Connection <span class="string">&#x27;enp0s8&#x27;</span> (ae99f48d-5f20-4a9c-a487-c4ebafa3f92e) successfully deleted.</span><br></pre></td></tr></table></figure>
<p>然后添加一个新的连接，名字叫’test_conn’，接口是’enp0s8’，类型是’ethernet’也就是以太网，ip使用v4版本123.123.123.123，子网掩码是24位，ipv4的网关是123.123.123.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli connection add con-name &#x27;test_conn&#x27; ifname enp0s8 type ethernet ip4 123.123.123.123/24 gw4 123.123.123.1</span></span><br><span class="line">Connection <span class="string">&#x27;test_conn&#x27;</span> (05c7cd70-a48e-4a12-a0de-9d57724cf0d0) successfully added.</span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection show test_conn</span></span><br><span class="line"><span class="comment"># 这行命令的输出太多了就不展示了。但是我们可以通过这行命令看到自己创建的连接，信息和自己填写的命令相对应。</span></span><br></pre></td></tr></table></figure>
<p>修改一个连接可以使用<code>nmcli connection modify</code>，下面我们来测试一下修改一个连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli connection show test_conn | grep ipv4.dns	# 使用grep搜索查看dns设置</span></span><br><span class="line">ipv4.dns:                               </span><br><span class="line">ipv4.dns-search:                        </span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection modify test_conn ipv4.dns 8.8.8.8	# 修改ipv4的dns地址</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection show test_conn | grep ipv4.dns</span></span><br><span class="line">ipv4.dns:                               8.8.8.8</span><br><span class="line">ipv4.dns-search:     </span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> nmcli </tag>
            
            <tag> Network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 异常处理 捕获异常]]></title>
      <url>/2016/10/27/python-execption/</url>
      <content type="html"><![CDATA[<h1 id="0X00-什么是异常"><a href="#0X00-什么是异常" class="headerlink" title="0X00 什么是异常"></a>0X00 什么是异常</h1><p>程序在运行出错的时候就会抛出异常，异常时在正确的代码里发生的，不是代码出现了错误。下面就是一个异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line">num_1 = <span class="number">10</span></span><br><span class="line">num_2 = <span class="number">0</span></span><br><span class="line"><span class="comment"># 很明显这里是用一个数字去除以0</span></span><br><span class="line"><span class="comment"># 小学老师就说过0不能作为被除数</span></span><br><span class="line"><span class="comment"># 那么我们来看Python是如何处理这个问题的</span></span><br><span class="line">num_3 = num_1 / num_2</span><br><span class="line"><span class="keyword">print</span> num_3</span><br></pre></td></tr></table></figure>
<p>运行这个程序就会报出下面的错误，错误提示说在<code>hello.py</code>这个文件的第6行，出现了一个错误<code>integer division or modulo by zero</code>也就是说Python解释器发现你试图除以0或者试图用0取模。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;./hello.py&quot;</span>, line 6, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    num_3 = num_1 / num_2</span><br><span class="line">ZeroDivisionError: <span class="built_in">integer</span> division or modulo by zero</span><br></pre></td></tr></table></figure>
<p>这里提示的<code>ZeroDivisionError</code>就是一个异常，我们可以在后面捕获这个异常，然后进行一些处理。如果不捕获这个异常的话，程序运行到这里，异常就会直接抛出到用户界面，中断程序的运行。</p>
<a id="more"></a>

<h1 id="0X01-自己放出一个异常"><a href="#0X01-自己放出一个异常" class="headerlink" title="0X01 自己放出一个异常"></a>0X01 自己放出一个异常</h1><p>我们可以用<code>raise</code>抛出一个自己的异常，这样我们可以在调试程序的时候判断到底出了什么错误，通过抛出的异常信息就可以判断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line">name = raw_input(<span class="string">&#x27;name: &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;&#x27;</span>:  <span class="comment"># 姓名不允许为空</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;name is null&#x27;</span>) <span class="comment"># 抛出一个自定义的Exception内容是name is null</span></span><br><span class="line"></span><br><span class="line">age  = input(<span class="string">&#x27;age : &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> age &lt;= <span class="number">0</span>:    <span class="comment"># 不允许年龄小于等于0</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;age too little&#x27;</span>) <span class="comment"># 爆出一个自顶一个Excep内容是age too little</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;name is &#x27;</span> + name</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;age is &#x27;</span> + str(age)</span><br></pre></td></tr></table></figure>
<p>上面这段代码只是简单地输入name和age两个变量，合法的话就输出出来。我们这里运行一下试试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># ./hello.py</span></span><br><span class="line">name: shawn     <span class="comment">#合法输入的话，就可以顺利输出</span></span><br><span class="line">age : 20</span><br><span class="line">name is shawn</span><br><span class="line">age is 20</span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># ./hello.py</span></span><br><span class="line">name:   <span class="comment"># 这里变量内容为空</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;./hello.py&quot;</span>, line 6, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    raise Exception(<span class="string">&#x27;name is null&#x27;</span>)     <span class="comment"># 就是在我设置的地方抛出了异常</span></span><br><span class="line">Exception: name is null <span class="comment"># 异常内容和类型都是我所规定的</span></span><br><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># ./hello.py</span></span><br><span class="line">name: shawn</span><br><span class="line">age : -1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;./hello.py&quot;</span>, line 10, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    raise Exception(<span class="string">&#x27;age too little&#x27;</span>)</span><br><span class="line">Exception: age too little</span><br></pre></td></tr></table></figure>
<p>我们可以用这种方式在自己的代码中抛出异常，用来做中间值检测，防止中间的数据出现意外导致一些不可思议的后果。</p>
<h1 id="0X02-捕获异常"><a href="#0X02-捕获异常" class="headerlink" title="0X02 捕获异常"></a>0X02 捕获异常</h1><p> 我们在代码中不管是解释器自己抛出的异常还是你手动抛出的异常，都可以手动的捕获到这个异常，并做出相应的处理。这样就可以提高代码的健壮性。在Python使用<code>try...except...else</code>来捕获处理异常。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 这里执行一些可能会抛出异常的代码</span></span><br><span class="line"><span class="keyword">except</span> (ExceptionA, ExceptionB, ExceptionC):   <span class="comment"># 一个except可以捕获好多个异常</span></span><br><span class="line">    <span class="comment"># 当抛出ABC三种异常的时候，执行这里的代码，执行完之后跳出try...except并继续执行代码</span></span><br><span class="line"><span class="keyword">except</span> ExceptD:</span><br><span class="line">    <span class="comment"># 当抛出D异常的时候就会执行这里的代码，执行完后也跳出</span></span><br><span class="line"><span class="keyword">except</span> ExceptE, e:</span><br><span class="line">    <span class="comment"># 当抛出E异常的时候在这里处理，e就是这个异常对象，我们可以看e中的信息</span></span><br><span class="line">    <span class="keyword">print</span> e <span class="comment"># 输出e</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 当抛出了一个上面两个except捕获不到的异常的时候，执行这里的操作</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 当没有异常抛出的时候执行这里的代码</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 不管代码有没有抛出异常，都会执行这里的代码</span></span><br></pre></td></tr></table></figure><br> 下面有一个样例，还是除0异常的样例，当除数是0的时候就抛出异常并捕获，然后处理这个异常（提示并重新输入），直到没有除0异常才计算成功并退出程序<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	num_1 = input(<span class="string">&#x27;num1: &#x27;</span>)</span><br><span class="line">	num_2 = input(<span class="string">&#x27;num2: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		num_3 = num_1 / num_2</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">&#x27;num_1 is 0 !!!&#x27;</span></span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">print</span> num_3</span><br><span class="line">		exit()</span><br></pre></td></tr></table></figure><br> 下面有一个运行样例<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># ./hello.py</span></span><br><span class="line">num1: 9</span><br><span class="line">num2: 0</span><br><span class="line">num_1 is 0 !!!</span><br><span class="line">num1: 2</span><br><span class="line">num2: 0</span><br><span class="line">num_1 is 0 !!!</span><br><span class="line">num1: 0</span><br><span class="line">num2: 0</span><br><span class="line">num_1 is 0 !!!</span><br><span class="line">num1: 4</span><br><span class="line">num2: 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br> 当然我们也可以将异常处理完了之后继续抛出，只要你需要。下面的代码和上面的是完全一样的，就只有12行的地方从continue换成了raise，意思就是抛出异常<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	num_1 = input(<span class="string">&#x27;num1: &#x27;</span>)</span><br><span class="line">	num_2 = input(<span class="string">&#x27;num2: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		num_3 = num_1 / num_2</span><br><span class="line">	<span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">&#x27;num_1 is 0 !!!&#x27;</span></span><br><span class="line">		<span class="keyword">raise</span>    <span class="comment"># 只有这里是不同的，从continue换成了没有参数的raise，就是把异常继续抛出</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">print</span> num_3</span><br><span class="line">		exit()</span><br></pre></td></tr></table></figure><br> 运行的样例就是下面这样的，执行下去之后会执行except中的处理代码，但是由于raise的存在还是会抛出这个异常<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ ~]<span class="comment"># ./hello.py</span></span><br><span class="line">num1: 123</span><br><span class="line">num2: 0</span><br><span class="line">num_1 is 0 !!!     <span class="comment"># 这里就是except处的处理代码</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;./hello.py&quot;</span>, line 9, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    num_3 = num_1 / num_2</span><br><span class="line">ZeroDivisionError: <span class="built_in">integer</span> division or modulo by zero</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Exception </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenSSH 配置 免密码登陆 公钥和私钥 私钥签名]]></title>
      <url>/2016/10/17/openssh-pub-pri/</url>
      <content type="html"><![CDATA[<h1 id="0X00-安装OpenSSH"><a href="#0X00-安装OpenSSH" class="headerlink" title="0X00 安装OpenSSH"></a>0X00 安装OpenSSH</h1><p>一般情况下我们的系统中都是自带SSH服务端和客户端的，万一没有的话就需要我们手动安装这个服务。</p>
<p><code>yum install -y openssh</code></p>
<p>然后重启OpenSSH服务</p>
<p><code>systemctl restart sshd</code></p>
<h1 id="0X01-两行简单的配置"><a href="#0X01-两行简单的配置" class="headerlink" title="0X01 两行简单的配置"></a>0X01 两行简单的配置</h1><p>OpenSSH的配置文件在<code>/etc/ssh/</code>目录下，有两个配置文件，一个是针对服务端的一个是针对客户端的，我们只需要修改针对服务端的<code>sshd_config</code>即可。</p>
<p>配置文件里比较重要的两行是<code>PermitRootLogin</code>和<code>PasswordAuthentication</code>。</p>
<ul>
<li><code>PermitRootLogin</code> 当这个值为yes时，才允许root用户使用ssh登陆</li>
<li><code>PasswordAuthentication</code> 当这个值为yes时，允许使用密码登陆，反之则拒绝密码登陆(只能使用密钥)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin yes</span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的配置就允许使用root用户登陆，也允许输入密码登陆</p>
</blockquote>
<a id="more"></a>

<h1 id="0X02-私钥和公钥————非对称加密"><a href="#0X02-私钥和公钥————非对称加密" class="headerlink" title="0X02 私钥和公钥————非对称加密"></a>0X02 私钥和公钥————非对称加密</h1><p>在ssh中可以使用用户名密码的形式登陆，也可以使用密钥的形式登陆。</p>
<p><strong>非对称加密</strong> 就是说加密和解密用的密码不同。非对称加密里有<strong>公钥</strong>和<strong>私钥</strong>，使用公钥加密的数据只有使用私钥才能解开，虽然是使用公钥加密的，但是并不能通过公钥反向解密。这点和传统的对称加密区别比较大。</p>
<p>下面假设有这么一个场景：有一台服务器S和三个管理员A1、A2、A3。  S生成了自己的一对公钥和私钥，将公钥公开出去，这时候A1就能能看到这个公钥，所以都可以用这个公钥将发给S的数据加密。虽然A2和A3也看到了这个公钥，但是不能通过这个公钥将这个加密的数据解开。数据只有在S上通过对应的私钥才能解开。</p>
<ul>
<li>公钥：一般是公开出去，并用于加密</li>
<li>私钥：保存在自己这里，用于解密<blockquote>
<p>公钥和私钥是一对的，一个公钥和一个私钥两两对应</p>
</blockquote>
</li>
</ul>
<h1 id="0X03-在SSH生成公钥和私钥"><a href="#0X03-在SSH生成公钥和私钥" class="headerlink" title="0X03 在SSH生成公钥和私钥"></a>0X03 在SSH生成公钥和私钥</h1><p>在Linux里SSH可以使用公钥和私钥来登陆系统，也就是前面我们说的那个<code>PasswordAuthentication</code>选项，如果禁止密码登陆的话就只能使用公钥和私钥登陆了。</p>
<p><code>ssh-keygen</code>可以生成一对公钥和私钥。我们一般在自己用户的主目录里的<code>.ssh</code>目录里执行这个命令、执行完了之后会提示输入加密，这里是给公钥私钥加密，可以暂时不用管，一路回车就行了，直到看到一堆乱七八糟的图像，类似于这样就算好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;root&#x2F;.ssh&#x2F;id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">09:7c:28:a5:75:sr:ab:5c:82:43:17:81:f8:78:zs:1e root@buyongkan.zhelishi.gaiguode</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|   . .+o.        |</span><br><span class="line">|  . .&#x3D;8o.        |</span><br><span class="line">|   oo+-+.        |</span><br><span class="line">|  . &#x3D;.oo..       |</span><br><span class="line">|   X +  SB.      |</span><br><span class="line">|    o . o        |</span><br><span class="line">|     o +         |</span><br><span class="line">|      )          |</span><br><span class="line">|                 |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>

<p><code>.ssh</code>目录如果不存在的话，执行一下<code>ssh localhost</code>然后输入密码登陆以下本地，就会有了。生成完之后目录里会多出两个文件，<code>id_rsa</code> 和 <code>id_rsa.pub</code> 后面pub结尾的是public也就是公钥，我们可以打开看看是一堆看似乱码的东西。</p>
<h1 id="0X04-使用公钥和私钥免密码登陆"><a href="#0X04-使用公钥和私钥免密码登陆" class="headerlink" title="0X04 使用公钥和私钥免密码登陆"></a>0X04 使用公钥和私钥免密码登陆</h1><p>如果我们有两台机器，一个叫Server一个叫Desktop，我想让Desktop可以免密码登陆到Server上，就可以用这个方法。</p>
<p>原理大概是这样的：在Desktop上生成一对公钥和私钥，然后将Desktop上的公钥追加到Server的<code>.ssh</code>目录下的<code>authorize_keys</code>里，这个文件就是用来保存可以免密码登录到自己机器上的那些用户的公钥的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ28jaak5nnZ .ssh]<span class="comment"># ssh-keygen  #生成一对公钥私钥</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">30:05:7d:63:sf:10:aa:cb:e1:b7:84:48:54:5f:42:4d root@iZ28jaak5nnZ</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">|..o o EO+o...    |</span></span><br><span class="line"><span class="string">| o = * n. +.     |</span></span><br><span class="line"><span class="string">|  + * N  o .     |</span></span><br><span class="line"><span class="string">|   S + a         |</span></span><br><span class="line"><span class="string">|    . . S        |</span></span><br><span class="line"><span class="string">|m            s   |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|    x            |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">+-----------------+</span></span><br><span class="line"><span class="string">[root@iZ28jaak5nnZ .ssh]# ssh-copy-id -i id_rsa.pub root@182.234.214.243 #使用ssh-copy-id来将自己的公钥发送到Server上去，会自动找到那个文件</span></span><br><span class="line"><span class="string">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span></span><br><span class="line"><span class="string">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span></span><br><span class="line"><span class="string">root@182.254.214.250&#x27;</span>s password:   <span class="comment"># 还没配置好所以要输密码</span></span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   <span class="string">&quot;ssh &#x27;root@182.254.214.250&#x27;&quot;</span></span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br><span class="line">[root@iZ28jaak5nnZ .ssh]<span class="comment"># ssh root@182.254.214.250  # 登陆</span></span><br><span class="line">Last login: Mon Oct 17 13:47:23 2016 from 43.13.56.7</span><br><span class="line">☁  ~  hostname  <span class="comment"># 成功登陆</span></span><br><span class="line">blog.just666.cn</span><br><span class="line">☁  ~  </span><br></pre></td></tr></table></figure>

<h1 id="0X05-使用私钥签名"><a href="#0X05-使用私钥签名" class="headerlink" title="0X05 使用私钥签名"></a>0X05 使用私钥签名</h1><p>公钥私钥对可以对数据加密，是用公钥加密私钥解密。也可以使用公钥私钥对进行数字签名。</p>
<p>当Server公开自己的公钥之后，大家都可以用这个公钥进行加密，然后传给Server，Server用私钥解密就能看到内容。</p>
<p>Server如果想加密一段数据给其他人的话，可以用自己的私钥加密，将密文发送给其他人，其他人就能用Server的<strong>公钥去解密</strong>。因为除了Server意外，任何人都不知道Server的私钥，所以其他人可以确信这条消息是Server发出来的。这种行为称之为<strong>签名</strong>。</p>
<p>注意一个问题：<strong>公钥加密的数据可以用私钥解开</strong>且<strong>私钥加密的数据也可以用公钥解开</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Encryption </tag>
            
            <tag> OpenSSH </tag>
            
            <tag> Public Key </tag>
            
            <tag> Private Key </tag>
            
            <tag> Signature </tag>
            
            <tag> Asymmetric Encryption </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Shell编程入门笔记  新手教程]]></title>
      <url>/2016/10/02/shell-programming/</url>
      <content type="html"><![CDATA[<h1 id="0X00-hello-world"><a href="#0X00-hello-world" class="headerlink" title="0X00 hello,world"></a>0X00 hello,world</h1><p>从一本<em>The C Programming Language</em>开始，我们就开始了几十年的’hello,world’之路。从那以后，机会所有的教程都从输出一句’hello,world’开始，这次也不例外。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello,world&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里的第一行是注释，这个注释是很特殊的，他会告诉系统我们使用哪个解释器来运行下面的代码，这里我们用的是<code>/bin/bash</code>，当然Python的代码就要加上<code>#!/usr/bin/python</code>。<br>第二行就是输出一句’hello,world’。<code>echo</code>就是输出语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@mail shell]# chmod +x test.sh</span><br><span class="line">[root@mail shell]# .&#x2F;test.sh</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><p>执行之前要给脚本一个x权限，也就是执行权限。然后直接运行就行了。还有一种运行方式是<code>/bin/bash test.sh</code> 这样就是执行bash这个命令，将test.sh作为参数传进去，这样就可以不必写第一行的解释器声明。但是建议使用第一种方式执行脚本。</p>
<h1 id="0X01-使用变量"><a href="#0X01-使用变量" class="headerlink" title="0X01 使用变量"></a>0X01 使用变量</h1><p>既然是编程，那一定会有变量。Shell编程里的变量和C、Java不同，我们不需要声明一个变量就能直接赋值，想下面这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意一点，我们在写一些代码的时候，可能习惯了像这样使用操作符<code>str = &quot;hello,world&quot;</code>,也就是在操作符两端加上空格。但是在Shell编程里这样做是被禁止的，加了空格就会导致语法错误。所以Shell编程里的空格限制是很严格的。</p>
</blockquote>
<p>给一个新的变量赋值的时候我们可以直接写变量名，但是我们调用这个变量的时候要给变量名前面加上一个<code>$</code>符号，就像上面我写的那样。当然最好写成下面这种形式<code>$&#123;str&#125;</code>因为这样会更加清晰的显示出变量名。</p>
<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>在Shell中有一种变量叫‘只读变量’，顾名思义，这种变量的值不会被改变，是固定的，我们这样来声明一个只读变量<code>readonly str</code>。只读变量之前也是可以随意更改的，只是在后面给它加上了一个只读属性而已，就像下面这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> str</span><br><span class="line">str=<span class="string">&quot;hey,world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> str</span><br></pre></td></tr></table></figure>
<p>就会报错：’./hello.sh: line 5: str: readonly variable’</p>
<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>当我们不再使用一个变量的时候，可以把这个变量删除掉</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="built_in">unset</span> str</span><br><span class="line"><span class="built_in">echo</span> str</span><br></pre></td></tr></table></figure>
<p>这里什么都不会输出，因为并没有str这个变量。在Shell中输出一个并不存在的变量不会有提示。</p>
<h1 id="0X02-执行一行命令"><a href="#0X02-执行一行命令" class="headerlink" title="0X02 执行一行命令"></a>0X02 执行一行命令</h1><p>既然是Shell编程，那么执行命令是最重要的事情了。所以在Shell编程里执行命令也是非常简单的，直接把要执行的命令写到这里就行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">lscpu  <span class="comment">#这个命令是查看CPU相关信息的</span></span><br></pre></td></tr></table></figure>

<h1 id="0X03-字符串"><a href="#0X03-字符串" class="headerlink" title="0X03 字符串"></a>0X03 字符串</h1><p>字符串可以用单引号包起来，也可以用双引号包起来。单引号包起来的字符串会原封不动，会忽略转义字符和变量；双引号包起来的字符串会识别转义字符和变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">&quot;hello&quot;</span></span><br><span class="line">str1=<span class="string">&#x27;$a, world&#x27;</span>  <span class="comment">#单引号字符串</span></span><br><span class="line">str2=<span class="string">&quot;<span class="variable">$a</span>, world&quot;</span>  <span class="comment">#双引号字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str2</span></span><br></pre></td></tr></table></figure>

<p>输出是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@mail shell]<span class="comment"># ./hello.sh</span></span><br><span class="line"><span class="variable">$a</span>, wrld        <span class="comment">#可以看到这里没有识别到变量</span></span><br><span class="line">hello, world    <span class="comment">#这里是识别到了变量的</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>Shell里拼接字符串的语法非常简陋，直接把两个字符串变量写在一起就行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str1=<span class="string">&quot;hello,&quot;</span></span><br><span class="line">str2=<span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str1</span><span class="variable">$str2</span>  <span class="comment">#就这么简单粗暴</span></span><br></pre></td></tr></table></figure>
<p>这样就可以输出一个’hello,world’了</p>
<h2 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h2><p>在Shell编程里获取字符串长度不是通过一个len方法或者.length属性获取，而是通过下面这种并不直观的方式获取长度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line">str_len=<span class="variable">$&#123;#str&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str_len</span></span><br></pre></td></tr></table></figure>

<h2 id="部分截取"><a href="#部分截取" class="headerlink" title="部分截取"></a>部分截取</h2><p>在Shell编程里我们可以截取一个字符串中的某一段，只需要两个参数，一个来指定开始位置，一个来指定结束位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:1:4&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样可以截取str字符串从1到4的部分。是一个闭区间，从0开始计数。</p>
<h2 id="查找位置"><a href="#查找位置" class="headerlink" title="查找位置"></a>查找位置</h2><p>我们经常会需要从一段字符串里找到某个字符出现的位置，可以通过下面的方法来查找。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;hello,world&quot;</span></span><br><span class="line">index=`expr index <span class="string">&quot;<span class="variable">$str</span>&quot;</span> lo` <span class="comment">#查找l或者o这个字符首次出现在字符串的哪个位置</span></span><br></pre></td></tr></table></figure>


<h1 id="0X04-搞个数组"><a href="#0X04-搞个数组" class="headerlink" title="0X04 搞个数组"></a>0X04 搞个数组</h1><p>既然是编程，那么当然要有数组这个最基本的数据结构了。但是Shell只支持一维数组，并不支持二维和多维数组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array_str=(<span class="string">&quot;hello&quot;</span> <span class="string">&quot;hey&quot;</span> <span class="string">&quot;nihao&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_str[2]&#125;</span> <span class="comment">#定义的时候用的是小括号，调用的时候是大括号</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_str[@]&#125;</span> <span class="comment">#这里的一个@表示数组里的所有内容</span></span><br></pre></td></tr></table></figure>

<h2 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h2><p>获取数组长度的方式和获取字符串长度的方式差不太多。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array_str=(<span class="string">&quot;hello&quot;</span> <span class="string">&quot;hey&quot;</span> <span class="string">&quot;nihao&quot;</span>)</span><br><span class="line">length=<span class="variable">$&#123;#array_str[@]&#125;</span> <span class="comment">#获取数组长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$length</span></span><br><span class="line">length=<span class="variable">$&#123;#array_str[2]&#125;</span> <span class="comment">#获取数组中某个元素的长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$length</span></span><br></pre></td></tr></table></figure>

<h1 id="0X05-别忘了注释"><a href="#0X05-别忘了注释" class="headerlink" title="0X05 别忘了注释"></a>0X05 别忘了注释</h1><p>编程的时候给关键代码加上注释是一个非常好的习惯。Shell编程里只支持单行注释，不支持多行注释。单行注释是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">#str=&quot;world&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br></pre></td></tr></table></figure>
<p>这样输出的结果是’hello’而不是’world’因为哪一行被注释掉了，并不会执行。<br>那么我们需要多行注释怎么办呢？其实也不是不可以，我们可以用一个诡异的方式来实现多行注释：把需要注释掉的代码改写成一个函数，只要我们在后面不去调用这个函数，那不就和被注释掉是一样的效果了嘛。关于函数的问题下面会说的。</p>
<h1 id="0X06-Shell参数"><a href="#0X06-Shell参数" class="headerlink" title="0X06 Shell参数"></a>0X06 Shell参数</h1><p>我们的Shell脚本经常是需要传入参数进来的，那么应该怎么传进来呢？我们有下面一段代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1. <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2. <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;3. <span class="variable">$3</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;all is <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;pid is $$&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们运行一下这段代码，并传入两个参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@mail shell]<span class="comment"># ./hello.sh hello world</span></span><br><span class="line">1. hello</span><br><span class="line">2. world</span><br><span class="line">3.</span><br><span class="line">all is 2</span><br><span class="line">pid is 22017</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$1 $2 $3 这些参数表示：传入的第几个参数<br>$# 表示传入的参数总数<br>$$ 表示这个脚本运行的PID  （进程号）</p>
</blockquote>
<h1 id="0X07-运算符"><a href="#0X07-运算符" class="headerlink" title="0X07 运算符"></a>0X07 运算符</h1><p>运算符示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">val=`expr 1 + 1` <span class="comment">#注意空格问题</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$val</span></span><br></pre></td></tr></table></figure>
<p>最常见的 <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>=</code> <code>==</code> 全都有的，不过注意的一点是，运算符两边一定要加空格，一定。</p>
<h2 id="bool布尔运算"><a href="#bool布尔运算" class="headerlink" title="bool布尔运算"></a>bool布尔运算</h2><p><code>!</code>  非<br><code>-o</code> 或<br><code>-a</code> 且<br>-eq 是‘判断是否相等，相等则true’</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -eq <span class="variable">$b</span> -o <span class="variable">$a</span> == 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;not ok&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>这段代码输出的是’ok’因为虽然$a和$b并不相等，但是后面的<code>-o</code>表示或，或后面的<code>$a == 1</code>成立了，所以还是输出了ok</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p><code>&amp;&amp;</code> and<br><code>||</code> or<br>下面这段Demo代码和上面的效果几乎是一样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> -eq <span class="variable">$b</span> || <span class="variable">$a</span> == 1 ]] <span class="comment">#这里比上面多了一组中括号</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;not ok&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p><code>=</code>  这里不是赋值，是判断两个字符串是否相等<br><code>!=</code> 这里是判断不相等<br><code>-n</code> 检测字符串长度，不为0则返回true<br><code>-z</code> 检测字符串长度，为0则返回true<br><code>str</code> 检测字符串是否为空，这里的str表示一切字符串或者变量</p>
<h2 id="运算符总结："><a href="#运算符总结：" class="headerlink" title="运算符总结："></a>运算符总结：</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运算符	说明	                                        举例</span><br><span class="line">+	     加法	                                    &#96;expr $a + $b&#96; 结果为 30。</span><br><span class="line">-	     减法	                                    &#96;expr $a - $b&#96; 结果为 -10。</span><br><span class="line">*	     乘法	                                    &#96;expr $a \* $b&#96; 结果为  200。</span><br><span class="line">&#x2F;	     除法	                                    &#96;expr $b &#x2F; $a&#96; 结果为 2。</span><br><span class="line">%	     取余	                                    &#96;expr $b % $a&#96; 结果为 0。</span><br><span class="line">&#x3D;	     赋值	a&#x3D;$b 将把变量 b 的值赋给 a。</span><br><span class="line">&#x3D;&#x3D;	     相等。用于比较两个数字，相同则返回 true。	[ $a &#x3D;&#x3D; $b ] 返回 false。</span><br><span class="line">!&#x3D;	     不相等。用于比较两个数字，不相同则返回 true。[ $a !&#x3D; $b ] 返回 true。</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运算符	说明	                                      举例</span><br><span class="line">-eq	   检测两个数是否相等，相等返回 true。	 [ $a -eq $b ] 返回 false。</span><br><span class="line">-ne	   检测两个数是否相等，不相等返回 true。[ $a -ne $b ] 返回 true。</span><br><span class="line">-gt	   检测左边的数是否大于右边的，如果是，则返回 true。[ $a -gt $b ] 返回 false。</span><br><span class="line">-lt	   检测左边的数是否小于右边的，如果是，则返回 true。[ $a -lt $b ] 返回 true。</span><br><span class="line">-ge	   检测左边的数是否大等于右边的，如果是，则返回 true。[ $a -ge $b ] 返回 false。</span><br><span class="line">-le	   检测左边的数是否小于等于右边的，如果是，则返回 true。[ $a -le $b ] 返回 true。</span><br></pre></td></tr></table></figure>

<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运算符	说明	                                             举例</span><br><span class="line">!	     非运算，表达式为 true 则返回 false，否则返回 true。[ ! false ] 返回 true。</span><br><span class="line">-o	    或运算，有一个表达式为 true 则返回 true。          [ $a -lt 20 -o $b -gt 100 ] 返回 true。</span><br><span class="line">-a	    与运算，两个表达式都为 true 才返回 true。	         [ $a -lt 20 -a $b -gt 100 ] 返回 false。</span><br></pre></td></tr></table></figure>

<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运算符	说明	      举例</span><br><span class="line">&amp;&amp;	    逻辑的 AND	[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</span><br><span class="line">||	    逻辑的 OR	 [[ $a -lt 100 || $b -gt 100 ]] 返回 true</span><br></pre></td></tr></table></figure>

<h3 id="字符串运算符-1"><a href="#字符串运算符-1" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运算符	说明	                                   举例</span><br><span class="line">&#x3D;	     检测两个字符串是否相等，相等返回 true。  [ $a &#x3D; $b ] 返回 false。</span><br><span class="line">!&#x3D;	    检测两个字符串是否相等，不相等返回 true。[ $a !&#x3D; $b ] 返回 true。</span><br><span class="line">-z	    检测字符串长度是否为0，为0返回 true。    [ -z $a ] 返回 false。</span><br><span class="line">-n	    检测字符串长度是否为0，不为0返回 true。  [ -n $a ] 返回 true。</span><br><span class="line">str   	检测字符串是否为空，不为空返回 true。	   [ $a ] 返回 true。</span><br></pre></td></tr></table></figure>

<h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">操作符	 说明	                                             举例</span><br><span class="line">-b file	检测文件是否是块设备文件，如果是，则返回 true。	   [ -b $file ] 返回 false。</span><br><span class="line">-c file	检测文件是否是字符设备文件，如果是，则返回 true。	 [ -c $file ] 返回 false。</span><br><span class="line">-d file	检测文件是否是目录，如果是，则返回 true。	         [ -d $file ] 返回 false。</span><br><span class="line">-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。[ -f $file ] 返回 true。</span><br><span class="line">-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	 [ -g $file ] 返回 false。</span><br><span class="line">-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。[ -k $file ] 返回 false。</span><br><span class="line">-p file	检测文件是否是具名管道，如果是，则返回 true。	     [ -p $file ] 返回 false。</span><br><span class="line">-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	 [ -u $file ] 返回 false。</span><br><span class="line">-r file	检测文件是否可读，如果是，则返回 true。	           [ -r $file ] 返回 true。</span><br><span class="line">-w file	检测文件是否可写，如果是，则返回 true。	           [ -w $file ] 返回 true。</span><br><span class="line">-x file	检测文件是否可执行，如果是，则返回 true。	         [ -x $file ] 返回 true。</span><br><span class="line">-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。[ -s $file ] 返回 true。</span><br><span class="line">-e file	检测文件（包括目录）是否存在，如果是，则返回 true。[ -e $file ] 返回 true。</span><br></pre></td></tr></table></figure>

<h1 id="0X08-条件判断语句"><a href="#0X08-条件判断语句" class="headerlink" title="0X08 条件判断语句"></a>0X08 条件判断语句</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>Shell 编程里的if语句和平时接触的编程语言有点区别</p>
<ol>
<li>if后面要加一个中括号，中括号之间是条件，而且中括号前后都要有一个空格；</li>
<li>if调节写好之后要写一个then表示接下来执行什么</li>
<li>then结束之后如果没有别的条件了的话就接一个if的逆字符串fi来表示if语句结束</li>
<li>如果还有其他条件那就用elif，然后也是一个中括号里写条件，then后面接要执行的语句</li>
<li>最后的else可写可不写，表示上面的条件没达成的话要执行的语句。</li>
<li>if语句的最后一定是一个fi，表示if语句的结束</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> == <span class="string">&quot;1&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;input is 1&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> == <span class="string">&quot;2&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;input is 2&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> == <span class="string">&quot;3&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;input is 3&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;input is big&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>运行起来是这样的，比如我运行的参数是<code>./hello.sh 2 </code>，那么就会输出’2’</p>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>跟if一起的一般还有一个switch-case语句，但是Shell里没有switch这个关键字，但是功能是一样的。<code>case $1 in</code>表示的是$1这个变量去对比下面的选项。下面的每一个选项都要加一个回括号，然后写上要执行的语句，再加上两个连续的分号，表示这一段结束，最后的<code>* )</code>表示匹配其他全部没有匹配到的可能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;1&quot;</span> )</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;word is 1&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">&quot;2&quot;</span> )</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;word is 2&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    * )</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;word is other&quot;</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h1 id="0X09-几种循环"><a href="#0X09-几种循环" class="headerlink" title="0X09 几种循环"></a>0X09 几种循环</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>在Shell编程里有我们非常熟悉的for循环，但是语法个其他编程语言还是有一定的出入。<br>在Shell里用for循环的话，要给每一段循环体加上<code>do...done</code>，表示这之间的代码是循环体，注意for的一行后面没有冒号，像Python的话就会有个冒号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&quot;hello,wrld&quot;</span>	<span class="comment">#循环输出字符串中的每个字符</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> 1 2 3 4 5      <span class="comment">#循环输出列表中的每一个数据</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>in</code>关键字前面是一个a后面是一堆数据，我们可以理解成把a从后面的一堆数据上走一遍，也就是说相当于Python代码中这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;234&#x27;</span>, <span class="string">&#x27;345&#x27;</span>, <span class="string">&#x27;456&#x27;</span>]:</span><br><span class="line">	<span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$1</span> == <span class="string">&quot;2&quot;</span> ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>这段代码如果我是这样运行<code>./hello.sh 2</code> 那么因为<code>$1</code>是2所以就会进入死循环，否则就什么都不会输出。<br>while循环就是说，如果while后面的表达式成立，那么就执行一次循环。因为我这段代码没有改变$1的值，所以才会出现要么无输出要么死循环的情况。我们改成下面这种情况就好了，这意思是当我运行这个脚本，就执行10次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$a</span> -lt 10 ]]  <span class="comment">#这里的 -lt 的意思是 &#x27;当左边的值小于右边的值就返回true&#x27;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    a=<span class="variable">$a</span>+1</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><p>until循环就相当于C和Java中的do-while循环，表示一个‘直到’的效果。下面就是说，执行循环体里的内容，一直到$a的变量大于右边的数值的时候才停止，所以才输出了11次’hello,world’</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line">until [[ <span class="variable">$a</span> -gt 10 ]];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    a=<span class="variable">$a</span>+1</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h1 id="0X0A-写个函数"><a href="#0X0A-写个函数" class="headerlink" title="0X0A 写个函数"></a>0X0A 写个函数</h1><p>Shell里的函数有两种定义方式，效果是一样的。</p>
<h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>方案一是直接写函数名，后面接一个括号，然后大括号里写上函数体就好了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">myFunction</span></span>()&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><p>方案二是<code>function name()</code>这样定义，先声明这是一个函数，然后写上函数名，最后也是一对小括号，大括号里写函数体。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">name</span></span>()&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shell的函数也是有返回值的，不过返回值的类型很少不像Java中可以返回数字字符串甚至返回对象，在Shell中只能返回数字，还只能是0~255的。变量只有8个二进制位，就算你返回了一个255以上的数字也会返回出溢出之后的数字的。返回值是不可以赋值的，想使用函数的返回值的话要用<code>$?</code>，这个符号代表上一次调用的函数的返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">my</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my 1</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">my 10</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">my 256</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">my -2</span><br><span class="line"><span class="built_in">echo</span> $?</span><br><span class="line">my 123.123</span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
<p>这里前两个可以正常输出，256因为溢出了所以输出不正常，负数和浮点数不支持。</p>
<h1 id="0X0B-test测试"><a href="#0X0B-test测试" class="headerlink" title="0X0B test测试"></a>0X0B test测试</h1><p>test测试可以测试各种数据，包括数字、字符串、文件。使用方法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e /etc/passwd <span class="comment">#判断是否存在这个文件</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;ok&quot;</span>  <span class="comment">#存在则输出ok</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;no&quot;</span>  <span class="comment">#不存在则输出no</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="针对数字的测试"><a href="#针对数字的测试" class="headerlink" title="针对数字的测试"></a>针对数字的测试</h2><p>-eq    等于则为真<br>-ne    不等于则为真<br>-gt    大于则为真<br>-ge    大于等于则为真<br>-lt    小于则为真<br>-le    小于等于则为真</p>
<h2 id="针对字符串的测试"><a href="#针对字符串的测试" class="headerlink" title="针对字符串的测试"></a>针对字符串的测试</h2><p>=    等于则为真<br>!=    不相等则为真<br>-z 字符串    字符串的长度为零则为真<br>-n 字符串    字符串的长度不为零则为真</p>
<h2 id="针对文件的测试"><a href="#针对文件的测试" class="headerlink" title="针对文件的测试"></a>针对文件的测试</h2><p>-e 文件名    如果文件存在则为真<br>-r 文件名    如果文件存在且可读则为真<br>-w 文件名    如果文件存在且可写则为真<br>-x 文件名    如果文件存在且可执行则为真<br>-s 文件名    如果文件存在且至少有一个字符则为真<br>-d 文件名    如果文件存在且为目录则为真<br>-f 文件名    如果文件存在且为普通文件则为真<br>-c 文件名    如果文件存在且为字符型特殊文件则为真<br>-b 文件名    如果文件存在且为块特殊文件则为真</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python之面向对象]]></title>
      <url>/2016/09/14/python-oop/</url>
      <content type="html"><![CDATA[<h1 id="0X00-创建一个类"><a href="#0X00-创建一个类" class="headerlink" title="0X00 创建一个类"></a>0X00 创建一个类</h1><p>Python也是一个和C++、Java一样的面向对象编程语言，所以Python里也有类和对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span>   <span class="comment">#这是一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span>(<span class="params">self</span>):</span>     <span class="comment">#这是一个方法</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setName</span>(<span class="params">self, inputName</span>):</span></span><br><span class="line">        self.name = inputName</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.getName()</span><br></pre></td></tr></table></figure>
<p>在类中创建的方法使用def关键字定义，每个方法有一个或以上的参数，selft就是实例化的对象自己。需要返回值就return一个，不需要就可以不写return</p>
<blockquote>
<p>Python的类和Java的类还是有点区别，Java的类里主要写的是属性和方法，Python里不写属性，因为Java的变量需要定义而Python的变量并不需要定义，最多也就是在前面个各个属性一个变量名并赋初值</p>
</blockquote>
<h1 id="0X01-实例化一个对象"><a href="#0X01-实例化一个对象" class="headerlink" title="0X01 实例化一个对象"></a>0X01 实例化一个对象</h1><p>类是一个很抽象的概念，可以由类实例化好多个对象出来。Java中我们习惯说成 new一个对象，而Python中并不需要new</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = Person() <span class="comment">#实例化了一个类</span></span><br><span class="line">xiaoming.setName(<span class="string">&#x27;xiaoming&#x27;</span>)  <span class="comment">#调用一个方法</span></span><br><span class="line"><span class="keyword">print</span> xiaoming.getName()</span><br><span class="line">xiaoming.sayHello()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此段代码接着上面的类声明</p>
</blockquote>
<a id="more"></a>

<h1 id="0X02-Python的私有"><a href="#0X02-Python的私有" class="headerlink" title="0X02 Python的私有"></a>0X02 Python的私有</h1><p>Java和其他好多面向对象编程语言中会有一个private关键字，将属性和方法约束为私有的。然而Python并不能直接支持private，间接地支持也不是真正的private。在Python中的private由一种诡异的方式模拟，在方法前加上连续的两个下划线</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hello</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">print</span> self.__hello()</span><br><span class="line"></span><br><span class="line">xiaoming = Person()</span><br><span class="line">xiaoming.sayHello()</span><br><span class="line">xiaoming.__hello()</span><br></pre></td></tr></table></figure>
<p>运行起来就是这样的，前面的<code>xiaoming.sayHello()</code>因为是可以直接调用的，然后在方法里调用了私有的<code>__hello()</code>方法，所以可以正常执行；后面的<code>xiaoming.__hello()</code>因为不能直接调用，所以报错了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello,world</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;./hello.py&quot;</span>, line 12, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    xiaoming.__hello()</span><br><span class="line">AttributeError: Person instance has no attribute <span class="string">&#x27;__hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其实在方法前面加了两个下划线并没有真的把方法改了个名字而已，改成了<code>_Class__name</code>的类型，一个下划线+类名+两个下划线+方法名，当我们知道了这个问题之后就可以这样调用‘私有’方法了，但是既然我们都将其设为了’私有’就不要这么用了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>xiaoming = Person()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> xiaoming._Person__hello() <span class="comment">#不要这样做，虽然可行</span></span><br><span class="line">    hello,world</span><br></pre></td></tr></table></figure>

<h1 id="0X03-继承"><a href="#0X03-继承" class="headerlink" title="0X03 继承"></a>0X03 继承</h1><p>面向对象编程的特性之一：继承。Python中的继承和Java的语法差异还是挺大的，像下面这样可以声明两个类，让 一个类继承自另一个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;hello, I&#x27;m person&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;helo, I&#x27;m Jack&quot;</span></span><br><span class="line"></span><br><span class="line">person = Person()</span><br><span class="line">jack   = Jack()</span><br><span class="line"></span><br><span class="line">person.sayHello()</span><br><span class="line">jack.sayHello()</span><br></pre></td></tr></table></figure>
<p>输出是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, I<span class="string">&#x27;m person</span></span><br><span class="line"><span class="string">helo, I&#x27;</span>m Jack</span><br></pre></td></tr></table></figure>
<p>这也体现了面向对象的覆盖的思想</p>
<h1 id="0X04-多继承"><a href="#0X04-多继承" class="headerlink" title="0X04 多继承"></a>0X04 多继承</h1><p>一个类可以继承自另一个类，也可以继承自其他好多个类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span>  <span class="comment">#一个父类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;i&#x27;can learn&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coder</span>:</span>    <span class="comment">#另一个父类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">programming</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;I&#x27;can programming&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jack</span>(<span class="params">Student, Coder</span>):</span> <span class="comment">#继承自两个雷的子类</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">jack = Jack()</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以调用两个父类中的方法</span></span><br><span class="line">jack.learn()</span><br><span class="line">jack.programming()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>书写多继承的时候要注意一个问题，如果某类继承自两个类，且那两个类有相同的方法，那么就会造成覆盖（重写）<br>是这样一个情况，如果我上面的Student和Coder类都有一个名为eat的方法，但是Student类里的eat方法是输出‘student can eat’但是‘Coder’类中eat方法是输出’coder can eat’，那么在写子类的时候就要格外小心<br>如果子类这样写<code>class Jack(Student, Coder)</code>那么这个子类的ear方法就会是’Coder‘’中的方法，输出‘Coder can eat’，如果这样写<code>class Jack(Coder, Student)</code>的话，输出就是’Student can eat‘’</p>
</blockquote>
<h1 id="0X05-构造方法"><a href="#0X05-构造方法" class="headerlink" title="0X05 构造方法"></a>0X05 构造方法</h1><p>我们实例化一个对象的时候是这样做的<code>xiaoming = Person()</code>其内部是调用了Person类的构造方法并返回给了xiaoming这个变量。在Java中在java中构造方法是一个没有返回类型的与类名同名的方法，但是在Python中所有构造方法都叫<code>__init__()</code>。自己不手动写构造方法的话Python就会自动生成一个，这点和Java相同。当然我们也可以自己手写构造方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;new a person&#x27;</span></span><br><span class="line"></span><br><span class="line">xiaoming = Person()</span><br></pre></td></tr></table></figure>
<p>会输出一个<code>new a person</code> 这就能证明确实在实例化对象的时候回先调用这个类的构造方法。构造方法可以加参数，就像下面这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, say=<span class="string">&#x27;new a person&#x27;</span></span>):</span></span><br><span class="line">        <span class="keyword">print</span> say</span><br></pre></td></tr></table></figure>
<p>如果我实例化对象的时候这么写<code>xiaoming = Person()</code>那么就会输出一个’new a person’的字符串，因为我没传入参数，所以就使用了默认值，但是如果我这样实例化对象<code>xiaohong = Person(&#39;xiaohong&#39;)</code>就会输出一个’xiaohong’的字符串，因为我给构造方法传入参数了。<br>在Python中还有一个叫析构方法的<code>__del__</code>但是我们最好不要去碰它，因为Python里有像Java类似的自动垃圾回收，所以几乎不会需要我们自己去析构一个对象，但是如果真的有需要，也可以像C++一样手动析构</p>
<h1 id="0X06-方法的重写"><a href="#0X06-方法的重写" class="headerlink" title="0X06 方法的重写"></a>0X06 方法的重写</h1><p>如果有一个类A，A中有一个sayHello的方法，然后有一个B类继承了A类，那么自然就也有了sayHello的方法，但是如果我们给B类单独设定sayHello方法会怎么样呢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;i&#x27;m Person&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;i&#x27;m Man&quot;</span></span><br><span class="line"></span><br><span class="line">xiaoming = Man()</span><br><span class="line">xiaoming.sayHello()</span><br></pre></td></tr></table></figure>
<p>输出的是”i’m Man”而不是”i’m Person”。这就是方法的重写，子类中写了一个和父类中相同名的方法，就会把已经继承过来的方法重写掉</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> OOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python之字典]]></title>
      <url>/2016/09/13/python-dict/</url>
      <content type="html"><![CDATA[<h1 id="0X00-什么是字典"><a href="#0X00-什么是字典" class="headerlink" title="0X00 什么是字典"></a>0X00 什么是字典</h1><p>字典，顾名思义就是通过一个条件可以找到相应的值，字典由Key-Value组成。像是下面这样创建一个字典<br>字典中的数据是没有顺序的，不像列表一样有顺序，在字典中是没有固定顺序的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">22</span>&#125;  <span class="comment">#直接创建一个字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a</span><br><span class="line">    &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;F&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> a[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    xiaoming</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = dict(name=<span class="string">&#x27;xiaogang&#x27;</span>, sex=<span class="string">&#x27;M&#x27;</span>, age=<span class="number">23</span>)	 <span class="comment">#通过dict函数创建一个字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> b[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    xiaogang</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下文说的Key就是键， Value就是值<br>Key-Value 就是键值对，一个键对应着一个值<br>Key的值是可以随意改变的，但是Key的类型是固定的不能改变<br>如果为一个不存在的键赋值，那么会自动添加这个K-V</p>
</blockquote>
<a id="more"></a>

<h1 id="0X01-字典操作"><a href="#0X01-字典操作" class="headerlink" title="0X01 字典操作"></a>0X01 字典操作</h1><h2 id="len-测量长度"><a href="#len-测量长度" class="headerlink" title="len 测量长度"></a>len 测量长度</h2><p>测量这个字典中有多少</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> len(d)</span><br><span class="line">	<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="d-k-调用字典"><a href="#d-k-调用字典" class="headerlink" title="d[k] 调用字典"></a>d[k] 调用字典</h2><p>根据已知的Key来查找Key所对应的Value</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123456&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> d[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">	admin</span><br></pre></td></tr></table></figure>

<h2 id="d-k-v-字典赋值"><a href="#d-k-v-字典赋值" class="headerlink" title="d[k] = v    字典赋值"></a>d[k] = v    字典赋值</h2><p>为某个特定的Key赋值，如果这个Key在字典中不存在则创建这个Key</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123456&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;password&#x27;</span>] = <span class="string">&#x27;2336666&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> d[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">	<span class="number">2336666</span></span><br></pre></td></tr></table></figure>

<h2 id="del-d-k-删除Key-Value"><a href="#del-d-k-删除Key-Value" class="headerlink" title="del d[k] 删除Key-Value"></a>del d[k] 删除Key-Value</h2><p>删除相应的Key和Value</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123456&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> d</span><br><span class="line">	&#123;<span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="string">&#x27;username&#x27;</span>]	<span class="comment">#删除一个不存在的K-V会抛出异常</span></span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">      File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    KeyError: <span class="string">&#x27;username&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="k-in-d-成员检查"><a href="#k-in-d-成员检查" class="headerlink" title="k in d 成员检查"></a>k in d 成员检查</h2><p>检查某字典中是否存在某Key，成员检查时用的是Key而不是Value</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123456&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;username&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line">	<span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;phonenumber&#x27;</span> <span class="keyword">in</span> d</span><br><span class="line">	<span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="0X02-字典的递归"><a href="#0X02-字典的递归" class="headerlink" title="0X02 字典的递归"></a>0X02 字典的递归</h1><p>字典中是Key-Value，然而字典的Value是可以是字典的，也就是Key-Value的Value是字典，也就是递归。<br>这样就可以建立一个递归的字典，字典里的字典可以是一层一层递归包括下去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phones = &#123;</span><br><span class="line">        <span class="string">&#x27;xiaoming&#x27;</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;num&#x27;</span>:<span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;addr&#x27;</span>:<span class="string">&#x27;hebei&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;xiaohua&#x27;</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;num&#x27;</span>:<span class="string">&#x27;456&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;addr&#x27;</span>:<span class="string">&#x27;sichuan&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> phones</span><br><span class="line">    &#123;<span class="string">&#x27;xiaoming&#x27;</span>: &#123;<span class="string">&#x27;num&#x27;</span>: <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;addr&#x27;</span>: <span class="string">&#x27;hebei&#x27;</span>&#125;, <span class="string">&#x27;xiaohua&#x27;</span>: &#123;<span class="string">&#x27;num&#x27;</span>: <span class="string">&#x27;456&#x27;</span>, <span class="string">&#x27;addr&#x27;</span>: <span class="string">&#x27;sichuan&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> phones[<span class="string">&#x27;xiaoming&#x27;</span>]</span><br><span class="line">    &#123;<span class="string">&#x27;num&#x27;</span>: <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;addr&#x27;</span>: <span class="string">&#x27;hebei&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> phones[<span class="string">&#x27;xiaoming&#x27;</span>][<span class="string">&#x27;addr&#x27;</span>]</span><br><span class="line">    hebei</span><br></pre></td></tr></table></figure>

<h1 id="0X03-字典方法"><a href="#0X03-字典方法" class="headerlink" title="0X03 字典方法"></a>0X03 字典方法</h1><p>字典有好多方法可以调用，对字典进行操作</p>
<h2 id="clear-清除"><a href="#clear-清除" class="headerlink" title="clear 清除"></a>clear 清除</h2><p>clear可以清除字典所有项，这项操作是直接操作原来的字典而不是修改字典然后返回新的字典<br>下面展示一下这个方法的用处<br>A</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">	&#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">	&#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>B</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">	&#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">	&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对比A和B这两种情况，就大概知道什么时候clear方法可以发挥用处了</p>
<h2 id="copy-复制"><a href="#copy-复制" class="headerlink" title="copy 复制"></a>copy 复制</h2><p>可以复制一个全新的字典出来，并返回这个新的字典。字典的复制分为浅度复制和深度复制<br>浅度复制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;machines&#x27;</span>:[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;mlh&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y[<span class="string">&#x27;machines&#x27;</span>].remove(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">    &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;mlh&#x27;</span>, <span class="string">&#x27;machines&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">    &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;machines&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>深度复制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;names&#x27;</span>] = [<span class="string">&#x27;Alfred&#x27;</span>, <span class="string">&#x27;Bertrand&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = d.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc = deepcopy(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;names&#x27;</span>].append(<span class="string">&#x27;Clive&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">    &#123;<span class="string">&#x27;names&#x27;</span>: [<span class="string">&#x27;Alfred&#x27;</span>, <span class="string">&#x27;Bertrand&#x27;</span>, <span class="string">&#x27;Clive&#x27;</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dc</span><br><span class="line">    &#123;<span class="string">&#x27;names&#x27;</span>: [<span class="string">&#x27;Alfred&#x27;</span>, <span class="string">&#x27;Bertrand&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fromkeys-空字典"><a href="#fromkeys-空字典" class="headerlink" title="fromkeys 空字典"></a>fromkeys 空字典</h2><p>使用给定的键来建立一个没有值的字典，也可以给一个默认的值让所有键的值都是这个默认值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict.fromkeys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])	<span class="comment">#一个纯空的字典</span></span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;age&#x27;</span>:<span class="literal">None</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict.fromkeys([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>], <span class="string">&#x27;unknow&#x27;</span>)   <span class="comment">#给键创建一个默认值</span></span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;unknow&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;unknow&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-获取"><a href="#get-获取" class="headerlink" title="get 获取"></a>get 获取</h2><p>比较宽松的获取数据，以前用d[k]的方式调用一个值的话，如果这个键不存在就会抛出异常，用get获取就不会这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> d.get(<span class="string">&#x27;name&#x27;</span>)  <span class="comment">#获取一个不存在的数据，不会抛出异常，而显示None</span></span><br><span class="line">    <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="has-key-判断键"><a href="#has-key-判断键" class="headerlink" title="has_key 判断键"></a>has_key 判断键</h2><p>判断字典中是否有这个键，返回True和False</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123456&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.has_key(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.has_key(<span class="string">&#x27;hehe&#x27;</span>)</span><br><span class="line">    <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="items-iteritems-返回字典"><a href="#items-iteritems-返回字典" class="headerlink" title="items iteritems 返回字典"></a>items iteritems 返回字典</h2><p>items 可以将整个字典转化成列表并返回<br>iteritems 可以将整个字典转化成迭代器返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.items()</span><br><span class="line">    [(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>), (<span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;123&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.iteritems()</span><br><span class="line">    &lt;built-<span class="keyword">in</span> method iteritems of dict object at <span class="number">0x7f62ac08e6e0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(d.iteritems())</span><br><span class="line">    [(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>), (<span class="string">&#x27;password&#x27;</span>, <span class="string">&#x27;123&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="keys-iterkeys-返回键"><a href="#keys-iterkeys-返回键" class="headerlink" title="keys iterkeys 返回键"></a>keys iterkeys 返回键</h2><p>keys 以列表的方式返回整个字典中所有的key<br>iterkeys 以迭代器的方式返回整个字典中所有的key</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</span><br><span class="line">    [<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.iterkeys()</span><br><span class="line">    &lt;dictionary-keyiterator object at <span class="number">0x7f62ac0972b8</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="pop-出栈"><a href="#pop-出栈" class="headerlink" title="pop 出栈"></a>pop 出栈</h2><p>因为字典中是没有顺序的，所以出栈的时候必须自己指定一个Key才能弹出这个K-V，如果了解“栈”这个数据结构的话就能非常清晰这个方法。使用pop弹出一个数据的时候回在原字典中删除这个数据并返回这个数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;admin&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="popitem-随机出栈"><a href="#popitem-随机出栈" class="headerlink" title="popitem 随机出栈"></a>popitem 随机出栈</h2><p>随机从字典中弹出一组K-V</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;one&#x27;</span>:<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;two&#x27;</span>:<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;three&#x27;</span>:<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;four&#x27;</span>:<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;five&#x27;</span>:<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;six&#x27;</span>:<span class="string">&#x27;6&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem()</span><br><span class="line">    (<span class="string">&#x27;six&#x27;</span>, <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem()</span><br><span class="line">    (<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem()</span><br><span class="line">    (<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem()</span><br><span class="line">    (<span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem()</span><br><span class="line">    (<span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.popitem()</span><br><span class="line">    (<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="setdefault-设置默认"><a href="#setdefault-设置默认" class="headerlink" title="setdefault 设置默认"></a>setdefault 设置默认</h2><p>给字典中某个Key设定一个默认的Value，当这个Key没有Value的时候就默认为那个默认的Value，如果有数据则默认Value不会生效</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.setdefault(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line">    <span class="string">&#x27;N/A&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;N/A&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.setdefault(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line">    <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;admin&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="update-更新字典"><a href="#update-更新字典" class="headerlink" title="update 更新字典"></a>update 更新字典</h2><p>可以用一个新的字典去更新旧的字典，新旧字典中Key重合的部分以新字典为准，旧字典中有的Key且新字典中没有的话则不变，旧字典中没有的Key且新字典中有的话则添加这个K-V</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;123456&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;2336666&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;F&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.update(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">    &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;2336666&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;F&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="values-intervalues"><a href="#values-intervalues" class="headerlink" title="values intervalues"></a>values intervalues</h2><p>values 返回字典中所有的值组成的列表<br>intervalues 返回字典中所有的值相应的迭代器</p>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Dictionary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python之序列：列表、元组]]></title>
      <url>/2016/09/07/python-list-tumple/</url>
      <content type="html"><![CDATA[<h1 id="0X00-列表和元组"><a href="#0X00-列表和元组" class="headerlink" title="0X00 列表和元组"></a>0X00 列表和元组</h1><p>Python里有个东西叫做<strong>序列</strong>，可以想象成一堆数据。可以简单的通过序列实现数组、链表、栈和队列等数据结构。<br>序列有几种，常见的是列表和元组。</p>
<h1 id="0X01-序列分片"><a href="#0X01-序列分片" class="headerlink" title="0X01 序列分片"></a>0X01 序列分片</h1><p>我们可以从序列中截取一部分，这种操作被称为分片<br>分片的时候我们可以选择起始点和结束点，还能选择步长，甚至乃能倒序<br>分片使用<code>:</code>分隔开参数，一般情况下有两个参数，截取第一个参数到第二个参数，左开右闭<br>如果参数是负数的话，则表示倒数第几个<br>但是可以接受第三个参数，第三个参数表示步长。如果第二个参数是2那么就是接一跳一。<br>如果参数为空则表示极限。  具体可以看下面的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username[<span class="number">4</span>:<span class="number">8</span>]			<span class="comment">#截取从4到8，左开右闭</span></span><br><span class="line">	o,wo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username[<span class="number">4</span>:<span class="number">-2</span>]		<span class="comment">#截取4到倒数第4的参数，如果想要包括最后一个是不能用-1的，要用下面的方式</span></span><br><span class="line">	o,wor</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username[<span class="number">2</span>:]			<span class="comment">#截取包括最后一个的话不能用-1，因为-1是最后一个，然后区间是左开右闭，所有右边留空就表示极限了</span></span><br><span class="line">	llo,world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username[:]			<span class="comment">#两头取极限，就是完整的序列</span></span><br><span class="line">	hello,world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username[<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>]		<span class="comment">#演示步长，此处步长为2</span></span><br><span class="line">	el,o</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username[<span class="number">8</span>:<span class="number">0</span>:<span class="number">-1</span>]		<span class="comment">#当步长为-1的时候，就是从后向前的</span></span><br><span class="line">	row,olle</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0X02-序列拼接"><a href="#0X02-序列拼接" class="headerlink" title="0X02 序列拼接"></a>0X02 序列拼接</h1><p>序列拼接就和Java里的字符串拼接差不多，可以单纯的用一个加号连在一起。当然Python比Java方便的一点就是，不只是字符串，什么东西只要是在序列里就能用序列拼接到一起。<br>Python中用加号的方式把序列拼接在一起是<strong>返回一个新的序列</strong>而不是直接修改其中的一个序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>password = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username + <span class="string">&#x27;,&#x27;</span> + password</span><br><span class="line">	hello,world</span><br></pre></td></tr></table></figure>

<p>序列不只能做加法，还能做乘法。序列乘n之后返回一个重复了n次的序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username * <span class="number">3</span></span><br><span class="line">	hello,worldhello,worldhello,world</span><br></pre></td></tr></table></figure>

<h1 id="0X03-空序列"><a href="#0X03-空序列" class="headerlink" title="0X03 空序列"></a>0X03 空序列</h1><p>空序列是空的，而不是值为0。也许现在不知道这东西干嘛用，等到时候用到了就豁然开朗了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username = [<span class="literal">None</span>] * <span class="number">10</span> <span class="comment">#这样就生成了一个长度为10的空序列</span></span><br></pre></td></tr></table></figure>

<h1 id="0X04-成员判断"><a href="#0X04-成员判断" class="headerlink" title="0X04 成员判断"></a>0X04 成员判断</h1><p>成员判断就是判断一个元素是不是存在于一个序列里<br>这里返回的是布尔值，True或者False</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;,&#x27;</span> <span class="keyword">in</span> username		<span class="comment">#判断元素是不是在序列里</span></span><br><span class="line">	<span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello&#x27;</span> <span class="keyword">in</span> username	<span class="comment">#判断序列是不是在序列里</span></span><br><span class="line">	<span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello&#x27;</span> <span class="keyword">in</span> username</span><br><span class="line">	<span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hel&#x27;</span> <span class="keyword">in</span> username</span><br><span class="line">	<span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="0X05-长度-amp-统计"><a href="#0X05-长度-amp-统计" class="headerlink" title="0X05 长度&amp;统计"></a>0X05 长度&amp;统计</h1><p>可以统计一个序列的长度，还能计算出序列所有元素的最大和最小<br>具体的排序方法可以去网上找找或者自己尝试一下，针对每种类型的排序方式是不一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = <span class="string">&#x27;hello,world&#x27;</span>	<span class="comment">#获取长度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> len(username)</span><br><span class="line">	<span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>number = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> max(number)	<span class="comment">#统计最大</span></span><br><span class="line">	<span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> min(number)	<span class="comment">#统计平均</span></span><br><span class="line">	<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="0X06-列表赋值"><a href="#0X06-列表赋值" class="headerlink" title="0X06 列表赋值"></a>0X06 列表赋值</h1><p>对列表的赋值和对其他编程语言里的数组赋值几乎是一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username[<span class="number">3</span>] = <span class="number">33</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username[<span class="number">5</span>] = <span class="number">55</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username</span><br><span class="line">	[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">33</span>, <span class="number">4</span>, <span class="number">55</span>]</span><br></pre></td></tr></table></figure>

<h1 id="0X07-列表删除数据"><a href="#0X07-列表删除数据" class="headerlink" title="0X07 列表删除数据"></a>0X07 列表删除数据</h1><p>删除列表里的数据也非常易于理解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> username[<span class="number">5</span>]	<span class="comment">#删除索引为5的元素，也就是第6个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username</span><br><span class="line">	[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>] <span class="comment">#处在原来5的位置的逗号不在了</span></span><br></pre></td></tr></table></figure>

<h1 id="0X08-列表分片赋值"><a href="#0X08-列表分片赋值" class="headerlink" title="0X08 列表分片赋值"></a>0X08 列表分片赋值</h1><p>分片赋值相当于把以前的部分数据盖上，写上新的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = list(<span class="string">&#x27;hello,world&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username[<span class="number">1</span>:<span class="number">5</span>] = list(<span class="string">&#x27;++++++&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username[<span class="number">2</span>:<span class="number">2</span>] = list(<span class="string">&#x27;------&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username	<span class="comment">#数据添加成功</span></span><br><span class="line">	[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username[<span class="number">3</span>:<span class="number">5</span>] = []  <span class="comment">#理论上可以通过这种方式去删除列表中的数据，不过非常不建议这么做，没人愿意看这种代码，包括几天之后的你自己</span></span><br></pre></td></tr></table></figure>

<h1 id="0X09-列表常用方法"><a href="#0X09-列表常用方法" class="headerlink" title="0X09 列表常用方法"></a>0X09 列表常用方法</h1><h2 id="append-和-extend"><a href="#append-和-extend" class="headerlink" title="append 和 extend"></a>append 和 extend</h2><p>append()方法是 <strong>向列表中添加一个元素</strong>，而extend()则是扩展原有列表。这两个方法都是修改之前的列表，而不是返回一个新的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">	b = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]</span><br><span class="line">	<span class="comment"># a.append(b)</span></span><br><span class="line">	a.extend(b)</span><br><span class="line">	<span class="keyword">print</span> a</span><br></pre></td></tr></table></figure>
<p>上面的代码中，留下append()方法后运行结果如下，可以看到是向原来的列表中加入了一个元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p>留下extend()方法后运行结果如下，可以看到是将列表b中的元素扩展到了列表a中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="count-统计数据"><a href="#count-统计数据" class="headerlink" title="count 统计数据"></a>count 统计数据</h2><p>计数，统计一个列表在另一个列表里出现了多少次</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.count(<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">	<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.count(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="index-索引查找"><a href="#index-索引查找" class="headerlink" title="index 索引查找"></a>index 索引查找</h2><p>查找第一个匹配的位置，并返回索引位置。如果返回0则是在0的位置上找到了，而不是没找到。没找到的话会直接抛出异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.index(<span class="string">&#x27;l&#x27;</span>)	<span class="comment">#返回位置</span></span><br><span class="line">	<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.index(<span class="string">&#x27;h&#x27;</span>)	<span class="comment">#返回0的位置</span></span><br><span class="line">	<span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.index(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#找不到，抛出异常了</span></span><br><span class="line">	Traceback (most recent call last):</span><br><span class="line">  		File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">	ValueError: substring <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>
<h2 id="insert-插入数据-准"><a href="#insert-插入数据-准" class="headerlink" title="insert 插入数据-准"></a>insert 插入数据-准</h2><p>向列表中插入数据，可选参数有插入位置和插入内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.insert(<span class="number">3</span>, <span class="number">666</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username	<span class="comment">#向3的位置上插入666</span></span><br><span class="line">	[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">666</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<h2 id="pop-弹出数据-出栈"><a href="#pop-弹出数据-出栈" class="headerlink" title="pop 弹出数据-出栈"></a>pop 弹出数据-出栈</h2><p>将列表中的最后一个数据弹出来，返回且删除它。  如果知道数据结构中的栈的话，就明白了，可以比喻成  出栈</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.pop()	<span class="comment">#出栈</span></span><br><span class="line">	<span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.pop(<span class="number">2</span>)	<span class="comment">#选择删除</span></span><br><span class="line">	<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="remove-匹配删除"><a href="#remove-匹配删除" class="headerlink" title="remove 匹配删除"></a>remove 匹配删除</h2><p>移除匹配到的第一项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.remove(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username</span><br><span class="line">	[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<h2 id="sort-排序方法"><a href="#sort-排序方法" class="headerlink" title="sort 排序方法"></a>sort 排序方法</h2><p>可以通过Python内置算法排序，甚至还可以自定义参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">65</span>, <span class="number">23</span>, <span class="number">54675</span>, <span class="number">8</span>, <span class="number">34</span>, <span class="number">5568</span>, <span class="number">345</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username</span><br><span class="line">	[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">65</span>, <span class="number">345</span>, <span class="number">5568</span>, <span class="number">54675</span>]</span><br></pre></td></tr></table></figure>
<h2 id="sorted-排序函数"><a href="#sorted-排序函数" class="headerlink" title="sorted 排序函数"></a>sorted 排序函数</h2><p>类似sort，不过这个是返回一个新的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">3465</span>, <span class="number">234</span>, <span class="number">4657</span>, <span class="number">5</span>, <span class="number">65</span>, <span class="number">23</span>, <span class="number">54675</span>, <span class="number">8</span>, <span class="number">34</span>, <span class="number">5568</span>, <span class="number">345</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(username)</span><br><span class="line">	[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">65</span>, <span class="number">234</span>, <span class="number">234</span>, <span class="number">345</span>, <span class="number">3465</span>, <span class="number">4657</span>, <span class="number">5568</span>, <span class="number">54675</span>]</span><br></pre></td></tr></table></figure>
<h2 id="list-reversed-x-反向排序"><a href="#list-reversed-x-反向排序" class="headerlink" title="list(reversed(x)) 反向排序"></a>list(reversed(x)) 反向排序</h2><p>逆向</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">234</span>, <span class="number">3465</span>, <span class="number">234</span>, <span class="number">4657</span>, <span class="number">5</span>, <span class="number">65</span>, <span class="number">23</span>, <span class="number">54675</span>, <span class="number">8</span>, <span class="number">34</span>, <span class="number">5568</span>, <span class="number">345</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = sorted(username)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> username</span><br><span class="line">	[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">65</span>, <span class="number">234</span>, <span class="number">234</span>, <span class="number">345</span>, <span class="number">3465</span>, <span class="number">4657</span>, <span class="number">5568</span>, <span class="number">54675</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(reversed(username))</span><br><span class="line">	[<span class="number">54675</span>, <span class="number">5568</span>, <span class="number">4657</span>, <span class="number">3465</span>, <span class="number">345</span>, <span class="number">234</span>, <span class="number">234</span>, <span class="number">65</span>, <span class="number">34</span>, <span class="number">23</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="0X0A-元组简介"><a href="#0X0A-元组简介" class="headerlink" title="0X0A 元组简介"></a>0X0A 元组简介</h1><ul>
<li>元组一般用括号表示</li>
<li>元组和列表相比，列表可以修改而元组不能修改<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>username = (<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>password = (<span class="string">&#x27;x&#x27;</span>, ) <span class="comment">#创建一个只包含一个数据的元组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Data Structure </tag>
            
            <tag> List </tag>
            
            <tag> Tuple </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python之字符串]]></title>
      <url>/2016/09/05/python-str/</url>
      <content type="html"><![CDATA[<h1 id="0X00-如何定义一个字符串"><a href="#0X00-如何定义一个字符串" class="headerlink" title="0X00 如何定义一个字符串"></a>0X00 如何定义一个字符串</h1><p>** Python不需要定义 ** 其实就是这样的。。在Python中的字符串通常这么写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&#x27;hello,world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">&quot;It&#x27;s work&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str3 = <span class="string">&quot;&quot;&quot; Jack:&quot;oh shit&quot; &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>str1 的声明方式是最普通的声明方式<br>str2 的声明方式可以在字符串中存在单引号‘<br>str3 的声明方式可以在字符串中存在双引号 “ 还能在字符串中换行</p>
<h1 id="0X01-拼接字符串"><a href="#0X01-拼接字符串" class="headerlink" title="0X01 拼接字符串"></a>0X01 拼接字符串</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">&quot;,&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str3 = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> str1 + str2 + str3</span><br><span class="line">	hello,world</span><br></pre></td></tr></table></figure>
<p>注意：<br>连接的时候加号左右都要是字符串，如果是字符串加数字就不行了。除非把数字转成字符串格式</p>
<a id="more"></a>

<h1 id="0X02-输入字符串"><a href="#0X02-输入字符串" class="headerlink" title="0X02 输入字符串"></a>0X02 输入字符串</h1><p>标准输入就是直接把你输入的东西写到代码里，甚至可以用变量名<br>原始输入就是直接输入字符串，纯字符串<br>具体情况可以从下面的Demo中看到效果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello = <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = input(<span class="string">&quot;what&#x27;s your name:&quot;</span>)   <span class="comment">#获取标准输入</span></span><br><span class="line">	hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = raw_input(<span class="string">&quot;what&#x27;s your name:&quot;</span>)	<span class="comment">#获取原始输入</span></span><br><span class="line">	<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> str1</span><br><span class="line">	hello,world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> str2</span><br><span class="line">	hello</span><br></pre></td></tr></table></figure>

<h1 id="0X03-字符串格式化"><a href="#0X03-字符串格式化" class="headerlink" title="0X03 字符串格式化"></a>0X03 字符串格式化</h1><p>学过C的能迅速的理解Python里的字符串格式化，没学过C的可以快速的理解Python里的字符串格式化  +_+</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = Template(<span class="string">&quot;1---$a  2---$b   3---$c   4---$$&quot;</span>)	<span class="comment"># $a $b $c 都是字符串占位符，先写好后赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text.substitute(a=<span class="string">&quot;hello,&quot;</span>, b=<span class="string">&quot;world&quot;</span>, c=<span class="string">&quot;wow&quot;</span>)</span><br><span class="line">	<span class="string">&#x27;1---hello,  2---world   3---wow   4---$&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  %s  是字符串占位符，将后面的字符串加到前面</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">&quot;hello, %s&quot;</span> % (<span class="string">&quot;world&quot;</span>)</span><br><span class="line">	hello, world</span><br><span class="line"></span><br><span class="line"><span class="comment"># %15s  是将字符串向前扩充打15位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">&quot;hello, %15s&quot;</span> % (<span class="string">&quot;world&quot;</span>)</span><br><span class="line">	hello,           world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">&quot;%15s, world&quot;</span> % (<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    hello, world</span><br><span class="line"></span><br><span class="line"><span class="comment"># %-15s 是将字符串向后扩充到15位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">&quot;%-15s, world&quot;</span> % (<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	hello          , world</span><br></pre></td></tr></table></figure>

<h1 id="0X04-字符串处理函数"><a href="#0X04-字符串处理函数" class="headerlink" title="0X04 字符串处理函数"></a>0X04 字符串处理函数</h1><h2 id="find-字符串查找"><a href="#find-字符串查找" class="headerlink" title="find 字符串查找"></a>find 字符串查找</h2><p>从一个字符串中查找另一个字符串，返回最左端索引，找不到就返回 -1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.find(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">	<span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">&quot;hello,hello,world,world&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.find(<span class="string">&quot;,&quot;</span>, <span class="number">8</span>, <span class="number">12</span>)</span><br><span class="line">	<span class="number">11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果find函数返回了0，并不是没找到，而是在0的位置找到了。毕竟程序员的世界从来都是从0开始数数的</p>
</blockquote>
<h2 id="join-连接"><a href="#join-连接" class="headerlink" title="join 连接"></a>join 连接</h2><p>连接序列中的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">&quot;---&quot;</span>.join(str1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> str2</span><br><span class="line">	hello---world</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里是  str.join(list)  而不是  list.join(str)</p>
</blockquote>
<h2 id="lower-我要小写"><a href="#lower-我要小写" class="headerlink" title="lower 我要小写"></a>lower 我要小写</h2><p>返回字符串的全小写版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&quot;HELLO,WORLD&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = str1.lower()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> str2</span><br><span class="line">	hello,world</span><br></pre></td></tr></table></figure>

<h2 id="replace-查找并替换"><a href="#replace-查找并替换" class="headerlink" title="replace 查找并替换"></a>replace 查找并替换</h2><p>查找并替换全部</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&quot;my world, my house, my phone&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = str1.replace(<span class="string">&quot;my&quot;</span>, <span class="string">&quot;your&quot;</span>)	<span class="comment">#我就这么把所有东西过户给了你+_+</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> str2</span><br><span class="line">	your world, your house, your phone</span><br></pre></td></tr></table></figure>

<h2 id="split-分割"><a href="#split-分割" class="headerlink" title="split 分割"></a>split 分割</h2><p>分割字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&quot;hello,world&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = str1.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> str2</span><br><span class="line">	[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>]	<span class="comment">#返回了一个列表</span></span><br></pre></td></tr></table></figure>

<h2 id="strip-清理字符串"><a href="#strip-清理字符串" class="headerlink" title="strip 清理字符串"></a>strip 清理字符串</h2><p>去除两侧的东西<br>strip默认去除两侧的空格，当然也可以加参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;	str1 = <span class="string">&quot;  hello,world  &quot;</span></span><br><span class="line">&gt;&gt;&gt;	str2 = str1.strip()	<span class="comment">#默认去除空格</span></span><br><span class="line">&gt;&gt;&gt;	<span class="keyword">print</span> str2</span><br><span class="line">	hello,world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&quot;aaahello,worldaaa&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = str1.srtip(<span class="string">&quot;a&quot;</span>)  <span class="comment">#加了参数就删除两侧的参数里的内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> str2</span><br><span class="line">	hello,world</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Shadowsocks 如何科学上网 搭梯子 简明教程]]></title>
      <url>/2016/07/23/shadowsocks-build/</url>
      <content type="html"><![CDATA[<h1 id="0X00-准备工作"><a href="#0X00-准备工作" class="headerlink" title="0X00 准备工作"></a>0X00 准备工作</h1><p>1.一台海外或者香港的服务器/虚拟主机（后面统称VPS），要有独立IP<br>2.VPS的带宽和流量不能太小<br>3.一个连接VPS的软件，LInux/Mac可以用终端，Windows用户可以用XShell或者putty<br>4.VPS要使用Linux系统，Debian/Ubuntu/CentOS都行</p>
<blockquote>
<p>开工之前最好有Linux适用基础<br>没有VPS的推荐一个购买地址，便宜好用<a href="http://banwagong.cn/gonglue.html">banwagong</a><br>这个网站不是官网，但是起到了类似中文官网的作用，可以按照里面的推荐和教程去购买适合自己的VPS<br>VPS买回来不止可以干这个、配置高一点的话还可以搭建一个独立博客和一些其他的服务</p>
</blockquote>
<h1 id="0X01-简述工作原理"><a href="#0X01-简述工作原理" class="headerlink" title="0X01 简述工作原理"></a>0X01 简述工作原理</h1><p>** 不通过伟大防火墙时 ** 我们访问某网站，流量从我们的机器一路跑到网站服务器，然后服务器响应数据再一路跑回来。<br>现在 ** 有了伟大的防火墙 ** 不让我们和某些网站交流了，我们可以搭一个 ** 梯子 ** ，让流量通过梯子。其实用 ** 镜子 ** 比喻会更好一点。<br>** 有了镜子 ** 之后，我们的流量一路跑到镜子那里，镜子替我们将流量一路跑到网站服务器，然后网站服务器将数据一路发送到镜子，镜子再转发给我们。<br>所以造成下面几个问题：<br>1.你终端（电脑、手机等设备）产生的数据流量（代理流量）都要从梯子那里经过，所以梯子也要走一份流量。<br>2.你的网速同时取决于 你的速度、VPS的速度、网站服务器的速度<br>3.你的延迟同时取决于 你到VPS的延迟，VPS到网站服务器的延迟</p>
<a id="more"></a>

<h1 id="0X02-安装软件"><a href="#0X02-安装软件" class="headerlink" title="0X02 安装软件"></a>0X02 安装软件</h1><p>Debian/Ubuntu</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update				<span class="comment">#更新系统</span></span><br><span class="line">sudo apt-get install python-pip <span class="comment">#安装Python-pip</span></span><br><span class="line">sudo pip install shadowsocks 	<span class="comment">#安装shadowsocks</span></span><br></pre></td></tr></table></figure>

<p>CentOS</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update					<span class="comment">#更新系统</span></span><br><span class="line">sudo yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class="line">sudo pip install shadowsocks	<span class="comment">#安装shadowsocks</span></span><br></pre></td></tr></table></figure>

<h1 id="0X03-修改配置文件"><a href="#0X03-修改配置文件" class="headerlink" title="0X03 修改配置文件"></a>0X03 修改配置文件</h1><p>配置文件默认不存在，我们直接创建一个就行<code>vim /etc/shadowsocks.json</code><br>这里配置文件使用Json解析，看起来很清晰，便于识别修改</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	    <span class="attr">&quot;server&quot;</span>:<span class="string">&quot;my_server_ip&quot;</span>,</span><br><span class="line">	    <span class="attr">&quot;server_port&quot;</span>:<span class="number">8388</span>,</span><br><span class="line">	    <span class="attr">&quot;local_address&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">	    <span class="attr">&quot;local_port&quot;</span>:<span class="number">1080</span>,</span><br><span class="line">	    <span class="attr">&quot;password&quot;</span>:<span class="string">&quot;mypassword&quot;</span>,</span><br><span class="line">	    <span class="attr">&quot;timeout&quot;</span>:<span class="number">300</span>,</span><br><span class="line">	    <span class="attr">&quot;method&quot;</span>:<span class="string">&quot;aes-256-cfb&quot;</span>,</span><br><span class="line">	    <span class="attr">&quot;fast_open&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>server 修改成你VPS的外网ip<br>server_port 是服务端用的端口，没有特殊需要就不用改了<br>local_address 本地地址，使用默认的127.0.0.1就行<br>local_port 客户机端口，使用默认的1080就行<br>password 设置密码<br>timeout 超时时间，使用默认即可<br>method 加密算法，使用默认aes-256-cfb即可，改用rc4-md5也行，不过客户端也要跟着改<br>fast_open 默认即可</p>
</blockquote>
<h1 id="0X04-如何开启关闭服务"><a href="#0X04-如何开启关闭服务" class="headerlink" title="0X04 如何开启关闭服务"></a>0X04 如何开启关闭服务</h1><p>这样开启服务<code>ssserver -c /etc/shadowsocks.json -d start</code><br>这样关闭服务<code>ssserver -c /etc/shadowsocks.json -d stop</code><br>这样重启服务<code>关了再开就是重启+_+</code></p>
<h3 id="0X04-下载客户端"><a href="#0X04-下载客户端" class="headerlink" title="0X04 下载客户端"></a>0X04 下载客户端</h3><p><a href="http://o7bn7vqpt.bkt.clouddn.com/%2Fdownload%2Fshadowsocks-windows.7z">点击下载WIndows环境下的Shadowsocks客户端</a><br><a href="http://o7bn7vqpt.bkt.clouddn.com/%2Fdownload%2Fshadowsocks-android.7z">点击下载Android环境下的Shadowsocks客户端</a><br>IOS版本的客户端在AppStore里有，不过要收费。也有免费的解决方案，因为不用IOS所以不清楚，自己去找找吧。</p>
<h1 id="0X05-优化速度"><a href="#0X05-优化速度" class="headerlink" title="0X05 优化速度"></a>0X05 优化速度</h1><p><strong>注意：</strong><br>1.前提是你的VPS限制流量但不限制带宽且你有足够的流量<br>2.所谓速度优化只针对大文件下载和在线视频有明显效果<br>3.速度优化之后会双倍流量发送，所以只有流量充足的用户适用</p>
<p>Debian/Ubuntu:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/tennfy/debian_netspeeder_tennfy/master/debian_netspeeder_tennfy.sh</span><br><span class="line">chmod a+x debian_netspeeder_tennfy.sh</span><br><span class="line">bash debian_netspeeder_tennfy.sh</span><br></pre></td></tr></table></figure>

<p>CentOS:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://gist.github.com/LazyZhu/dc3f2f84c336a08fd6a5/raw/d8aa4bcf955409e28a262ccf52921a65fe49da99/net_speeder_lazyinstall.sh</span><br><span class="line">sudo sh net_speeder_lazyinstall.sh</span><br></pre></td></tr></table></figure>

<p>启动加速<code>    nohup /usr/local/net_speeder/net_speeder venet0 &quot;ip&quot; &gt;/dev/null 2&gt;&amp;1 &amp;</code></p>
]]></content>
      
        
        <tags>
            
            <tag> VPS </tag>
            
            <tag> Proxy </tag>
            
            <tag> Shadowsocks </tag>
            
            <tag> GFW </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java使用MD5和BASE64]]></title>
      <url>/2016/07/17/java-md5-base64/</url>
      <content type="html"><![CDATA[<h1 id="0X00-简介"><a href="#0X00-简介" class="headerlink" title="0X00 简介"></a>0X00 简介</h1><p>最近经常要在代码中使用到BASE64编码和MD5，所以把笔记贴在这里方便自己查找。<br>在配置postfix邮件服务器的时候发现，收到的邮件正文都是使用BASE64编码过的，所以才了解了一下这种编码。<br>MD5不算加密算法，但是可以用作摘要计算。</p>
<a id="more"></a>

<h1 id="0X01-BASE64编码"><a href="#0X01-BASE64编码" class="headerlink" title="0X01 BASE64编码"></a>0X01 BASE64编码</h1><blockquote>
<p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法，和之后binhex的版本使用不同的64字符集来代表6个二进制数字，但是它们不叫Base64。  ———–维基百科</p>
</blockquote>
<p>代码需要 <code>import sun.misc.BASE64Encoder;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeing</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] b = <span class="keyword">null</span>;</span><br><span class="line">    String s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        b = str.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="keyword">null</span>)&#123;</span><br><span class="line">        s = <span class="keyword">new</span> BASE64Encoder().encode(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0X02-BASE64解码"><a href="#0X02-BASE64解码" class="headerlink" title="0X02 BASE64解码"></a>0X02 BASE64解码</h1><p>代码需要<code>import sun.misc.BASE64Decoder;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decoding</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>)&#123;</span><br><span class="line">            BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                b = decoder.decodeBuffer(str);</span><br><span class="line">                result = <span class="keyword">new</span> String(b, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="0X03-MD5"><a href="#0X03-MD5" class="headerlink" title="0X03 MD5"></a>0X03 MD5</h1><blockquote>
<p>MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由罗纳德·李维斯特设计，于1992年公开，用以替换MD4算法。这套算法的程序在 RFC 1321 中被加以规范。<br>将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。<br>1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-1。2004年，证实MD5算法无法防止碰撞，因此无法适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。     ———–维基百科</p>
</blockquote>
<p>虽说MD5已经被证明不安全，不过用作实验性的登陆验证还是没有问题的。（其实好多好多网站的密码都是MD5的，不信可以去社工库里看看）</p>
<p>代码需要<code>import java.security.MessageDigest;</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMd5</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">           md.update(text.getBytes());</span><br><span class="line">           <span class="keyword">byte</span> b[] = md.digest();</span><br><span class="line">           <span class="keyword">int</span> i;</span><br><span class="line">           StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; b.length; offset++)&#123;</span><br><span class="line">               i = b[offset];</span><br><span class="line">               <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                   i += <span class="number">256</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (i &lt; <span class="number">16</span>)&#123;</span><br><span class="line">                   buf.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               buf.append(Integer.toHexString(i));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> buf.toString();                      <span class="comment">// 32位</span></span><br><span class="line">           <span class="comment">//return buf.toString().substring(8, 24);   // 16位</span></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> MD5 </tag>
            
            <tag> BASE64 </tag>
            
            <tag> Encryption </tag>
            
            <tag> Decryption </tag>
            
            <tag> Encoding </tag>
            
            <tag> Decoding </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NFS 网络文件系统 安装 配置 挂载 卸载]]></title>
      <url>/2016/06/12/linux-nfs/</url>
      <content type="html"><![CDATA[<h1 id="0X00-NFS简介"><a href="#0X00-NFS简介" class="headerlink" title="0X00 NFS简介"></a>0X00 NFS简介</h1><p>NFS的全称是Net-File-System也就是网络文件系统。这和Samba与FTP不同，FTP的主要用途是用来上传和下载文件，Samba的主要功能是共享文件，而NFS的主要功能是用作文件系统。也就是说和NTFS、FAT32、EXT4等是类似的性质。我们可以将这个NFS当做一个磁盘分区挂载到自己的操作系统上，像操作自己的分区一样，甚至可以从NFS启动操作系统。</p>
<blockquote>
<p>实验环境：两台虚拟机CentOS7.x<br>同处在一个内网环境下</p>
</blockquote>
<a id="more"></a>

<h1 id="0X01-安装NFS软件和服务"><a href="#0X01-安装NFS软件和服务" class="headerlink" title="0X01 安装NFS软件和服务"></a>0X01 安装NFS软件和服务</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装软件</span></span><br><span class="line">yum install rpcbind</span><br><span class="line">yum install nfs-utils</span><br></pre></td></tr></table></figure>

<h1 id="0X02-创建测试目录并修改权限"><a href="#0X02-创建测试目录并修改权限" class="headerlink" title="0X02 创建测试目录并修改权限"></a>0X02 创建测试目录并修改权限</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试用的目录</span></span><br><span class="line">mkdir /home/share</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建测试用的文件(让文件里有内容，方便后来判断是否搭建成功)</span></span><br><span class="line">ls / &gt; /home/share/test1</span><br><span class="line">ls /etc/ &gt; /home/share/test2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建挂载点、以后就把NFS挂载到这里</span></span><br><span class="line">mkdir /home/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将这个测试目录设置为777的权限</span></span><br><span class="line">chmod 777 /home/share</span><br></pre></td></tr></table></figure>

<h1 id="0X03-修改配置文件"><a href="#0X03-修改配置文件" class="headerlink" title="0X03 修改配置文件"></a>0X03 修改配置文件</h1><p>配置文件是<code>/etc/exports</code>  使用文本编辑器打开配置文件并进行修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加如下配置  192.168.123.132是客户端IP</span></span><br><span class="line">/home/share/ 192.168.123.132(rw, sync) *(ro)</span><br></pre></td></tr></table></figure>
<p><code>/home/share/</code>表示NFS的路径<br><code>192.168.123.132(rw, sync)</code>表示192.168.123.132访问此NFS时使用后面的配置、具有rw权限（读写）、sync同步模式，表示内存中的数据实时写入磁盘<br><code>*(ro)</code>表示所有IP访问时使用后面的配置、ro表示read only只读</p>
<blockquote>
<p>每个路径下面可以接好多个访问项，就是<code>192.168.123.132(rw, sync)</code>或者<code>*(ro)</code>，使用空格分开</p>
</blockquote>
<h1 id="0X04-启动服务并检查NFS配置"><a href="#0X04-启动服务并检查NFS配置" class="headerlink" title="0X04 启动服务并检查NFS配置"></a>0X04 启动服务并检查NFS配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start portmap</span><br><span class="line">systemctl start nfs</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在客户端检查 192.168.123.123是服务端</span></span><br><span class="line">showmount -e 192.168.123.123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果输出成如下这样就是正确了</span></span><br><span class="line">Export List <span class="keyword">for</span> 192.168.123.123:</span><br><span class="line">/home/share *</span><br></pre></td></tr></table></figure>

<h1 id="0X05-挂载和卸载"><a href="#0X05-挂载和卸载" class="headerlink" title="0X05 挂载和卸载"></a>0X05 挂载和卸载</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载</span></span><br><span class="line">mount -t nfs 192.168.123.123:/home /home/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">umount /home/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> File System </tag>
            
            <tag> NFS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux交换分区 Swap 虚拟内存 理解虚拟内存]]></title>
      <url>/2016/05/28/linux-swap-virtualmemery/</url>
      <content type="html"><![CDATA[<p>SWAP分区是Linux的交换分区。交换分区实际存在于磁盘中，不过Linux系统可以将它当作内存使用，当物理真实内存不足的时候交换分区就可以和真实内存进行数据交换。简单地说就是从磁盘里拿出一块空间当作内存的储备区。虽说磁盘被拿来当作内存使用，但是速度还是磁盘的速度。可以想象下面一种日常生活的场景：</p>
<blockquote>
<p>当你工作的时候一定是把桌洞里的东西拿出来放到桌面上，并且手里拿着一部分东西在操作，然后桌面和桌洞里的东西在不断的交换你手里的东西和桌面上的东西也一直在交换。<br>可以这么想：你从桌洞里拿出来了一本《5年高考3年模拟——理综》放到桌面上，然后拿起笔开始刷题。后来你又从桌洞里拿出来了一本《5年高考3年模拟——数学》放到桌面上，准备两本一起写（就是这么屌），写一题理综写一题数学。再后来你又想同时写语文，但是你发现你的桌面上已经没有了那么大的空间，就只能把语文放到桌洞里，每次拿出来语文就要把数学或是理综放到桌洞中。<br>计算机实际上是这样。从磁盘中打开了一个程序（一本书），操作系统就（另一个人）把这个程序运行起来放到内存中（放到桌面上），CPU将（部分）程序加载到寄存器中（拿起笔开始做题）。然后又运行了一个程序，CPU就在这两个程序之间切换（做完一题数学就换一题理综）。再运行一个程序，发现内存不足（桌面不够用了）就将内存和磁盘中的交换分区开始交换（把语文放到桌洞里，每次拿出来语文就要把数学或是理综放到桌洞中）</p>
</blockquote>
<a id="more"></a>

<h1 id="0X00-创建一个分区-创建一块文件"><a href="#0X00-创建一个分区-创建一块文件" class="headerlink" title="0X00 创建一个分区 || 创建一块文件"></a>0X00 创建一个分区 || 创建一块文件</h1><p> 要想创建swap分区可以有两种分配空间的方式，一种是直接从磁盘中分出来一块用来当做swap分区，然后格式化为swap格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对磁盘sdb进行分区</span></span><br><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure>
<p>在提示符下输入n 然后会提示p 或 e的选项，P就是主分区，只能创建4个， e就是逻辑分区，不限个数。<br>我们创建一个逻辑分区就行。然后会提示新分区的起始扇区，使用默认的就好，直接回车<br>接下来是终止扇区，这里支持直接输入扇区号和输入大小两种方式，我们普遍直接输入分区大小<br>输入 +512M 按下回车，就是创建一个512M的分区。现在fdisk又回到了开始的提示符，如果之前的操作有错误可以直接输入q退出，如果没有问题就可以输入w保存并退出。<br>根据你的命令，就创建了一个名为sdb*的文件，这个文件就是分区文件。</p>
<p> 另一种方式就是创建一个文件，然后将这块文件格式化为swap格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个512M的数据类型文件</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=swapfile bs=1024 count=523288</span><br><span class="line"><span class="comment"># if -&gt; input_file输入文件   of -&gt; output_file输出文件   bs -&gt; block_size块大小   count -&gt; 计数</span></span><br></pre></td></tr></table></figure>
<p>解释一下特殊文件/dev/zero</p>
<blockquote>
<p>/dev/zero 这个文件放在Linux存放设备的目录下，如果以他为输出源，输出的全部都是二进制0<br>cat /dev/zero &gt; test  这个命令会生成一个test文件并不断的向该文件中输入二进制0</p>
</blockquote>
<h1 id="0X01-格式化-amp-amp-激活-amp-amp-挂载swap分区"><a href="#0X01-格式化-amp-amp-激活-amp-amp-挂载swap分区" class="headerlink" title="0X01 格式化&amp;&amp;激活&amp;&amp;挂载swap分区"></a>0X01 格式化&amp;&amp;激活&amp;&amp;挂载swap分区</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化刚才的文件</span></span><br><span class="line"><span class="comment"># 根据创建的方式选择命令</span></span><br><span class="line">mkswap /dev/sdb*</span><br><span class="line">mkswap swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活swap分区 相等于挂载</span></span><br><span class="line"><span class="comment"># 根据创建的方式选择命令</span></span><br><span class="line">swapon /dev/sdb*</span><br><span class="line">swapon swapfile</span><br></pre></td></tr></table></figure>

<h1 id="0X02-设置自动挂载"><a href="#0X02-设置自动挂载" class="headerlink" title="0X02 设置自动挂载"></a>0X02 设置自动挂载</h1><p>大家都是懒人，谁想每次开机都手动挂载一次分区呢？所以我们可以一劳永逸，将挂载设为自动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开配置文件</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加这样一行</span></span><br><span class="line"><span class="comment"># 根据创建的方式选择命令</span></span><br><span class="line">/dev/sdb*          swap     swap     defaults     0     0</span><br><span class="line">/home/swapfile     swap     swap     defaults     0     0</span><br></pre></td></tr></table></figure>
<p>下面解释这个配置文件的每一列</p>
<ol>
<li>第一列是数据块文件的位置</li>
<li>第二列是挂载点</li>
<li>第三列是分区类型</li>
<li>第四列是挂载参数   通常默认</li>
<li>第五列是备份选项   0代表不备份 1代表备份  通常为0</li>
<li>第六列是自检顺序   0代表不自检 1和2代表自检  如果是根分区要设为1，其他分区只能是2   通常为0</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Operation System </tag>
            
            <tag> swap </tag>
            
            <tag> Swap Partition </tag>
            
            <tag> Virtual Memerry </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux的LVM 逻辑卷管理 分区 划分 重划]]></title>
      <url>/2016/05/17/linux-lvm/</url>
      <content type="html"><![CDATA[<h1 id="0X00-LVM是什么，有什么用"><a href="#0X00-LVM是什么，有什么用" class="headerlink" title="0X00 LVM是什么，有什么用"></a>0X00 LVM是什么，有什么用</h1><p>LVM的全称是Logical Volume Manager（逻辑卷管理）。是Linux下的一种磁盘分区管理机制，方便给分区（逻辑分区）扩容和压缩。最简单的可以理解成原始的磁盘分区管理是单纯的给每个独立的磁盘进行分区，然后对每个分区进行管理，这样的话每次扩容和压缩空间都会很麻烦。LVM就相当于把所有磁盘的分区都揉到一起，揉成一个大磁盘或者说是大分区，然后从大的中分出小的，这样的话扩容和压缩都会变得方便。<br><img src="http://o7bn7vqpt.bkt.clouddn.com//article/image/lvm.jpg" alt="test"><br><strong>版权声明：图片来自<a href="https://linux.cn/article-3218-2.html">Linux.cn</a></strong></p>
<a id="more"></a>

<h1 id="0X01-基础术语解释"><a href="#0X01-基础术语解释" class="headerlink" title="0X01 基础术语解释"></a>0X01 基础术语解释</h1><p>PV 是<em>Physical Volume</em> <strong>物理卷</strong>—也就是真实的磁盘分区<br>VG 是<em>Volume Group</em> <strong>卷组</strong>—也就是好多PV组成的一个组<br>LV 是<em>Logical Volume</em> <strong>逻辑卷</strong>—就是从VG中分出来的分区<br>PE 是<em>Physical Extent</em> <strong>物理区域</strong>—是PV中最小的存储单元<br>LE 是<em>Logical Extent</em> <strong>逻辑区域</strong>—是LV中做小的存储单元</p>
<h1 id="0X02-测试环境"><a href="#0X02-测试环境" class="headerlink" title="0X02 测试环境"></a>0X02 测试环境</h1><p>V-Box 中的 CentOS 7.x 64bit<br>有两块或者以上数量的虚拟磁盘<br>磁盘大小在1GB以上<br>我这里/dev/sdb和/dev/sdc是刚刚添加的磁盘<br>root用户的~/lvm-mount用来挂载逻辑卷<br>使用root登陆(单纯的因为每次sudo太麻烦)</p>
<h1 id="0X03-准备分区"><a href="#0X03-准备分区" class="headerlink" title="0X03 准备分区"></a>0X03 准备分区</h1><p>使用fdisk为磁盘分区<br><strong>不会使用fdisk的可以直接按着我说的敲</strong><br><strong>还是建议学LVM之前掌握最基础的fdisk分区和格式化</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb <span class="comment"># 使用fdisk给/dev/sdb分区</span></span><br><span class="line">按n 回车 新建一个分区</span><br><span class="line">按p 回车 选择新建分区为主分区</span><br><span class="line">按 回车 选择默认分区号</span><br><span class="line">按 回车 默认选择开始位置</span><br><span class="line">输入 +100M 回车 选择使用100M为新分区的大小</span><br><span class="line">输入 t 回车 设置分区类型</span><br><span class="line">按 回车 默认选择刚才创建的分区</span><br><span class="line">输入 8e 设置刚才创建的分区为 LVM 类型</span><br></pre></td></tr></table></figure>
<p>重复上面的步骤，给/dev/sdb分出来三个区</p>
<h1 id="0X04-创建物理卷-PV"><a href="#0X04-创建物理卷-PV" class="headerlink" title="0X04 创建物理卷 PV"></a>0X04 创建物理卷 PV</h1><p>创建物理卷的时候，可以大小不同，也可以是不同磁盘的分区，只要是 8e 类型的分区都是可以创建到物理卷中的，这里只是为了做示范</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">pvcreate /dev/sdb1</span><br><span class="line">pvcreate /dev/sdb2</span><br><span class="line">pvcreate /dev/ddb3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">pvdisplay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 (这步不要跟着做)</span></span><br><span class="line">pvremove /dev/sdb1</span><br></pre></td></tr></table></figure>

<h1 id="0X05-准备卷组-VG"><a href="#0X05-准备卷组-VG" class="headerlink" title="0X05 准备卷组 VG"></a>0X05 准备卷组 VG</h1><p>创建一个包括/dev/sdb1 /dev/sdb2 /dev/sdb3 物理卷的卷组<br>命名为 volme-group1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">vgcreate volume-group1 /dev/sdb1 /dev/sdb2 /dev/sdb3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">vgdisplay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 (这步不要跟着做)</span></span><br><span class="line">vgremove volume-group1</span><br></pre></td></tr></table></figure>

<h1 id="0X06-创建逻辑卷-LV"><a href="#0X06-创建逻辑卷-LV" class="headerlink" title="0X06 创建逻辑卷 LV"></a>0X06 创建逻辑卷 LV</h1><p>创建逻辑卷的时候要指定名称、大小和所属VG</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">lvcreate -L 100M -n LV1 volume-group1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">lvdisplay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化 格式化成ext4类型</span></span><br><span class="line">mkfs.ext4 /dev/volume-group1/LV1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载</span></span><br><span class="line">mkdir ~/lvm-mount <span class="comment">#设置一个挂载点</span></span><br><span class="line">mount /dev/volume-group1/LV1 ~/lvm-mount <span class="comment"># 挂载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">lvremove /dev/volume-group1/LV1</span><br></pre></td></tr></table></figure>

<h1 id="0X07-扩展LVM逻辑卷"><a href="#0X07-扩展LVM逻辑卷" class="headerlink" title="0X07 扩展LVM逻辑卷"></a>0X07 扩展LVM逻辑卷</h1><p>调整逻辑卷大小是LVM最重要最有用的功能。<br>比如之前创建的100MB的分区不够用了，所以我们需要扩展一下那个分区的大小。虽然LVM很强大，但是扩展的时候还是需要卸载LV</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载LV</span></span><br><span class="line">umount ~/lvm-mount/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整大小</span></span><br><span class="line">lvresize -L 200M /dev/volume-group1/LV1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查磁盘错误（非必须）</span></span><br><span class="line">e2fsck -f /dev/volume-group1/LV1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展文件系统</span></span><br><span class="line">resize2fs /dev/volume-group1/LV1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">lvdisplay</span><br></pre></td></tr></table></figure>

<h1 id="0X08-压缩LVM逻辑卷"><a href="#0X08-压缩LVM逻辑卷" class="headerlink" title="0X08 压缩LVM逻辑卷"></a>0X08 压缩LVM逻辑卷</h1><p>比如你发现有一个分区给了很大，但是完全用不到，那么就可以压缩它的空间，把空余的空间用在有用的地方。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同样，先卸载</span></span><br><span class="line">umount /dev/volume-group1/LV1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查错误</span></span><br><span class="line">e2fsck -f /dev/volume-group1/LV1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新文件系统信息</span></span><br><span class="line">resize2fs /dev/volume-group1/LV1 100M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩空间</span></span><br><span class="line">lvresize -L 100M /dev/volume-group1/LV1</span><br></pre></td></tr></table></figure>
<p>这里会弹出警告，告诉你这项操作可能会导致数据丢失，当然，一般是没有问题的</p>
<h1 id="0X09-扩展卷组"><a href="#0X09-扩展卷组" class="headerlink" title="0X09 扩展卷组"></a>0X09 扩展卷组</h1><p>有一天服务器的磁盘塞满了，你就新买了一块3TB的硬盘插到了电脑上，那么如何让这个3TB和之前的空间一起工作呢？我们可以把这个磁盘分区然后也放到之前的VG（卷组）中，这样通过之前的扩容功能就可以让新的3TB运用到系统中了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先给新磁盘分区（参考0X03步骤）</span></span><br><span class="line">fdisk /dev/sdc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后创建PV(物理卷)</span></span><br><span class="line">pvcreate /dev/sdc1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新PV添加到VG</span></span><br><span class="line">vgextend volume-group1 /dev/sdc1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证一下</span></span><br><span class="line">vgdisplay</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> LVM </tag>
            
            <tag> Partition </tag>
            
            <tag> Format </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux配置DHCP服务器 简明教程]]></title>
      <url>/2016/05/12/linux-dhcp-server/</url>
      <content type="html"><![CDATA[<h1 id="DHCP介绍"><a href="#DHCP介绍" class="headerlink" title="DHCP介绍"></a>DHCP介绍</h1><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>DHCP是一个基于UDP的工作在应用层的协议，用来自动分配IP地址。<br>应用实例：一个办公室有十个人，每个人每天上下班都要带着自己的笔记本，所以每次都要手动配置IP地址，这样简直就不是计算机该干的事情是吧。。所以DHCP应运而生，它能够根据服务端的配置给连接到网络的客户机自动分配IP地址。</p>
<a id="more"></a>

<h2 id="提供的服务"><a href="#提供的服务" class="headerlink" title="提供的服务"></a>提供的服务</h2><p>1.提供IP地址和子网掩码<br>2.提供IP地址对应的网络地址和广播地址<br>3.默认网关地址<br>4.DNS服务器地址</p>
<h2 id="通俗的解释"><a href="#通俗的解释" class="headerlink" title="通俗的解释"></a>通俗的解释</h2><p>你们寝室里有六个人（对应到客户机），每个人都需要用床（对应到IP地址）睡觉，所以每个人回到寝室都会需要一张床。这样的话每个人每次回到寝室的时候都需要宿管（对应到网络管理员）都需要给他分配一个床位，这样就很麻烦。<br>现在有一个“动态床位分配系统”（对应到DHCP服务器），你们每个人回到寝室的时候都会收到一张纸条，纸条上写了你可以使用哪个床位，这就简单多了。<br>再然后可能小明（对应到一个特定的客户机）有洁癖，他需要一个固定的床位（对应到一个需要固定IP的设备，比如打印机或者提供某些服务的服务器）。所以“动态床位分配系统”可以添加一条规则“叫小明的人来了就分配给他三号床位”，就解决了这个问题。</p>
<h2 id="租约时间"><a href="#租约时间" class="headerlink" title="租约时间"></a>租约时间</h2><p>DHCP分配给客户的IP是以<strong>租约</strong>形式分配的。当客户接入到网络中，DHCP便会分配一个IP给客户机，当租约时间到的时候如果客户机还在使用这个IP那么就可以续约，继续使用当前IP而不是从新分配一个。</p>
<h1 id="在CentOS-7-x-下搭建DHCP服务"><a href="#在CentOS-7-x-下搭建DHCP服务" class="headerlink" title="在CentOS 7.x 下搭建DHCP服务"></a>在CentOS 7.x 下搭建DHCP服务</h1><h2 id="0X00-安装DHCP服务"><a href="#0X00-安装DHCP服务" class="headerlink" title="0X00 安装DHCP服务"></a>0X00 安装DHCP服务</h2><p>使用yum、rpm、源码等方式进行安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install dhcpd</span><br></pre></td></tr></table></figure>

<h2 id="0X01-配置服务器网络服务"><a href="#0X01-配置服务器网络服务" class="headerlink" title="0X01 配置服务器网络服务"></a>0X01 配置服务器网络服务</h2><p>首先我们要将本地的网络配置成静态地址，并重启网络服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/enp0s3</span><br></pre></td></tr></table></figure>
<p>这里的<code>enp0s3</code>是我的网卡，你需要将这里修改成你的网卡，另外在CentOS 7.x 以前的版本中，使用的是<code>ethx</code>的命名方式。<br>修改如下选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=static <span class="comment">#之前很有可能是dhcp，现在我们修改它为静态</span></span><br><span class="line">ONBOOT=yes		 <span class="comment">#以前可能是no，改为yes、就是打开网络服务的时候启动这个网卡</span></span><br><span class="line">IPADDR=192.168.233.1 <span class="comment">#配置文件中可能没有这个，没有的话就自己添加这行</span></span><br><span class="line"><span class="comment"># 这里的IP地址可以自定义，不过最后一位最好是1，这样便于识别</span></span><br></pre></td></tr></table></figure>

<p>然后重启网络服务，如果配置文件没有错误的话，就可以正常启动了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure>

<p>这时候我们检查一下IP是不是已经变成我们设置的静态IP了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig enp0s3</span><br></pre></td></tr></table></figure>

<h2 id="0X02-配置DHCP服务"><a href="#0X02-配置DHCP服务" class="headerlink" title="0X02 配置DHCP服务"></a>0X02 配置DHCP服务</h2><p>配置文件在这里</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/dhcp/dhcpd.conf</span><br></pre></td></tr></table></figure>
<p>打开之后会有三行注释，我们初次学习配置的时候可以先不管它，只有服务真的跑起来并生效了我们才会进一步学习是吧。</p>
<p>在配置文件最后添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置DHCP于DNS服务器的动态信息更新模式。初学时完全可以不理这个选项，但是全局设置中一定要有这个选项，否则DHCP服务不能成功启动。</span></span><br><span class="line">ddns-update-style interim;</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面开始分配子网，网段是192.168.233.0 子网掩码是 255.255.255.0</span></span><br><span class="line"><span class="comment">#不能理解网段和子网掩码的可以去网上查一下。简单的说网段规定了分配IP的段（分配哪一段IP给客户机），子网掩码规定了网段的大小</span></span><br><span class="line">subnet 192.168.233.0 netmask 255.255.255.0 &#123;</span><br><span class="line">	range 192.168.233.100 192.168.233.199; <span class="comment">#分配给客户机的IP从192.168.233.100开始到192.168.233.199</span></span><br><span class="line">    option routers 192.168.233.2; <span class="comment">#设置网关</span></span><br><span class="line">    default-lease-time 600; <span class="comment">#默认租约时间</span></span><br><span class="line">    max-lease-time 7200; <span class="comment">#最大租约时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0X03-给特定客户分配特定地址"><a href="#0X03-给特定客户分配特定地址" class="headerlink" title="0X03 给特定客户分配特定地址"></a>0X03 给特定客户分配特定地址</h2><p>上面也说过，如果同一网络内有需要固定IP的设备，我们也可以通过DHCP来给他分配固定的IP。（就比如说那个有洁癖的同学）<br>首先要说一下DHCP识别主机的方式：<br>DHCP通过接入客户的网卡的MAC地址来判断客户，所以如果你的机器有两块网卡，并且两块网卡同时接入了网络，那么DHCP就会认为有两个设备接入了网络，并给你的机器分配两个IP</p>
<blockquote>
<p>MAC地址并不是“苹果地址”。。。<br>MAC地址是“物理地址”，每块网卡在出厂的时候都会有一个全球独一无二的MAC地址，MAC地址是一个48位2进制的数字，通常表达为六段两位十六进制。</p>
</blockquote>
<p>下面我们继续修改DHCP配置文件，在刚才的配置后面追加下面的内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host Client_C &#123; <span class="comment">#有一个主机，叫Client_C</span></span><br><span class="line">	hardware ethernet 08:00:27:5e:04:27; <span class="comment">#MAC地址是08:...:27的网卡</span></span><br><span class="line">    fixed-address 192.168.233.123;		 <span class="comment">#分配给它192.168.233.123的IP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样配置的话，不管何时，只要这个CLient_C接入到了这个网络中，那么它获取的IP就是固定的这一个，并不会变<br>然后重启一下DHCP服务就好了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart dhcpd.service</span><br></pre></td></tr></table></figure>

<h1 id="好了，至此DHCP的基础配置就搞定了"><a href="#好了，至此DHCP的基础配置就搞定了" class="headerlink" title="好了，至此DHCP的基础配置就搞定了"></a>好了，至此DHCP的基础配置就搞定了</h1>]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> DHCP </tag>
            
            <tag> Service Configure </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 软链接(符号链接)/硬链接 理解Linux链接]]></title>
      <url>/2016/05/11/linux-ln/</url>
      <content type="html"><![CDATA[<h1 id="0X00-什么是链接文件"><a href="#0X00-什么是链接文件" class="headerlink" title="0X00 什么是链接文件"></a>0X00 什么是链接文件</h1><p>Linux中的链接文件就相当于是Windows中的快捷方式，通过链接文件可以访问到链接指向的源文件。但是Linux下的链接文件和Windows中的快捷方式还是有一定的区别。Linux中有两种链接文件<strong>硬链接</strong>和<strong>软连接</strong>也称为<strong>符号链接</strong><br>在介绍链接文件之前先要介绍一下Linux文件系统中的inode</p>
<blockquote>
<p>inode是Linux文件系统中文件的唯一定位器，每一个文件都有一个inode，也是唯一的，每一个inode唯一对应一个文件。</p>
</blockquote>
<p>还要熟悉一下指针的问题，如果学习过C/C++的话理解起来会很轻松</p>
<blockquote>
<p>计算机中所有的数据都是保存在磁盘里的，使用的时候会读取到内存中，而磁盘和内存都是一块一块的地方，我们用地址来找到数据的具体存放位置。保存了文件或者数据存放地址的物体（通常是变量）就称为指针。<br>我们在Linux的操作界面看到的文件，都是一个指针，他们指向磁盘的某个具体位置。这样我们每次点开文件的时候，系统就可以在磁盘对应的位置打开我们需要的文件。</p>
</blockquote>
<a id="more"></a>

<h1 id="0X01-硬链接"><a href="#0X01-硬链接" class="headerlink" title="0X01 硬链接"></a>0X01 硬链接</h1><p><strong>硬链接就是指向磁盘中具体位置的指针。</strong>如果我们创建一个文件，那么就会在磁盘中分配一块位置用来存储这个文件，并且创建一个指针方便我们找到这个文件。然后我们创建一个这个文件的硬链接，就相当于又创建了一个<strong>指向磁盘中存放文件的位置的指针</strong>，所以就算我们删除了之前创建的文件（其实就是一个指针），文件本身也不会被删除，因为还是有一个指针是指向文件存储位置的，所以我们还是可以通过后来创建的硬链接来访问到原来的文件。</p>
<h1 id="0X02-软链接——符号链接"><a href="#0X02-软链接——符号链接" class="headerlink" title="0X02 软链接——符号链接"></a>0X02 软链接——符号链接</h1><p><strong>软连接可以大致理解成指向指针的指针。</strong>如果我们创建一个文件，并且创建了这个文件的一个软连接，那么如果删除了原来的文件，那这个文件就真的找不到了。因为软连接只是指向之前（指向具体文件位置）的指针，所以那个软连接就指向一片空白区域了，以前存在的文件也找不到了。就好像我们在Windows中卸载了一个软件，但是桌面上的快捷方式还可能存在，现在我们打开那个快捷方式是不能访问到软件的，因为已经被我们删除了。</p>
<h1 id="0X03-操作演示"><a href="#0X03-操作演示" class="headerlink" title="0X03 操作演示"></a>0X03 操作演示</h1><p>首先我这里有一个<code>hehe.tar.gz</code>的文件，我们查看一下它的inode是33515290。然后创建一个硬链接名为<code>heihei.tar.gz</code>，再查看这两个文件的inode，发现两个文件的inode是一样的。再创建一个软连接名为<code>haha.tar.gz</code>，继续查看文件inode。可以看到系统给<code>haha.tar.gz</code>分配了一个新的inode，并且ls的时候有个箭头显示了指向什么文件。</p>
<blockquote>
<p>ls -i 可以显示文件的inode</p>
</blockquote>
<p><img src="http://o6sowsew8.bkt.clouddn.com/VirtualBox_CentOS_Study_16_05_2016_20_10_26.png" alt="alt text"></p>
<h1 id="0X04-软硬链接对比"><a href="#0X04-软硬链接对比" class="headerlink" title="0X04 软硬链接对比"></a>0X04 软硬链接对比</h1><h2 id="硬链接："><a href="#硬链接：" class="headerlink" title="硬链接："></a>硬链接：</h2><p>不分配新的inode<br>不可以在不同的文件系统之间链接<br>只有root才能创建目录的硬链接<br>只能源于存在的文件</p>
<h2 id="软链接："><a href="#软链接：" class="headerlink" title="软链接："></a>软链接：</h2><p>分配新的inode<br>不受文件系统的限制<br>指向源文件位置的标识<br>可以链向不存在的文件</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Soft Link </tag>
            
            <tag> Hard Link </tag>
            
            <tag> Link </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Apache配置虚拟主机 VirtualHost 多站点]]></title>
      <url>/2016/05/08/apache-vhost/</url>
      <content type="html"><![CDATA[<p>如果我们只有一台服务器，应该怎么实现让这台服务器同时处理PHP和JSP的请求？<br>这里的解决方案是通过Apache的虚拟主机（vhost）来进行端口转发。<br>Apache会通过访问服务器的域名将请求转发至不同的端口或者不同的服务器。</p>
<a id="more"></a>

<h1 id="0X00-前提-amp-目的"><a href="#0X00-前提-amp-目的" class="headerlink" title="0X00 前提&amp;目的"></a>0X00 前提&amp;目的</h1><p>前提：<br>　　拥有一个域名，并有两个A解析，同时解析到这台服务器的IP<br>　　分别拥有一个JSP和PHP的页面（网站）<br>目的：<br>　　使用php.test.com访问的时候解析到PHP的网站上<br>　　使用jsp.test.com访问的时候解析到JSP的网站上<br>操作系统：<br>    Centos 7.x 如果是之前的版本或是其他系统可能出现不同的情况</p>
<h1 id="0X01-安装httpd-Apache"><a href="#0X01-安装httpd-Apache" class="headerlink" title="0X01 安装httpd  (Apache)"></a>0X01 安装httpd  (Apache)</h1><p>安装并启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd</span><br><span class="line">systemctl start httpd.service</span><br></pre></td></tr></table></figure>

<h1 id="0X02-安装PHP"><a href="#0X02-安装PHP" class="headerlink" title="0X02 安装PHP"></a>0X02 安装PHP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install php</span><br></pre></td></tr></table></figure>

<h1 id="0X03-安装JDK用来配合JSP"><a href="#0X03-安装JDK用来配合JSP" class="headerlink" title="0X03 安装JDK用来配合JSP"></a>0X03 安装JDK用来配合JSP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<h1 id="0X04-安装tomcat用于解析JSP页面"><a href="#0X04-安装tomcat用于解析JSP页面" class="headerlink" title="0X04 安装tomcat用于解析JSP页面"></a>0X04 安装tomcat用于解析JSP页面</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install tomcat tomcat-webapps tomcat-admin-webapps</span><br><span class="line">systemctl start tomcat.service</span><br></pre></td></tr></table></figure>
<h1 id="0X05-配置httpd用于同时支持PHP和JSP"><a href="#0X05-配置httpd用于同时支持PHP和JSP" class="headerlink" title="0X05 配置httpd用于同时支持PHP和JSP"></a>0X05 配置httpd用于同时支持PHP和JSP</h1><p>打开配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br></pre></td></tr></table></figure>
<p>在配置文件的最前端添加如下内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NameVirtualHost *:80</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></span><br><span class="line">        ServerName php.test.com #指定一个域名</span><br><span class="line">        DocumentRoot /var/www/html #PHP网站的位置</span><br><span class="line">        ErrorLog logs/php.test.com-error.log #日志位置</span><br><span class="line">        CustomLog logs/php.test.com-access.log common #日志位置</span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></span><br><span class="line">        ServerName jsp.test.com #指定另一个域名</span><br><span class="line">        DocumentRoot /var/lib/tomcat/webapps/ROOT #JSP网站的位置</span><br><span class="line">        ErrorLog logs/jsp.test.com-error.log  #日志位置</span><br><span class="line">        CustomLog logs/jsp.test.com-access.log common #日志位置</span><br><span class="line">        ProxyPass / http://127.0.0.1:8080/ #转发位置</span><br><span class="line">        ProxyPassReverse / http://127.0.0.1:8080/ #转发位置</span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="0X06-最后"><a href="#0X06-最后" class="headerlink" title="0X06 最后"></a>0X06 最后</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart httpd.service</span><br><span class="line">systemctl restart tomcat.service</span><br></pre></td></tr></table></figure>
<p>现在就可以使用php.test.com 和 jsp.test.com分别访问到PHP和JSP的页面了</p>
]]></content>
      
        
        <tags>
            
            <tag> Apache </tag>
            
            <tag> Web Server </tag>
            
            <tag> VPS </tag>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mariadb/MySQL 增删查改 数据库操作 建表 建数据库]]></title>
      <url>/2016/03/15/mysql-crud/</url>
      <content type="html"><![CDATA[<p>首先需要安装好MySQL/Mariadb的服务端和客户端，并且能连接到服务端</p>
<blockquote>
<p>命令中的大写字母是SQL的关键字，小写字母是自己的相关属性和数据</p>
</blockquote>
<h1 id="0X00-连接到数据库"><a href="#0X00-连接到数据库" class="headerlink" title="0X00 连接到数据库"></a>0X00 连接到数据库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用mysql连接到127.0.0.1并用root用户登陆，密码等待输入</span><br><span class="line">mysql -h 127.0.0.1 -u root -p</span><br></pre></td></tr></table></figure>

<h1 id="0X01-创建数据库"><a href="#0X01-创建数据库" class="headerlink" title="0X01 创建数据库"></a>0X01 创建数据库</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建一个名为school的数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> school;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="0X02-建立一个表"><a href="#0X02-建立一个表" class="headerlink" title="0X02 建立一个表"></a>0X02 建立一个表</h1><p>建立一个名为student的表<br>索引：<br>10个字符长度的name   不能为空<br>11个字符长度的number 不能为空<br>int类型的age        不能为空</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> school;</span><br><span class="line">使用school这个数据库</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">number</span> <span class="built_in">VARCHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">age <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="built_in">number</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="0X03-查询数据库和表"><a href="#0X03-查询数据库和表" class="headerlink" title="0X03 查询数据库和表"></a>0X03 查询数据库和表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line">查看所有数据库</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> BALES;</span><br><span class="line">查看正在使用的数据库中的表</span><br></pre></td></tr></table></figure>

<h1 id="0X04-插入数据"><a href="#0X04-插入数据" class="headerlink" title="0X04 插入数据"></a>0X04 插入数据</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">&#x27;lilei&#x27;</span>,<span class="string">&#x27;666&#x27;</span>,<span class="number">15</span>);</span><br><span class="line">插入新的数据，按照顺序写</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (<span class="keyword">name</span>)<span class="keyword">VALUES</span>(<span class="string">&#x27;hanmeimei&#x27;</span>);</span><br><span class="line">自定义顺序写入</span><br></pre></td></tr></table></figure>

<h1 id="0X05-查询数据"><a href="#0X05-查询数据" class="headerlink" title="0X05 查询数据"></a>0X05 查询数据</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student;</span><br><span class="line">查询student表中的所有name</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="built_in">number</span>=<span class="number">0002</span>;</span><br><span class="line">查询student表中number为0002的name</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">30</span>;</span><br><span class="line">查询student表中age在20到30之间的name</span><br></pre></td></tr></table></figure>

<h1 id="0X06-更新数据"><a href="#0X06-更新数据" class="headerlink" title="0X06 更新数据"></a>0X06 更新数据</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">&#x27;xiaohei&#x27;</span> <span class="keyword">WHERE</span> <span class="built_in">number</span>=<span class="string">&#x27;0002&#x27;</span>;</span><br><span class="line">把所有number为0002的name更新为xiaohei</span><br></pre></td></tr></table></figure>

<h1 id="0X07-删除数据"><a href="#0X07-删除数据" class="headerlink" title="0X07 删除数据"></a>0X07 删除数据</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="built_in">number</span>=<span class="string">&#x27;0002&#x27;</span></span><br><span class="line">删除所有<span class="built_in">number</span>为<span class="number">0002</span>的数据</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
            <tag> MariaDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 抽象类和接口 理解抽象类和接口]]></title>
      <url>/2015/11/21/java-class-interface/</url>
      <content type="html"><![CDATA[<h1 id="0X00抽象类-amp-接口简介"><a href="#0X00抽象类-amp-接口简介" class="headerlink" title="0X00抽象类&amp;接口简介"></a>0X00抽象类&amp;接口简介</h1><p>抽象类</p>
<ol>
<li>abstract 抽象修饰符——抽象就是为了让子类集成的，并不能直接实现一个对象</li>
<li>抽象类中所有抽象方法都要在子类中实现</li>
<li>拥有抽象方法的类必须声明为抽象类</li>
<li>抽象类可以有非抽象的方法</li>
</ol>
<p>接口</p>
<ol>
<li>interface 接口修饰符——接口是为了让类实现的</li>
<li>变量默认是public static final并且不能改变</li>
<li>方法默认是public abstract并且不能改变</li>
<li>接口不实现方法</li>
</ol>
<a id="more"></a>

<h1 id="0X01抽象类和接口的区别"><a href="#0X01抽象类和接口的区别" class="headerlink" title="0X01抽象类和接口的区别"></a>0X01抽象类和接口的区别</h1><ol>
<li>抽象类可以实现方法细节，接口不能</li>
<li>抽象类的变量可以是各种类型的，接口不能</li>
<li>抽象类可以有静态代码块和静态方法，接口不能</li>
<li>一个类可以实现多个接口，而只能继承自一个抽象类</li>
<li>继承可以理解成“是不是”，接口可以理解成“有没有”</li>
</ol>
<h1 id="0X02举个例子"><a href="#0X02举个例子" class="headerlink" title="0X02举个例子"></a>0X02举个例子</h1><p>有一个接口CanFly</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个抽象类Bird</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I can eat insect~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个Sparrow类继承自Bird</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">CanFly</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I can fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个抽象类Airplane</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Crash</span><span class="params">()</span></span>&#123;   <span class="comment">//坠毁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;This airplane is crashed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个Jian_10类继承自Airplane</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jian_10</span> <span class="keyword">extends</span> <span class="title">Airplane</span> <span class="keyword">implements</span> <span class="title">CanFly</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I can fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个包含主方法的类来测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jian_10 A_0 = <span class="keyword">new</span> Jian_10();<span class="comment">//实例化A_0号战机</span></span><br><span class="line">        Sparrow xiaoMing = <span class="keyword">new</span> Sparrow();<span class="comment">//没错，这只麻雀叫小明</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们都能飞</span></span><br><span class="line">        A_0.fly();</span><br><span class="line">        xiaoMing.fly();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小明吃饭了</span></span><br><span class="line">        xiaoMing.eat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//战机坠毁了</span></span><br><span class="line">        A_0.Crash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I can fly</span><br><span class="line">I can fly</span><br><span class="line">I can eat insect~</span><br><span class="line">This airplane is crashed!</span><br></pre></td></tr></table></figure>

<h1 id="0X03粗略解释"><a href="#0X03粗略解释" class="headerlink" title="0X03粗略解释"></a>0X03粗略解释</h1><p>大概是这么回事：<br>Airplane和Bird是两个抽象类，Jian_10和Sparrow分别继承自他们，所以子类可以直接调用父类的方法。且Jian_10和Sparrow还有接口CanFly 。然后Jian_10和Sparrow实现了接口CanFly中声明的fly方法（必须实现）。<br>如果以后想要修改Airplane和Bird两个父类的方法的时候，比如我不想让Bird吃东西了或者Airplane不会坠毁了，就只需要修改Airplane和Bird中相应的方法。</p>
<blockquote>
<p>一个类只能继承自一个类&amp;抽象类，但是可以实现多个接口</p>
</blockquote>
<p>比如，Airplane和Bird有很多相同的方法，但是实现不尽相同，我们就可以把这些方法放到一个接口中。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> OOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言 推箱子 Gcc编译通过]]></title>
      <url>/2015/10/19/c-push-box/</url>
      <content type="html"><![CDATA[<h1 id="0X00-编译环境"><a href="#0X00-编译环境" class="headerlink" title="0X00 编译环境"></a>0X00 编译环境</h1><p>Ubuntu 14.04 + GNU/gcc<br>如果要在Windows下编译的话，* 可能 * 需要注释掉16-18的编译预处理，还 * 可能 * 要注释掉getch()的函数声明及定义，最后在加上conio.h的头文件。</p>
<h1 id="0X01-遇到的问题"><a href="#0X01-遇到的问题" class="headerlink" title="0X01 遇到的问题"></a>0X01 遇到的问题</h1><p>Windows中能使用getch()函数，这个函数是以输入流的方式输入。（简单地说就是按下去一个按键就能有反应，而不用点击回车）。但是在Linux环境下没有这个函数也没有connio.h的头文件。但是每次按一下还要按回车还是挺逆天的。不过我在网上找到了替代品（感谢<em>幽鬼</em>）</p>
<blockquote>
<p><a href="http://my.oschina.net/yougui/blog/111345">http://my.oschina.net/yougui/blog/111345</a></p>
</blockquote>
<a id="more"></a>

<h1 id="0X02-代码实现"><a href="#0X02-代码实现" class="headerlink" title="0X02 代码实现"></a>0X02 代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************</span></span><br><span class="line"><span class="comment"> * Project name     : push the boxs</span></span><br><span class="line"><span class="comment"> * Create date      : 2015.10.17</span></span><br><span class="line"><span class="comment"> * Last modify date : 2015.10.19</span></span><br><span class="line"><span class="comment"> * Auther name      : mouse_ts</span></span><br><span class="line"><span class="comment"> * E-mail address   : michaelhaozi@hotmail.com</span></span><br><span class="line"><span class="comment"> * Description      : this is game, you control a boy push the boxs</span></span><br><span class="line"><span class="comment"> * to the destination. but you can&#x27;t push the stone and two boxs.</span></span><br><span class="line"><span class="comment"> * if you&#x27;r box touch the wall , you can&#x27;t pull it.</span></span><br><span class="line"><span class="comment"> * ****************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;//using getch()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//this is constant</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX    10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WALL   6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLAYER 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOX    8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLANK  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DES    9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W      <span class="meta-string">&#x27;w&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A      <span class="meta-string">&#x27;a&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S      <span class="meta-string">&#x27;s&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D      <span class="meta-string">&#x27;d&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//this is game map</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//player</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">player</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;player;</span><br><span class="line"></span><br><span class="line"><span class="comment">//boxs</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;box_1, box_2, box_3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//des</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">des</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;des_1, des_2, des_3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//statement function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMap</span><span class="params">()</span></span>;         <span class="comment">//init the map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPlayer</span><span class="params">()</span></span>;      <span class="comment">//init the player</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initBox</span><span class="params">()</span></span>;         <span class="comment">//init the boxs</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDes</span><span class="params">()</span></span>;         <span class="comment">//init the des</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">()</span></span>;        <span class="comment">//print the map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMap</span><span class="params">()</span></span>;          <span class="comment">//set the player, boxs, des</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getch</span><span class="params">()</span></span>;           <span class="comment">//getch()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUP</span><span class="params">()</span></span>;            <span class="comment">//go up</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goDown</span><span class="params">()</span></span>;          <span class="comment">//go down</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goLeft</span><span class="params">()</span></span>;          <span class="comment">//go left</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goRight</span><span class="params">()</span></span>;         <span class="comment">//go right</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">computingSuccess</span><span class="params">()</span></span>;<span class="comment">//computing how many box seccessd</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init the game</span></span><br><span class="line">    initMap();</span><br><span class="line">    initPlayer();</span><br><span class="line">    initBox();</span><br><span class="line">    setMap();</span><br><span class="line">    printMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//control the boy</span></span><br><span class="line">    <span class="keyword">while</span> (ch = getch())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)<span class="comment">//where is the boy move</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> W:</span><br><span class="line">                goUP();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> A:</span><br><span class="line">                goLeft();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> S:</span><br><span class="line">                goDown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> D:</span><br><span class="line">                goRight();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            defualt:</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">&quot;You should press w, a, s, d to control the boy to move\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setMap();</span><br><span class="line">        system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">        printMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (computingSuccess() == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;\n\n\n\n\n\n\n             You win the game!\n&quot;</span>);</span><br><span class="line">    getch();</span><br><span class="line">    system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getch()   by.YouGui   http://my.oschina.net/yougui/blog/111345</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">org_opts</span>, <span class="title">new_opts</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res = tcgetattr(STDIN_FILENO, &amp;org_opts);</span><br><span class="line">    assert(res == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;new_opts, &amp;org_opts, <span class="keyword">sizeof</span>(new_opts));</span><br><span class="line">    new_opts.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ECHOK | ECHONL | ECHOPRT | ECHOKE | ICRNL);</span><br><span class="line">    tcsetattr(STDIN_FILENO, TCSANOW, &amp;new_opts);</span><br><span class="line">    c = getchar();</span><br><span class="line">    res = tcsetattr(STDIN_FILENO, TCSANOW, &amp;org_opts);</span><br><span class="line">    assert(res == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init this map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[i][j] = WALL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">2</span>] = BLANK;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">3</span>] = BLANK;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">5</span>] = BLANK;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">6</span>] = BLANK;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">7</span>] = BLANK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">4</span>] = BLANK;</span><br><span class="line"></span><br><span class="line">    initDes();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;This is a game !\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == WALL)</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">&quot; # &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == BOX)</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">&quot; @ &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == PLAYER)</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">&quot; X &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == BLANK)</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == DES)</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">&quot; O &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init the player</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    player.x = <span class="number">2</span>;</span><br><span class="line">    player.y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init the boxs</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initBox</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    box_1.x = <span class="number">3</span>;</span><br><span class="line">    box_1.y = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    box_2.x = <span class="number">4</span>;</span><br><span class="line">    box_2.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    box_3.x = <span class="number">6</span>;</span><br><span class="line">    box_3.y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init the des</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    des_1.x = <span class="number">5</span>;</span><br><span class="line">    des_1.y = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    des_2.x = <span class="number">6</span>;</span><br><span class="line">    des_2.y = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    des_3.x = <span class="number">7</span>;</span><br><span class="line">    des_3.y = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set blank</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">2</span>] = BLANK;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">3</span>] = BLANK;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">5</span>] = BLANK;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">6</span>] = BLANK;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">7</span>] = BLANK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>[<span class="number">5</span>][<span class="number">4</span>] = BLANK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set des</span></span><br><span class="line">    <span class="built_in">map</span>[des_1.x][des_1.y] = DES;</span><br><span class="line">    <span class="built_in">map</span>[des_2.x][des_2.y] = DES;</span><br><span class="line">    <span class="built_in">map</span>[des_3.x][des_3.y] = DES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set player</span></span><br><span class="line">    <span class="built_in">map</span>[player.x][player.y] = PLAYER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set box</span></span><br><span class="line">    <span class="built_in">map</span>[box_1.x][box_1.y] = BOX;</span><br><span class="line">    <span class="built_in">map</span>[box_2.x][box_2.y] = BOX;</span><br><span class="line">    <span class="built_in">map</span>[box_3.x][box_3.y] = BOX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//computing the success move the box to the des</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computingSuccess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[des_1.x][des_1.y] == BOX)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[des_2.x][des_2.y] == BOX)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[des_3.x][des_3.y] == BOX)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * after this is control your boy to move up down left and right</span></span><br><span class="line"><span class="comment"> * all of the  functions to control the boy to move</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//control the boy go up</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[player.x - <span class="number">1</span>][player.y] == BLANK ||</span><br><span class="line">        <span class="built_in">map</span>[player.x - <span class="number">1</span>][player.y] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        player.x--;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (player.x - <span class="number">1</span> == box_1.x &amp;&amp; player.y == box_1.y &amp;&amp;</span><br><span class="line">        <span class="built_in">map</span>[box_1.x - <span class="number">1</span>][box_1.y] == BLANK ||</span><br><span class="line">        player.x - <span class="number">1</span> == box_1.x &amp;&amp; player.y == box_1.y &amp;&amp;</span><br><span class="line">        <span class="built_in">map</span>[box_1.x - <span class="number">1</span>][box_1.y] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_1.x--;</span><br><span class="line">        player.x--;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (player.x - <span class="number">1</span> == box_2.x &amp;&amp; player.y == box_2.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_2.x - <span class="number">1</span>][box_2.y] == BLANK ||</span><br><span class="line">             player.x - <span class="number">1</span> == box_2.x &amp;&amp; player.y == box_2.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_2.x - <span class="number">1</span>][box_2.y] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_2.x--;</span><br><span class="line">        player.x--;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (player.x - <span class="number">1</span> == box_3.x &amp;&amp; player.y == box_3.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_3.x - <span class="number">1</span>][box_3.y] == BLANK ||</span><br><span class="line">             player.x - <span class="number">1</span> == box_3.x &amp;&amp; player.y == box_3.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_3.x - <span class="number">1</span>][box_3.y] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_3.x--;</span><br><span class="line">        player.x--;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//control the boy go down</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[player.x + <span class="number">1</span>][player.y] == BLANK ||</span><br><span class="line">        <span class="built_in">map</span>[player.x + <span class="number">1</span>][player.y] == DES)</span><br><span class="line">        player.x++;</span><br><span class="line">    <span class="keyword">if</span> (player.x + <span class="number">1</span> == box_1.x &amp;&amp; player.y == box_1.y &amp;&amp;</span><br><span class="line">        <span class="built_in">map</span>[box_1.x + <span class="number">1</span>][box_1.y] == BLANK ||</span><br><span class="line">        player.x + <span class="number">1</span> == box_1.x &amp;&amp; player.y == box_1.y &amp;&amp;</span><br><span class="line">        <span class="built_in">map</span>[box_1.x + <span class="number">1</span>][box_1.y] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_1.x++;</span><br><span class="line">        player.x++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (player.x + <span class="number">1</span> == box_2.x &amp;&amp; player.y == box_2.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_2.x + <span class="number">1</span>][box_2.y] == BLANK ||</span><br><span class="line">             player.x + <span class="number">1</span> == box_2.x &amp;&amp; player.y == box_2.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_2.x + <span class="number">1</span>][box_2.y] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_2.x++;</span><br><span class="line">        player.x++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (player.x + <span class="number">1</span> == box_3.x &amp;&amp; player.y == box_3.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_3.x + <span class="number">1</span>][box_3.y] == BLANK ||</span><br><span class="line">             player.x + <span class="number">1</span> == box_3.x &amp;&amp; player.y == box_3.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_3.x + <span class="number">1</span>][box_3.y] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_3.x++;</span><br><span class="line">        player.x++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//control the boy go left</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goLeft</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[player.x][player.y - <span class="number">1</span>] == BLANK ||</span><br><span class="line">        <span class="built_in">map</span>[player.x][player.y - <span class="number">1</span>] == DES)</span><br><span class="line">        player.y--;</span><br><span class="line">    <span class="keyword">if</span> (player.x == box_1.x &amp;&amp; player.y - <span class="number">1</span> == box_1.y &amp;&amp;</span><br><span class="line">        <span class="built_in">map</span>[box_1.x][box_1.y - <span class="number">1</span>] == BLANK ||</span><br><span class="line">        player.x == box_1.x &amp;&amp; player.y - <span class="number">1</span> == box_1.y &amp;&amp;</span><br><span class="line">        <span class="built_in">map</span>[box_1.x][box_1.y - <span class="number">1</span>] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_1.y--;</span><br><span class="line">        player.y--;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (player.x == box_2.x &amp;&amp; player.y - <span class="number">1</span> == box_2.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_2.x][box_2.y - <span class="number">1</span>] == BLANK ||</span><br><span class="line">             player.x == box_2.x &amp;&amp; player.y - <span class="number">1</span> == box_2.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_2.x][box_2.y - <span class="number">1</span>] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_2.y--;</span><br><span class="line">        player.y--;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (player.x == box_3.x &amp;&amp; player.y - <span class="number">1</span> == box_3.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_3.x][box_3.y - <span class="number">1</span>] == BLANK ||</span><br><span class="line">             player.x == box_3.x &amp;&amp; player.y - <span class="number">1</span> == box_3.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_3.x][box_3.y - <span class="number">1</span>] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_3.y--;</span><br><span class="line">        player.y--;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//control the boy go right</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goRight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[player.x][player.y + <span class="number">1</span>] == BLANK ||</span><br><span class="line">        <span class="built_in">map</span>[player.x][player.y + <span class="number">1</span>] == DES)</span><br><span class="line">        player.y++;</span><br><span class="line">    <span class="keyword">if</span> (player.x == box_1.x &amp;&amp; player.y + <span class="number">1</span> == box_1.y &amp;&amp;</span><br><span class="line">        <span class="built_in">map</span>[box_1.x][box_1.y + <span class="number">1</span>] == BLANK ||</span><br><span class="line">        player.x == box_1.x &amp;&amp; player.y + <span class="number">1</span> == box_1.y &amp;&amp;</span><br><span class="line">        <span class="built_in">map</span>[box_1.x][box_1.y + <span class="number">1</span>] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_1.y++;</span><br><span class="line">        player.y++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (player.x == box_2.x &amp;&amp; player.y + <span class="number">1</span> == box_2.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_2.x][box_2.y + <span class="number">1</span>] == BLANK ||</span><br><span class="line">             player.x == box_2.x &amp;&amp; player.y + <span class="number">1</span> == box_2.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_2.x][box_2.y + <span class="number">1</span>] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_2.y++;</span><br><span class="line">        player.y++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (player.x == box_3.x &amp;&amp; player.y + <span class="number">1</span> == box_3.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_3.x][box_3.y + <span class="number">1</span>] == BLANK ||</span><br><span class="line">             player.x == box_3.x &amp;&amp; player.y + <span class="number">1</span> == box_3.y &amp;&amp;</span><br><span class="line">             <span class="built_in">map</span>[box_3.x][box_3.y + <span class="number">1</span>] == DES)</span><br><span class="line">    &#123;</span><br><span class="line">        box_3.y++;</span><br><span class="line">        player.y++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> C Programing Lanuage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python命令行日历 获取时间 格式化输出]]></title>
      <url>/2015/07/07/python-cal/</url>
      <content type="html"><![CDATA[<p>实现简单日历</p>
<blockquote>
<p>读取当前时间并显示本月日历<br>输出格式化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#It&#x27;s my first Python program</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#get date 获取当前日期</span></span><br><span class="line">year  = time.strftime(<span class="string">&#x27;%Y&#x27;</span>, time.localtime(time.time()))</span><br><span class="line">year = (int)(year)</span><br><span class="line">month = time.strftime(<span class="string">&#x27;%m&#x27;</span>, time.localtime(time.time()))</span><br><span class="line">day   = time.strftime(<span class="string">&#x27;%d&#x27;</span>, time.localtime(time.time()))</span><br><span class="line">day = (int)(day)</span><br><span class="line">week  = time.strftime(<span class="string">&#x27;%w&#x27;</span>, time.localtime(time.time()))</span><br><span class="line"></span><br><span class="line">week = (int)(week)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, day - <span class="number">1</span>):</span><br><span class="line">    week = week - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> week == <span class="number">-1</span>:</span><br><span class="line">        week = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#judge leap 判断是否是闰年</span></span><br><span class="line"><span class="keyword">if</span> year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">400</span> != <span class="number">0</span> <span class="keyword">or</span> year % <span class="number">400</span> == <span class="number">0</span> :</span><br><span class="line">    isLeap = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    isLeap = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#all Day这个月一共有多少天</span></span><br><span class="line"><span class="keyword">if</span> month == <span class="string">&#x27;01&#x27;</span> <span class="keyword">or</span> month == <span class="string">&#x27;03&#x27;</span> <span class="keyword">or</span> month == <span class="string">&#x27;05&#x27;</span> <span class="keyword">or</span> month == <span class="string">&#x27;07&#x27;</span> <span class="keyword">or</span> month == <span class="string">&#x27;08&#x27;</span> <span class="keyword">or</span> month == <span class="string">&#x27;10&#x27;</span> <span class="keyword">or</span> month == <span class="string">&#x27;12&#x27;</span> :</span><br><span class="line">    allDay = <span class="number">31</span></span><br><span class="line"><span class="keyword">elif</span> month == <span class="string">&#x27;02&#x27;</span> <span class="keyword">and</span> isLeap :</span><br><span class="line">    allDay = <span class="number">29</span></span><br><span class="line"><span class="keyword">elif</span> month == <span class="string">&#x27;02&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> isLeap :</span><br><span class="line">    allDay = <span class="number">28</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    allDay = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print CAL  输出这个月的日历</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;            &#x27;</span> + str(year) + <span class="string">&#x27;   &#x27;</span> + str(month)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;Sun  Mon  Tue  Wed  Thu  Fri  Sat&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(week) :   <span class="comment">#print space   输出空白部分</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;    &#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, allDay + <span class="number">1</span>) :   <span class="comment">#print everday  输出日期</span></span><br><span class="line">    x = str(i)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&#x27;%-4s&#x27;</span> % x,</span><br><span class="line">    week = week + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> week == <span class="number">7</span> :</span><br><span class="line">        week = <span class="number">0</span></span><br><span class="line">        <span class="keyword">print</span></span><br><span class="line"></span><br><span class="line">raw_input()</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Demo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 目录结构 理解Linux目录树]]></title>
      <url>/2015/06/09/linux-dirtree/</url>
      <content type="html"><![CDATA[<h1 id="0X00-Linux文件目录结构"><a href="#0X00-Linux文件目录结构" class="headerlink" title="0X00 Linux文件目录结构"></a>0X00 Linux文件目录结构</h1><p>　　我们在Windows环境下的文件目录结构大概是几个盘符，C盘D盘E盘…但是在Linux下是树状图（其实Windows内部也是树状图）。Linux下一个主要目录是<code>/</code>根目录，其他所有目录都在根目录下，其他的磁盘或者分区也都挂载在根目录下。</p>
<p>　　挂载：比如我的<code>/media/shawn/new_disk</code>是一个空的目录，那我就可以把一个分区挂载到这个目录下，就相当于你挂了一个瓶子在某个树杈上，这样你在瓶子（分区）装的文件就只占用你的瓶子（分区）空间，并不会占据树上的空间。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">            |------------- bin     是binary的简写，保存可执行文件，此处的都二进制文件所有用户都有执行权限</span><br><span class="line">            |------------- boot    引导目录，负责引导启动系统。目录中的vmlinux是内核文件</span><br><span class="line">            |------------- dev     是Device的简写，保存设备文件。Uinux哲学中“一切皆文件”，设备被抽象成文件</span><br><span class="line">            |------------- home    用户的主目录，每个用户默认在此有一个自己的主目录。root用户的主目录在根目录下&#96;&#x2F;root&#96;</span><br><span class="line">            |------------- lib     保存库文件</span><br><span class="line">            |------------- media   挂载驱动器（U盘或者磁盘分区等），并不是所有发行版本都有这个文件夹</span><br><span class="line">            |------------- mnt     和media的功能几乎完全一致，该目录所有发行版本都有</span><br><span class="line">           &#x2F; ------------- opt     是option的简写，用来安装各种大型软件</span><br><span class="line">&#x2F;   ------</span><br><span class="line">           \</span><br><span class="line">            |------------- proc    是process的简写，不是一个真实存在的目录，可以查看目录的信息判断。用来保存系统实时信息，各个进程的和内存信息</span><br><span class="line">            |------------- sbin    是super binary的简写，保存可执行文件，此处的文件是只有超级管理员可以使用的</span><br><span class="line">            |------------- selinux 保存SELinux的相关内容（SELinux是美国国安局开发的安全系统，开源并整合到了Linux内核中）</span><br><span class="line">            |------------- sys     保存系统底层信息，硬件信息</span><br><span class="line">            |------------- temp    临时目录，系统会自动删除清理</span><br><span class="line">            |------------- usr     应用软件的默认安装位置</span><br><span class="line">            |------------- var     是variable的简写，用来保存经常变动的文件比如日志信息和邮件等</span><br></pre></td></tr></table></figure>

<h1 id="0X01-Proc文件介绍"><a href="#0X01-Proc文件介绍" class="headerlink" title="0X01 Proc文件介绍"></a>0X01 Proc文件介绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cpuconf    CPU的实时信息</span><br><span class="line">memconf    内存的实时信息</span><br><span class="line">iomem      I&#x2F;O信息</span><br><span class="line">interrupts 中断信息</span><br><span class="line">uptime     启动时间</span><br><span class="line">acpi       电源信息</span><br><span class="line">凌乱的数字   可以理解成每个目录都是一个进程，目录里是进程的相关信息</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Diiectory Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言中的Bool类型]]></title>
      <url>/2015/03/17/c-language-bool-type/</url>
      <content type="html"><![CDATA[<p>　　最近在网上看到有的说法里是没有bool类型的，不过以前在书上好像看到过相关的介绍，就特意找出来了那本书《C Primer Plus》，确定了C语言里确实存在bool类型。C语言是在C99标准中添加的bool类型。</p>
<blockquote>
<p>bool类型是以英国数学家 * George Boole * 命名的，是他开发了用线性代数表示并解决逻辑问题的系统。</p>
</blockquote>
<p>　　在C语言中我们使用 _Bool 来定义bool类型的变量</p>
<p>　　下面定义了一个_Bool类型的变量，并把(1 == 3)的计算值赋值给test</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">_Bool</span> test;</span><br><span class="line">    test = (<span class="number">1</span> == <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　下面能证明bool类型变量的特点<br>　　　　只有0和1两个值<br>　　　　只有0赋值给bool类型时，bool才为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">_Bool</span> test;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">-10</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        test = i;</span><br><span class="line">        <span class="keyword">if</span> (test)</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;true\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;false\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 　　最后我们证明一下bool类型比int类型占的内存要少</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myint;</span><br><span class="line">    <span class="built_in">_Bool</span> mybool;</span><br><span class="line">    <span class="keyword">int</span> memint;</span><br><span class="line">    <span class="keyword">int</span> membool;</span><br><span class="line"></span><br><span class="line">    memint = <span class="keyword">sizeof</span>(myint);</span><br><span class="line">    membool = <span class="keyword">sizeof</span>(mybool);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;int   = %d\n&quot;</span>, memint);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;_Bool = %d\n&quot;</span>, membool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> C Programing Lanuage </tag>
            
            <tag> Bool </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
